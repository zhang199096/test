/**********************************************************************
*   file name: task2.c
*   author : vinge
*   create date: 20080819
*   version: 0: 20080819--init version,  ;
***********************************************************************
*/
//#define DEBUG
#include "../include/key.h"
#include "../include/spi.h"
#include "../include/structpacket.h"
#include "task2.h"
#include <math.h>
//#define FAIT_SEND2DSP  //dont't really send gcode to dsp for debug, it remove crc
//#include "msg_mem.h"
#include "../include/sharemem.h"
#include <stdlib.h>
#define TASK_LED_INTERVAL 500
#define TASK_LED_INTERVAL2 1000
#define TASK2EVENT_MAX 8
U8 task2inited=0;
U32 taskEventBuf[TASK2EVENT_MAX+4]={0,}; //left 1 empty
U8 taskEventCount=0;

U32 resetTimer=0;
#define DSP_KEEPALIVE_TIME (5)  //CYCLE
//#define WHELL_SIMPLE_TIME  (30)
U8 WHELL_SIMPLE_TIME=20;
U8 WHELL_CODE_TIME=25;
U16 whelldir=0;
U16 whellreachstart=0;
/*
jog key pos
0x01 0x02 0x04
0x08  __  0x10
0x20 0x40 0x80
__   xp   yp
zn   __   zp
yn   xn   __
*/

#define JOGKEY_XP  0X40
#define JOGKEY_ZP  0X01
#define JOGKEY_YP  0X05

#define JOGKEY_XN  0X04
#define JOGKEY_YN  0XA0
#define JOGKEY_ZN  0X02

//U32 task2led=0;

/*****************************************************************
* turun on and off led to show task runing;
*****************************************************************
*/
void updateLed2(void)
{
    task2led=~task2led;
    //计算主轴点动时间定时
    if(spindleSpotTimer>0)
    {
        spindleSpotTimer--;
        if(spindleSpotTimer==0)
        {
            gWorkState.sdir=5;
            spinRunSign=0;
            //gWorkState.s=spindleSpotSaveSpeed;
        }
    }
}
/*
*------------------------------------------------------------------------------
* function: Task2_main
* parameter: void
* return   : void
* description :task 2 main loop, task2 is to replace the arm 44b0 functions in F system.
*                   it handle net work, file, and keyboards .And most importent the G code
*
*------------------------------------------------------------------------------
*/

void Task2_main(void)
{
    static U32 network_time = 0;
    int plcfile,plclen,i,j;
    U8* temp;

    i=0;
    if(!task2inited)
    {
        //do init here
        //
        task2inited=TRUE;
        //----------------------------------------------------------
        //get param data form iic
        //sysReadIIcInit();
        //----------------------------------------------------------
        softResetVars();

        sysState=SYS_STATE_MDI;
        sysMode=SYS_MODE_MDI;
        resetTimer=100;
        taskEventCount=1;
    }

    while(task2inited)
    {
        taskct[2]++;
        //updateLed2();
        LEDflash(1);
        //SHM_CHAR_VALUE(SHM_CURGUI_ADDR) = machLockFlag;
        coordUpdate();

        handleEvent();
        //dsp commminulcation
        //armDspCom();
    
        handleEventAck();

        key_com();
        //std mode code
        execGcode();
        AssistenFunction();
        traceDSPrun();

        TOOLstand();

        alarmRecord();
        limitAlarmAutoClear();

        refFounded |= BITX|BITZ|BITY;

        if (shutdownsig) {
            return;
        }

        Task_sleep(2);//usleep(500);
    }
    //}
}

/*
*------------------------------------------------------------------------------
* function: keyInterval
* parameter:
* return   : void
* description :count 5 ms and handle one key package; systick is 500us,
* it only send or recv in one time, so time interval is set to 5
*
*------------------------------------------------------------------------------
* /
void keyInterval(void)
{
    #define KEY_CYCLE_TIME (8)
    static U32 keytime=0;
    //nowkeytick=OSGetTimeTick();
    keytime++;
    if(keytime>KEY_CYCLE_TIME)
    //||((S32)(nowkeytick-prevkeytick)<0))
    {
        keytime=0;
        //prevkeytick=nowkeytick;
        processKEY();
        keyHandle(); 
    }
}*/
/*
*------------------------------------------------------------------------------
* function: updateGUI
* parameter: void
* return   : void
* description : if any of the gui need updated, a flag is seted,
*    then we send a gui update message
*
*------------------------------------------------------------------------------
*/
void updateGUI()
{
    /*
    Parm2guiMsg msgptr =(Parm2guiMsg)arm2guiMsgPtr;
    if(FLAGguiUpdate==TRUE)
        return;
    if(*arm2guiFilled!=FALSE)
        return; //this mean that the gui not take the prev update yet
    msgptr->coordWork=coordWorkShow;
    msgptr->coordMach=coordMACHShow;
    msgptr->coordRemain=coordRemain;
    msgptr->coordRelate=coordRelate;
    msgptr->guinum=currentGUI;
    strcpy(msgptr->inputBuf,cmdbuf);
    msgptr->mode=sysMode;
    msgptr->g0f =1234;
    msgptr->g1f = realFeedSpeed;
    msgptr->g0grade = rapidGrade;
    msgptr->g1grade = feedGrade;

    *arm2guiFilled=TRUE; //set the pointer
    FLAGguiUpdate=FALSE;//clear the flag
    */
}
/*
*------------------------------------------------------------------------------
* function: handleEvent
* parameter: void
* return   : void
* description : handle the event given by the task 3 or task1 maybe
*
*------------------------------------------------------------------------------
*/
void handleEvent(void)
{
    //static U16 looptime=0;
    static U32 tick=0;
    static U32 b0tickprev=0;
    static U32 retranstickprev=0;
    U32 b0ticknow=0;
    U32 retransticknow;
    U16 i;
//-------------------------------------------------------------------------
    //U32 event=0xee;
    //shm_cycBufWrite(CYCBUF_ARMEVENT, &event, 1);
    //return;
//---------------------------------------------------------------------------
    //retransmission
    tick++;
    if((taskEventState==EVENT_STATE_SEND))
    {
        retransticknow=tick;//OSGetTimeTick();  //retrans machine
        if((retransticknow-retranstickprev)>5)
        {
            retranstickprev=retransticknow;
            taskEventState=EVENT_STATE_SEND;        
            arm2dspREQ=TRUE;
            retransFlag=TRUE;
            DSPStatisFail++;
        }
    }
    //---------------------------------------------------
    //keep alive
    if((taskEventCount==0)&&(taskEventState==EVENT_STATE_DONE))
    {
        b0ticknow=tick;//OSGetTimeTick(); //idle b0 trans machine
        if((b0ticknow-b0tickprev)>DSP_KEEPALIVE_TIME)
        {
            b0tickprev=b0ticknow;
            taskEventBuf[taskEventCount]=TEVENT_IDLE;
            taskEventCount++;
        }
    }
    //Get events from event buf
    if((taskEventState==EVENT_STATE_DONE)&&(taskEventCount>0))
    {   
        taskEvent=taskEventBuf[0];
        //DBASSERT((taskEventCount<TASK2EVENT_MAX));
        for(i=0;i<taskEventCount;i++)
        {
            taskEventBuf[i]=taskEventBuf[i+1];
        }
        taskEventState=EVENT_STATE_REQ;
        taskEventCount--;
        b0tickprev=tick;//OSGetTimeTick();  //update the idle start time
    }
    
    if(taskEventState!=EVENT_STATE_REQ)
        return;
    switch(taskEvent&0x000000ff)
    {
        //static U8 task2led=0;
        case(TEVENT_NONE):
            taskEventState=EVENT_STATE_DONE;
            return;
            break;
        case(TEVENT_MOD_MDI):
            //nothing move in mdi
            armCMDB0(ARMCMDB0_MDI);
            break;
        case(TEVENT_MOD_JOG):
        case(TEVENT_MOD_WHELL):
        case(TEVENT_MOD_ZERO):
            armCMDB0(ARMCMDB0_SPC);
			break;
       // case(TEVENT_COORDORGSET):
       //     armCMDB0(ARMCOMB0_CORGSET);
       //     break;
        case(TEVENT_MOD_AUTO):
            armCMDB0(ARMCMDB0_STD);
            break;
        //case(TEVENT_SENT_JOGCODE):
        //    jogCode();     //WHELL mode whould pass here buf do nothing;
        //    armCMDB4();
        //    break;
         case(TEVENT_COORDOFFSET):
             armCMDB0(ARMCMDB0_COFFSET);
             break;
        //case(TEVENT_SENT_BATCODE):
        //    armCMDB3((U8*)0);
            break;
        case(TEVENT_FIND_REF):
            task2FindReference();
            break;/*
         //*************************************************************
         case(TEVENT_SEND_SYSPARAM):
             armCMDB1();
             break;

         case(TEVENT_SEND_COMPX):
             armCMDB2(0);
             break; 
         case(TEVENT_SEND_COMPY):
             armCMDB2(1);
             break;                 
         case(TEVENT_SEND_COMPZ):
             armCMDB2(2);
             break; 
         case(TEVENT_SEND_COMPA4):
             armCMDB2(3);
             break; 
         case(TEVENT_SEND_COMPA5):
             armCMDB2(4);
             break;
         case(TEVENT_SEND_COMPS):
             armCMDB2(5);
             break;
             */
         case(TEVENT_IDLE):
             armCMDB0(ARMCMDB0_ALIVE);
             break;
         default:
             //if there 's no req and loop time passed
             //send  a 0xb0 command to keep the communicate
             break;
    }
    /*
    taskEventState=EVENT_STATE_SEND;
    #ifdef FAIT_SEND2DSP
    if((taskEvent&0x000000ff)==TEVENT_SENT_BATCODE)
    {
        taskEventState=EVENT_STATE_DONE;
    }
    #endif*/
    taskEventState=EVENT_STATE_DONE;
    shm_cycBufWrite(CYCBUF_ARMEVENT, &taskEvent, 1);
    retranstickprev=tick;//OSGetTimeTick(); //start a retrans delay clock
    //=b0tickprev;
}
/*
*------------------------------------------------------------------------------
* function: handleEventAck
* parameter: void
* return   : void
* description : handle the event ack that dsp send back
*
*------------------------------------------------------------------------------
*/
void handleEventAck(void)
{
    if(shm_cycBufIsEmpty(CYCBUF_DSPEVENT)==0)
    {
        U32 key;
        U32 event;
        TCycleBuf tempbuf;
        //printf("going to enven handle\n");
        //memcpy(&tempbuf,&cycleBufList[1],sizeof(TCycleBuf));
        shm_cycBufReadValue(CYCBUF_DSPEVENT,&event);
        //printf("get event 0x%x\n",event);
        if(event)
            armCMDB0Ack();
        //memcpy(&tempbuf,&cycleBufList[1],sizeof(TCycleBuf));
        /*
        switch(event){

        case DSP_EVENT_PKGB0:
            armCMDB0Ack();
            break;
        }
        */
       shm_cycBufRead(CYCBUF_DSPEVENT, NULL, CYCBUFSIZE_EVENT);

       // tempbuf.readPtr++;
    }    

/*
    if(taskEventState!=EVENT_STATE_ACKED)
        return;
    switch(taskEvent&0xff)
        {
            case(TEVENT_NONE):
                return;
                break;
            case(TEVENT_MOD_JOG):
            case(TEVENT_MOD_WHELL):
            case(TEVENT_MOD_ZERO):
            case(TEVENT_COORDORGSET):
                armCMDB0Ack();
                break;
            case(TEVENT_MOD_AUTO):
                armCMDB0Ack();
                break;
            case (TEVENT_COORDOFFSET):
                armCMDB0Ack();
                //coordOffsetAck();
                break;
            case(TEVENT_SENT_JOGCODE):
                armCMDB4Ack();
                break;
            case(TEVENT_SENT_BATCODE):
                armCMDB3Ack();
                //DEBUGMSG(4,"send bat code acked %d\n",taskEventState);
                break;
            case(TEVENT_FIND_REF):
                task2FindReferenceAck();
                break;                
             //*************************************************************
            case(TEVENT_SEND_SYSPARAM):
                armCMDB1Ack();
                break;
            case(TEVENT_SEND_COMPX):
                armCMDB2Ack();
                break;
            case(TEVENT_IDLE):
                armCMDB0Ack();
                break;
            default:
                break;
        }
        dsp2armREQ=FALSE;
        //if the ack functon of command not set the error state, it was done.
        if(taskEventState==EVENT_STATE_ACKED)
        {    
            taskEventState=EVENT_STATE_DONE;
            DSPStatisOK++;
            /*
            #ifdef DEBUG
            if(taskEvent==TEVENT_SENT_BATCODE)
            {
                DEBUGMSG(4,"bat code send done\n");
            }
            #endif
            * /
        }
        */
}
/*
*------------------------------------------------------------------------------
* function: armDspCom
* parameter: void
* return   : void
* description :task 2 main loop, task2 is to replace the arm 44b0 functions in F system.
*                   it handle net work, file, and keyboards .And most importent the G code 
*                   
*------------------------------------------------------------------------------
* /
void armDspCom(void)
{
    static U32 recvCounter=0;
    static U32 sendCounter=0;
    static U32 errCounter=0;
    static U32 clitCounter=0;
    U16 pkglen=0;    
    if(dsp2armFilled)
    {  //GET DSP MESSAGE
        if(arm2dspREQ==TRUE)
        {        
            if(retransFlag==TRUE)
            {
                arm2dspREQ=FALSE; //since this only shoule happen in retrans
                clitCounter++;
            }else{
               //we had get ack for prev package, ignore this retrans
               dsp2armFilled=FALSE;
               goto ARMSEND;
               // while(1); 
            }
               
        }
        pkglen=DSP2ARMBUF[1]+(DSP2ARMBUF[2]<<8);
        memcpy(dsp2armACK,DSP2ARMBUF,pkglen);            
        dsp2armFilled=FALSE; //clear the flag
        dsp2armREQ=TRUE; 
        if(taskEventState==EVENT_STATE_SEND)
        {
            taskEventState=EVENT_STATE_ACKED;
            //if(retransFlag==TRUE)
            retransFlag=FALSE;
            recvCounter++;
        }else
            errCounter++;
    }
ARMSEND:
    if(arm2dspREQ)
    { //SEND MESSAGE
        //COPY to ARM2DSPbuf;
        pkglen=arm2dspPKG[1]+(arm2dspPKG[2]<<8);
        memcpy(ARM2DSPBUF,arm2dspPKG,pkglen);
        arm2dspFilled=TRUE;  
        arm2dspREQ=FALSE;
        sendCounter++;
    } 
}

/*
*------------------------------------------------------------------------------
* function: armCMDB0
* parameter: cmd 0 keep alive nothing change; 1 mod change to STD; 2 mode change to spc;
*            20 enter find ref pos;21 enter find ref neg;
* return   : void
* description :send comment data command 0xb0 to dsp task
*
*------------------------------------------------------------------------------
*/
void armCMDB0(U32 cmd)
{
#define INFO0_STDINIT        (0X01)
#define INFO0_SERVOEN        (0X02)
#define INFO0_REPOSITION     (0X04)
#define INFO0_SPCINIT        (0X08)
#define INFO0_ARMSINGLE      (0X10)
#define INFO0_STDMOD         (0X20)
#define INFO0_SPCMOD         (0X40)
#define INFO0_SINGLE         (0X80)
#define INFO1_DSPCLRALM   (0X0100)
#define INFO1_TOOLREPOS2  (0X0200)
#define INFO1_TOOLREPOS1  (0X0400)
#define INFO1_MACHLOCK    (0X0800)
#define INFO3_ADDLINEMODE1 (0X80000)
#define INFO3_ADDLINEMODE2 (0X40000)

    //tsDSP_PACKETIN_COM tempdata;
    tsDSP_PACKETIN_COM *parmInfo=(tsDSP_PACKETIN_COM *)parm2dspPKG;
    static U8 info0=0;
    parmInfo->Fix=0xAA;
    parmInfo->Head=0xAA;
    parmInfo->Length=sizeof(tsDSP_PACKETIN_COM)-4;
    parmInfo->Port=0xD0;
    parmInfo->Command=0xB0;

    parmInfo->OrginX=coordOrginWork.x;
    parmInfo->OrginY=coordOrginWork.y;
    parmInfo->OrginZ=coordOrginWork.z;
    parmInfo->OrginIV=0;
    parmInfo->OrginV=0;
    parmInfo->OrginVI=0;
    parmInfo->OffsetX=coordShiftWork.x;
    parmInfo->OffsetY=coordShiftWork.y; 
    parmInfo->OffsetZ=coordShiftWork.z;
    parmInfo->OffsetIV=0;
    parmInfo->OffsetV=0;
    parmInfo->OffsetVI=0;
    parmInfo->SafeZ=400;
    parmInfo->ToolZ=0;
    
    if(SYS_MODE_AUTO==sysMode)
    {
        if(TRUE==pauseFlag)
        {
            parmInfo->GradeG0=0; 
            parmInfo->GradeG1=0; 
        }else if(TRUE==whellRunFlag)
        {
            parmInfo->GradeG0=whellRunGrade;
            parmInfo->GradeG1=whellRunGrade;
        }else{
            parmInfo->GradeG0=rapidGrade; 
            parmInfo->GradeG1=feedGrade;   
        }
    }else if((SYS_MODE_REF==sysMode)||(SYS_MODE_WHEEL==sysMode))
    {
        parmInfo->GradeG0=10; // 10
        parmInfo->GradeG1=10; // 10     
    }else if((SYS_MODE_MDI==sysMode)||(SYS_MODE_EDIT==sysMode))
    {
            parmInfo->GradeG0=0; 
            parmInfo->GradeG1=0;         
    }else if(SYS_MODE_JOG==sysMode){
        parmInfo->GradeG0=rapidGrade; 
        parmInfo->GradeG1=rapidGrade;
    }else{
        parmInfo->GradeG0=rapidGrade; 
        parmInfo->GradeG1=feedGrade;    
    }
    parmInfo->GradeS=spindleGrade;  
    parmInfo->ComID   =armReqCMD;
    
    info0=2;
    if(cmd==ARMCMDB0_ALIVE){
        info0&=(~0x6D); //clear the bit 1 2 3 5,6
        switch(sysState)
        {
            case(SYS_STATE_AUTO):
                info0|=INFO0_STDMOD;
                break;
            case(SYS_STATE_JOG):
            case(SYS_STATE_WHEEL):
            case(SYS_STATE_ZERO):
                info0|=INFO0_SPCMOD;
                break;
            case(SYS_STATE_ALARM):
                if((SYS_MODE_WHEEL==sysMode)||(SYS_MODE_JOG==sysMode))
                    info0|=INFO0_SPCMOD;
                break;
            default:
                //info0|=INFO0_SPCMOD;
                break;
        }
    }else if(cmd==ARMCMDB0_MDI)
    {
        info0=info0&(~(INFO0_STDMOD|INFO0_SPCMOD));
    }else if(cmd==ARMCMDB0_STD)
    {
        if(addLineMode==0)
        {
            info0=(info0&(~0x60))|INFO0_STDINIT|INFO0_STDMOD;  //init std ,goto std mode
            coordStable=FALSE;
            DSPState&=~(BIT_LOCA_OVER);
            coordStableCheckDelay=COOORD_STABLE_CHECK_DELAY;
        }else if(addLineMode==2)
        {
            info0=(info0&(~0x60))|INFO0_STDMOD;  //init std ,goto std mode
            coordStable=FALSE;
            DSPState&=~(BIT_LOCA_OVER);
            coordStableCheckDelay=COOORD_STABLE_CHECK_DELAY;
        }else{
            info0=(info0&(~0x60))|INFO0_STDMOD;
        }
        //DEBUGMSG(4,"STD coord unstalbe now\n");

    }else if(cmd==ARMCMDB0_COFFSET)
    {   //should only be use in auto mode
        info0&=(~0x69); //clear the bit 1 3 5,6
        switch(sysState)
        {
            case(SYS_STATE_AUTO):
                info0|=INFO0_STDMOD;
                break;
            case(SYS_STATE_JOG):
            case(SYS_STATE_WHEEL):
            case(SYS_STATE_ZERO):
                info0|=INFO0_SPCMOD;
                info0=info0|(INFO0_REPOSITION);
                coordStable=FALSE;
                DSPState&=~(BIT_LOCA_OVER);
                coordStableCheckDelay=COOORD_STABLE_CHECK_DELAY;
                break;
        }

        //DEBUGMSG(4,"coord unstalbe now\n");
    }else if((cmd==ARMCMDB0_SPC)
        ||(cmd==ARMCMDB0_POSREF)||(cmd==ARMCMDB0_REF_LOCA))
    {
        info0=(info0&(~0x60))|(1<<3)|(1<<6);  //init spc ,goto spc mode
        coordStable=FALSE;
        DSPState&=~(BIT_LOCA_OVER);
        coordStableCheckDelay=COOORD_STABLE_CHECK_DELAY;
        //DEBUGMSG(4,"SPC coord unstalbe now\n");
    }else if((cmd==ARMCMDB0_NEGREF)
        ||(cmd==ARMCMDB0_PREF_WAIT)||(cmd==ARMCMDB0_NREF_WAIT)
        ||(cmd==ARMCMDB0_REF_LOCA_WAIT))
    {
        info0=(info0&(~0x69))|INFO0_SPCMOD;  //state in spc mode
    }
    if((singleModeFlag>=1)&&(sysMode==SYS_MODE_AUTO))
    {
        if(autoBreakPoint.flag<101)//break point not hit
        {
            info0=info0|0x10; //set singel mode sign
            //check if a run is need to be send
            if((singleRunFlag==1)&&(DSPState&BIT_SINGLE_END))
            {
                singleRunFlag=0;
                info0=info0|INFO0_SINGLE;
            }else
                info0=info0&(~INFO0_SINGLE);
        }else{
            info0=info0&(~0x90); //clear singel and singel run sign
        }
    }else{
        info0=info0&(~0x90); //clear singel and singel run sign
    }
	/////////////////////////////////
    parmInfo->Info1=info0;
    parmInfo->Info2=0;
    if(alarmDSPclr==1)
    {
        parmInfo->Info2|=0X01; //tell DSP clear prev alarms
    }
    if(toolReposition==1)
    {
        parmInfo->Info2|=0x40;
        toolReposition=0;
    }else  if(toolReposition==2)
    {
        parmInfo->Info2|=0x20;
        toolReposition=0;    
    }
    if(machLockFlag==1)
        parmInfo->Info2|=0x80;
    parmInfo->Info3=0;
    if((cmd==ARMCMDB0_POSREF)||(cmd==ARMCMDB0_PREF_WAIT))
        parmInfo->Info3=0x80; 
    else if((cmd==ARMCMDB0_NEGREF)||(cmd==ARMCMDB0_NREF_WAIT))
        parmInfo->Info3=0x85; //find  x ,z ref
    parmInfo->Info4=spinRunSign;
    if(addLineMode==1)
    {
        parmInfo->Info4|=8;
    }else if(addLineMode==2)
    {   //set add line sign
        parmInfo->Info4|=4;
        //
        addLineMode=3;
    }
    //spindle run speed
    parmInfo->Info5=(gWorkState.s)&0xff;
    parmInfo->Info6=(gWorkState.s&0xff00)>>8;
    parmInfo->Info7=0;
    parmInfo->Info9=0;
    parmInfo->Info9=0;
    if(whelldir)
    {
        parmInfo->Info9|=0x1;
    }
    if(sysMode==SYS_MODE_WHEEL)
    {
        parmInfo->Info9|=0x2;
    }
    parmInfo->CRC=0;
    parmInfo->End=0xBB;
    
    //memcpy(&parm2dspPKG,parmInfo,sizeof(tsDSP_PACKETIN_COM));
}
/*
*------------------------------------------------------------------------------
* function: armCMDB0Ack
* parameter:
* return   : void
* description :handle the dsp answered b0 command data
*
*------------------------------------------------------------------------------
*/
void armCMDB0Ack(void)
{
    //armCMDB4Ack();
    armDSPackCMD1();
    //after reset and a b0 trans, recover the mode
    if(resetTimer!=0)
    {

        switch(sysModePrev)
        {
            case(SYS_MODE_EDIT):
                sysModeChange(KEY_EDIT);
                break;
            case(SYS_MODE_AUTO):
                sysModeChange(KEY_AUTO);
                break;
            case(SYS_MODE_WHEEL):
                sysModeChange(KEY_WHEEL);
                break;
            case(SYS_MODE_JOG):
                sysModeChange(KEY_JOG);
                break;

            default:
                break;
        }
        resetTimer=0;
    }
}
/*
*------------------------------------------------------------------------------
* function: armCMDB1
* parameter: void
* return   : void
* description :send sys parameter data command 0xb1 to dsp task
*      
* this function is abounded,it should be init in task 2's init;  
*------------------------------------------------------------------------------
* /
void armCMDB1(void)
{
    Parm2dspSDPkg COMB1ptr;
    COMB1ptr=(Parm2dspSDPkg)arm2dspPKG;
    COMB1ptr->head=LKB_HEAD;
    COMB1ptr->len=LKB_LEN_ARM2DSP_SYSDATA;
    COMB1ptr->address=LKB_ADDR_DSP0;
    COMB1ptr->type=LKB_TYPE_H2S;
    COMB1ptr->command=LKB_CMD_DSP_SYSDATA;
    COMB1ptr->subcommand=0;//LKB_CMD_DSP_SYSDATA;
    memcpy(&(COMB1ptr->sysparm),&DSPparam,sizeof(TDSPparam));
    COMB1ptr->seq=armdspPKGCount++;
    COMB1ptr->crc=0;
    COMB1ptr->tail=LKB_TAIL;
    arm2dspBufLen=sizeof(Tarm2dspSDPkg);
    arm2dspREQ=TRUE;
}
/*
*------------------------------------------------------------------------------
* function: armCMDB1Ack
* parameter: 
* return   : void
* description :handle the dsp answered b1 command data
*                   
*------------------------------------------------------------------------------
* /
void armCMDB1Ack(void)
{
     //0xb1 cmd is passed, then put the system to mdi mode
     taskEventState=EVENT_STATE_DONE;
     //if(DSPparam.sysdword[6]==0)
     {
        sysState=SYS_STATE_MDI;
        sysMode=SYS_MODE_MDI;

     }
     //we can enable the hwlimit now
     //FPGA_renableHWL();
     //Goto send compensation data
}
/*
*------------------------------------------------------------------------------
* function: armCMDB2
* parameter: axis index 0-4 xyz a4a5
* return   : void
* description :send compentsation data command 0xb2 to dsp task
*                   
*------------------------------------------------------------------------------
* /
void armCMDB2(U8 axis)
{
    //Parm2dspCDPkg COMB1ptr;
    //compensation array max 280 ,len=8*280=2440
    TLKBpkgHead head;
    TLKBpkgTail tail;
    
    //ALIGN4 U8 tempbuf[COMP_ARRAY_MAX*8+100];
    U8* ptr=arm2dspPKG;
    U16 i,j;
    if((axis>4)||(DSPparam.sysdword[axis+6]==0))
        return;
    i=sizeof(TLKBpkgHead);
    head.head=LKB_HEAD;
    head.len=LKB_LEN_ARM2DSP_COMDATA;
    head.address=LKB_ADDR_DSP0;
    head.type=LKB_TYPE_H2S;
    head.command=LKB_CMD_DSP_COMPDATA ;
    memcpy(arm2dspPKG,&head,i);
    ptr=&(arm2dspPKG[i]);
    *ptr++=axis+4;
    *ptr++=DSPparam.sysdword[axis+6]&0x00ff; //array count
    *ptr++=DSPparam.sysdword[axis+6]>>8;
    j=DSPparam.sysdword[axis+6]*8;
    memcpy(ptr, &(axisCompensationInt[axis][0].l),j );
    i=i+3+DSPparam.sysdword[axis+6]*8;
    
    tail.seq=armdspPKGCount++;
    tail.crc=0;
    tail.tail=LKB_TAIL;
    memcpy(&(arm2dspPKG[i]),&tail,sizeof(TLKBpkgTail));
    arm2dspBufLen=i+sizeof(TLKBpkgTail);
    arm2dspREQ=TRUE;
}
/*
*------------------------------------------------------------------------------
* function: armCMDB2Ack
* parameter:
* return   : void
* description :handle the dsp answered b2 command data
*
*------------------------------------------------------------------------------
* /
void armCMDB2Ack(void)
{
}
/*
*------------------------------------------------------------------------------
* function: armCMDB3
* parameter:
* return   : void
* description :send bat code command 0xb1 to dsp task
*
*------------------------------------------------------------------------------
* /

// a real CMD B3 
void armCMDB3(U8* pgcode)
{ 
    if((sysMode!=SYS_MODE_AUTO)||(sysState==SYS_STATE_ALARM))\
        return;
    SendSTDGcode();
}
/*
*------------------------------------------------------------------------------
* function: armCMDB3Ack
* parameter:
* return   : void
* description :handle the dsp answered b3 command data
*
*------------------------------------------------------------------------------
* /
void armCMDB3Ack(void)
{
    armDSPackCMD1();
}
/*
*------------------------------------------------------------------------------
* function: armCMDB4
* parameter: void
* return   : void
* description :send jog code command 0xb4 to dsp task
*
*------------------------------------------------------------------------------
*/
void armCMDB4(void)
{
    Pjogcode jogcodeptr;
    //jogcodeptr=shm_cycBufWriteptr(CYCBUF_JOGCODE);
    if(jogcodeptr==NULL)    
        return; //is full
    jogcodeptr->coordx=coordSPCGend.x;
    jogcodeptr->coordy=0;
    jogcodeptr->coordz=coordSPCGend.z;
    jogcodeptr->coorda4=0;
    jogcodeptr->coorda5=0;
    jogcodeptr->coorda6=0;
    jogcodeptr->f=0;
    if((sysState==SYS_STATE_JOG)||(sysState==SYS_STATE_ZERO)||
        ((sysMode==SYS_MODE_JOG)&&(sysState==SYS_STATE_ALARM)&&ALM_IS_LIMITS))
    {
        jogcodeptr->f=jogFeed; //800;
    }else if((sysState==SYS_STATE_WHEEL)||
             ((sysMode==SYS_MODE_WHEEL)
                &&((sysState==SYS_STATE_ALARM)
                    &&(ALM_IS_LIMITS||(softLimitNegState&BITA4)))))
    {
        jogcodeptr->f=whellFeedRate;//*whellGrade;
    }else if(sysState==SYS_STATE_REF1)
    {
        jogcodeptr->f=DSPparam.sysdword[34];   //POS REF find ,find limit
    }else if((sysState==SYS_STATE_REF4)||(sysState==SYS_STATE_REF10))
    {
        jogcodeptr->f=DSPparam.sysdword[35];  //NEG ref find ,real ref finding
    }else if(sysState==SYS_STATE_REF8)
    {
        jogcodeptr->f=DSPparam.sysdword[34];
    }
    jogcodeptr->sangle=0;
    if((DSPState&BIT_SPCGEN)&&(coordStable==TRUE))
    {
        jogcodeptr->spcSendCount=(++SPCsendcount);
        coordGendSPC[SPCsendcount%GCODE_BUF_MAX]=coordSPCGend; 
       // DEBUGMSG(4,"coord end is x:0x%X, Z:0x%X\n",jogpkg->arm2dspJCInfo.coordx,jogpkg->arm2dspJCInfo.coordz);
    }else{
        jogcodeptr->spcSendCount=SPCsendcount;
    }
    //shm_cycBufWrite(CYCBUF_JOGCODE, NULL, CYCBUFSIZE_JOGCODE);
    //recharge the jog feed
    switch(jogGrade)
    {
        case(0):
            jogFeed=DSPparam.sysdword[20];
            break;
        case(1):
            jogFeed=DSPparam.sysdword[21];
            break;
        case(2 ):
            jogFeed=DSPparam.sysdword[22];
            break;
        default:
            jogGrade=0;
            jogFeed=DSPparam.sysdword[20];
            break;
    }
}
/*
*------------------------------------------------------------------------------
* function: armCMDB4Ack
* parameter:
* return   : void
* description :handle the dsp answered b2 command data
*
*------------------------------------------------------------------------------
* /
void armCMDB4Ack(void)
{
    armDSPackCMD1();
}
/*
*------------------------------------------------------------------------------
* function: armCMDAck1
* parameter:
* return   : void
* description :handle the dsp return cmd 1while
*
*------------------------------------------------------------------------------
*/
void armDSPackCMD1(void)
{
    //Pdsp2armCDPkg dspcmd1pkg;
    tsDSP_PACKETOUT_B0 *pdspInfo=(tsDSP_PACKETOUT_B0 *)pdsp2armPKG;
    U32 tempSTDrunCount,tempSPCrunCount;
    
    //dspcmd1pkg=(Pdsp2armCDPkg)dsp2armACK;
    tempSTDrunCount=pdspInfo->StdRunCount; ;
    tempSPCrunCount=pdspInfo->SpcRunCount;
    if((SYSparam[94].val == 1)&&
        (SYSparam[40].val ==3))//(S_Spindle.SpindleControlStyle != S_STYLE_VT_BUS))
    {
        if(gWorkState.sdir!=5)
        {
            spindleRealSpeed = gWorkState.s*spindleGrade/10;
        }else{
            spindleRealSpeed = 0;
        }
    }else{
        spindleRealSpeed = pdspInfo->Speed;
    }
    realFeedSpeed=pdspInfo->Feed;
    coordMACH.x=pdspInfo->MacX;
    coordMACH.y=pdspInfo->MacY;
    coordMACH.z=pdspInfo->MacZ;
    //check if a gcode is finsh, update the local coord and work coord

    if((sysMode==SYS_MODE_AUTO)&&(tempSPCrunCount!=SPCruncount))
    {      
        //spc run count is used for realrun conut in auto
        coordCurGstart=coordGend[SPCruncount%GCODE_BUF_MAX];
        coordCurGend=coordGend[tempSPCrunCount%GCODE_BUF_MAX];
                
        coordCurGendMach.x=coordCurGend.x+coordOrginWork.x+coordShiftWork.x;
        coordCurGendMach.y=coordCurGend.y+coordOrginWork.y+coordShiftWork.y;
        coordCurGendMach.z=coordCurGend.z+coordOrginWork.z+coordShiftWork.z;
        if((sendedBuf[SPCruncount%GCODE_BUF_MAX].gnum!=GCODE_T)
        &&(sendedBuf[SPCruncount%GCODE_BUF_MAX].gnum!=GCODE_50)
        &&(sendedBuf[SPCruncount%GCODE_BUF_MAX].gnum!=GCODE_54))
        {
            coordWork=coordCurGend;
        }
        STDruncount=tempSTDrunCount; 
        SPCruncount=tempSPCrunCount;
    }else if((tempSPCrunCount!=SPCruncount)&&(sysMode!=SYS_MODE_EDIT)&&(sysMode!=SYS_MODE_MDI))
    {
        if((tempSPCrunCount-SPCruncount)<1)
        {
           U32 i;
           while(1) //HERE SEEM TO HAS SOME PROBLEM, CHECK IT LATER
           {
               i=pdspInfo->MacX+1;
           }
        }
        coordCurGstart=coordGendSPC[SPCruncount%GCODE_BUF_MAX];
        coordCurGend=coordGendSPC[tempSPCrunCount%GCODE_BUF_MAX];
        coordCurGendMach.x=coordCurGend.x+coordOrginWork.x+coordShiftWork.x;
        coordCurGendMach.y=coordCurGend.y+coordOrginWork.y+coordShiftWork.y;
        coordCurGendMach.z=coordCurGend.z+coordOrginWork.z+coordShiftWork.z;
        coordWork=coordCurGend;
        SPCruncount=tempSPCrunCount;
    }    
    DSPState=pdspInfo->Info1;
    
    if(coordStableCheckDelay>0)
    {
        coordStableCheckDelay--;
        DSPState&=~(BIT_LOCA_OVER);
    }else if((coordStable==FALSE)&&
    ((DSPState&BIT_LOCA_OVER)||(sysMode==SYS_MODE_MDI)))
    {
        coordStable=TRUE;
        // re position,set coord value
        coordWork=coordWorkBack;
        coordSPCGend=coordWorkBack;
        coordCurGend=coordWorkBack;
        if(addLineMode==0)
        {
            coordSentedGend=coordWorkBack;
            coordCurGstart=coordWorkBack;
            coordCurGendMach.x=coordCurGend.x+coordOrginWork.x+coordShiftWork.x;
            coordCurGendMach.y=coordCurGend.y+coordOrginWork.y+coordShiftWork.y;
            coordCurGendMach.z=coordCurGend.z+coordOrginWork.z+coordShiftWork.z;
        }
        //it can be tool change ,clear it yes or not;
        //toolChangingFlag=0;
        if(addLineMode==3)
            addLineMode=0;
    }
    //if we are at the end of std runing set it end
    if((gexecState==GEXEC_SENDE)&&(STDruncount>=(STDsendcount-1))
        &&(DSPState&BIT_CODE_OVER))
    {
        U32 timeUsed=OSGetTimeTick();
        gexecState=GEXEC_DONE;
//        //PLC_NCSTAT_AUTOSTOP;
        //add the work piect static counter

        //cal the time used in cutting
        if(m20flag==0)
        {
            cutTimePiece=(timeUsed-cutTimeReg)/100;
            cutTimeCT+=cutTimePiece;
            IIC_Write4(IICADDR_CUT_TIME, cutTimeCT);
            cutTimePieceRecord=cutTimePiece;
        }
    }else{
        if(GEXEC_STATE_RUNING)
        {
            U32 timeUsed=OSGetTimeTick();
            cutTimePiece=(timeUsed-cutTimeReg)/100;
        }
    }
    hardLimitPosState=(pdspInfo->Info2)&0x07;
    //& 05 to supress all other not used axis
    hardLimitNegState=(pdspInfo->Info3)&0x07;
    if((SYSparam[91].val)&&(refFounded&BITX)&&(refFounded&BITZ))
    {
        hardLimitPosState=0;
        hardLimitNegState=0;
    }
	////////////////////////////////////////////////
    locateState= pdspInfo->Info4;
    referenceState=pdspInfo->Info5;
    SA4State=pdspInfo->Info6;
    //INFO 7 8 9 IS RESV
    /*
    if(pdspInfo->infoBit[7]&0x1)
    {
        whellreachstart=1;
    }else{
        whellreachstart=0;
    }*/
    //realFeedSpeed=pdspInfo->Feed;
    realFeedSpeed=(pdspInfo->Info11<<8)+pdspInfo->Info10;
    spindleLoad=pdspInfo->Info13;

    softLimitPosState=0;//pdspInfo->infoBit[13]&0xf;
    softLimitNegState=0;//(pdspInfo->infoBit[13]&0xf0)>>4;
    //info 14 -17 version info

       // memcpy(&jogpkg,ARMDSPBUF,sizeof(jogpkg));
    //check hardware limit alarm
    //alarmCheck();
    /*
    if(pdspInfo->alarmBit[0]!=0)
    {
        if(pdspInfo->alarmBit[0]&0x01) //x servo alarm
        {
            ALARM_GRP0|=ALM_GRP0_XSERVO;
            gexecState=GEXEC_RESET;
//            //PLC_NCSTAT_AUTOSTOP;
            if(SYSparam[93].val!=2)
                if(0==machLockFlag)refFounded=0;
        }
        if((pdspInfo->alarmBit[0]&0x02)&&(Yavailable)) //y servo alarm
        {
            ALARM_GRP0|=ALM_GRP0_YSERVO;
            gexecState=GEXEC_RESET;
//            //PLC_NCSTAT_AUTOSTOP;
            if(SYSparam[93].val!=2)
                if(0==machLockFlag)refFounded=0;
        }
        if(pdspInfo->alarmBit[0]&0x04) //z servo alarm
        {
            ALARM_GRP0|=ALM_GRP0_ZSERVO;
            gexecState=GEXEC_RESET;
            //PLC_NCSTAT_AUTOSTOP;
            if(SYSparam[93].val!=2)
                if(0==machLockFlag)refFounded=0;
        } 
        if(pdspInfo->alarmBit[0]&0x10) //S servo alarm
        {
            ALARM_GRP0|=ALM_GRP0_SSERVO;
            gexecState=GEXEC_RESET;
            //PLC_NCSTAT_AUTOSTOP;
            //refFounded=0;
        }
        if(pdspInfo->alarmBit[0]&0x20) //主轴定位失败
        {
            ALARM_GRP0|=ALM_GRP0_ORT_FAIL;
            gexecState=GEXEC_RESET;
            //PLC_NCSTAT_AUTOSTOP;
          //  refFounded=0;
        }
        if(ALARM_GRP0&(ALM_GRP0_XSERVO|ALM_GRP0_ZSERVO|ALM_GRP0_ORT_FAIL))
        { //stop the spindle if servo alarm
            gWorkState.sdir=5;
            spinRunSign=0;
//            ////PLC_NCSTAT_SSTOP;
        }
    }
    if(pdspInfo->alarmBit[3]!=0)
    {
        if(pdspInfo->alarmBit[3]&0x01) //pulse too much alarm
        {
            if(gexecState != GEXEC_RESET)
            {
                UNKNOW_ERR_src = tempSTDrunCount;
                DEBUGMSG(4,\
                         "UNKNOW ALARM:coordMACH.x %ld,coordMACH.z %ld,tempSTDrunCount %ld,tempSPCrunCount %ld\n",coordMACH.x,coordMACH.z,tempSTDrunCount,tempSPCrunCount);
            }
            ALARM_GRP1|=ALM_GRP1_DSP_PULSE;
            gexecState=GEXEC_RESET;
            //PLC_NCSTAT_AUTOSTOP;
            if(0==machLockFlag)refFounded=0;
        }
        if(pdspInfo->alarmBit[3]&0x10)
        {
            ALARM_GRP0|=ALM_GRP0_SPIN_COM;
            gWorkState.sdir=5;
            spinRunSign=0;
            gexecState=GEXEC_RESET;
            //PLC_NCSTAT_AUTOSTOP;
        }
        if(pdspInfo->alarmBit[3]&0x80)
        {
            if(machLockFlag==0)
            {
                ALARM_GRP0|=ALM_GRP0_EMG_STOP;
                gWorkState.sdir=5;
                spinRunSign=0;
                gexecState=GEXEC_RESET;
                //PLC_NCSTAT_AUTOSTOP;
            }
        }
    }else if(alarmDSPclr!=0){
        alarmDSPclr=0;
    }
    //if we are in program zero going
    if((programZeroFlag)&&(DSPState&BIT_CODE_OVER))
    {
        if(programZeroFlag<5) //avoid change in 5 cycle
            programZeroFlag++;
        else
            programZeroFlag=0;
    }
    alarmHardLimitCheck();
    alarmSoftLimitCheck();
    {
        static U16 prevstate=0,needclear=0;
        U16 state=ALARM_GRP0&ALM_GRP0_LIMITS;
        if((state!=prevstate)&&(state>prevstate))
        {
            needclear=1;
        }
        prevstate=state;
        if((DSPState&BIT_CODE_OVER)&&(needclear==1))
        {
            needclear=0;
            if(sysMode==SYS_MODE_WHEEL)
            {
                sysState=SYS_STATE_JOG; //cheat it as jog mode
                sysModeChange(KEY_WHEEL);
            }else if(sysMode==SYS_MODE_JOG)
            {
                sysState=SYS_STATE_WHEEL; //cheat it as jog mode
                sysModeChange(KEY_JOG);
            }
        }
    } */
}
//*****************************************************************************



/*
*------------------------------------------------------------------------------
* function: task2FindReference
* parameter:
* return   : void
* description : control the task2 to finish the auto find ref function
*-----------------------------------------------------------------------------
*/
void task2FindReference(void)
{
    #define REF_PULSE_INTERVAL (6)
    static U8 nowfindaxis;
    S8 signx,signz,limitx,limitz,signy,limity;

    if(DSPparam.sysbyte[26]==0)
    {
        signx=1;
        if(hardLimitPosState&BITX)
            limitx=1;
        else
            limitx=0;
    }else{
        signx=-1;
        if(hardLimitNegState&BITX)
            limitx=1;
        else
            limitx=0;
    }
    if(Yavailable)
        if(DSPparam.sysbyte[27]==0)
        {
            signy=1;
            if(hardLimitPosState&BITY)
                limity=1;
            else
                limity=0;
        }else{
            signy=-1;
            if(hardLimitNegState&BITY)
                limity=1;
            else
                limity=0;
        }
    if(DSPparam.sysbyte[28]==0)
    {    signz=1;
        if(hardLimitPosState&BITZ)
            limitz=1;
        else
            limitz=0;
    }else{
        signz=-1;
        if(hardLimitNegState&BITZ)
            limitz=1;
        else
            limitz=0;
    }
    if(sysState==SYS_STATE_REF)
    {
        nowfindaxis=0;
        armCMDB0(ARMCMDB0_POSREF);
        sysState=SYS_STATE_REF_STANDBY;
    }else if(sysState==SYS_STATE_REF_STANDBY){
        if(SYSparam[89].val==0)
        {
            if((Yavailable)&&(limity==0))
            {
                nowfindaxis=BITY;
            }else if(limitz==0){
                nowfindaxis=BITZ;
            }else if(limitx==0){
                nowfindaxis=BITX;
            }else{
                nowfindaxis=BITX|BITZ|(Yavailable?BITY:0);
            }
        }else if(SYSparam[89].val==1){
            if((Yavailable)&&(limity==0))
            {
                nowfindaxis=BITY;
            }else if(limitx==0){
                nowfindaxis=BITX;
            }else if(limitz==0){
                nowfindaxis=BITZ;
            }else{
                nowfindaxis=BITX|BITZ|(Yavailable?BITY:0);
            }
        }
        else{
            nowfindaxis=refFindAxis;
        }
        if(nowfindaxis!=0)
        {
            sysState=SYS_STATE_REF_GOPOS;
        }
        //armCMDB0(ARMCMDB0_POSREF);
    }else if(sysState==SYS_STATE_REF_GOPOS){
        F32 g0speedums = 1.0*DSPparam.sysdword[34]/60;
        F32 g0speedums1 = 10.0*g0speedums*REF_PULSE_INTERVAL;
        F32 g0speedums2 = 10000.0*pow(g0speedums,2)/SYSparam[149].val/(5-2);
        U8 finish=1;
        if(g0speedums1>g0speedums2)
        {
            g0speedums = g0speedums1;
        }else{
            g0speedums = g0speedums2;
        }
        if((nowfindaxis&BITZ)&&(!limitz))
        {
            finish=0;
        }
        if((nowfindaxis&BITX)&&(!limitx))
        {
            finish=0;
        }
        if((nowfindaxis&BITY)&&(!limity))
        {
            finish=0;
        }
        if(finish)
        {
            if(limitz&&limitx&&(Yavailable?limity:1))
            {
                sysState=SYS_STATE_REF_LEAVELIMIT;
            }else{
                sysState=SYS_STATE_REF_STANDBY;
            }
        }
        if((coordStable==TRUE)&&(DSPState&BIT_SPCGEN))
        {
            if((nowfindaxis&BITZ)&&(!limitz))
                coordSPCGend.z+=signx*g0speedums*REF_PULSE_INTERVAL;
            if((nowfindaxis&BITX)&&(!limitx))
                coordSPCGend.x+=signz*g0speedums*REF_PULSE_INTERVAL;
            if(Yavailable)
            if((nowfindaxis&BITY)&&(!limity))
                coordSPCGend.y+=signz*g0speedums*REF_PULSE_INTERVAL;
        }
        armCMDB4();  //just
    }else if(sysState==SYS_STATE_REF_LEAVELIMIT){
        F32 g0speedums=1.0*DSPparam.sysdword[35]*10/60;
         if(limitx||limitz||limity)
         {
             if((DSPState&BIT_SPCGEN)&&(coordStable==TRUE))
             {
                 if(limitx)
                 {
                    coordSPCGend.x-=signx*g0speedums*REF_PULSE_INTERVAL;
                 }
                 if(limitz)
                 {
                    coordSPCGend.z-=signz*g0speedums*REF_PULSE_INTERVAL;
                 }
                 if(limity)
                 {
                    coordSPCGend.y-=signz*g0speedums*REF_PULSE_INTERVAL;
                 }
             }
             armCMDB4();
         }else
         {
            sysState=SYS_STATE_REF_WAITLEAVELIMIT;
         }
    }else if(sysState==SYS_STATE_REF_WAITLEAVELIMIT){
        armCMDB0(ARMCMDB0_PREF_WAIT);  //
        if(DSPState&BIT_CODE_OVER)
        {
            sysState=SYS_STATE_REF_READYTOFINDREF;
        }
    }else if(sysState==SYS_STATE_REF_READYTOFINDREF){
        armCMDB0(ARMCMDB0_NEGREF);  //enter NEG find ref point
        if(DSPState&BIT_CODE_OVER)
        {
            sysState=SYS_STATE_REF_FINDREF;
        }
    }else if(sysState==SYS_STATE_REF_FINDREF){
        // send x z pulse of one axis round
        //F32 g1speedums=1.0*DSPparam.sysdword[35]/60;
        if((DSPState&BIT_SPCGEN)&&(coordStable==TRUE))
        {
            coordSPCGend.z-=signz*DSPparam.sysdword[33]*10000;//g1speedums*REF_PULSE_INTERVAL;
            coordSPCGend.x-=signx*DSPparam.sysdword[33]*10000;//g1speedums*REF_PULSE_INTERVAL;
            if(Yavailable)
            {
                coordSPCGend.y-=signy*DSPparam.sysdword[33]*10000;//g1speedums*REF_PULSE_INTERVAL;
            }
        }
        armCMDB4();
        sysState=SYS_STATE_REF_WAITFINDREF;
    }else if(sysState==SYS_STATE_REF_WAITFINDREF){
        armCMDB0(ARMCMDB0_NREF_WAIT);
        if((referenceState&BITX)&&(referenceState&BITZ)&&(Yavailable?(referenceState&BITY):1))
        {
            if((DSPState&BIT_CODE_OVER)&&(locateState&(BITX|BITZ|(Yavailable?BITY:0))))
            {   //ref done ,go back to mdi mode
                sysState=SYS_STATE_REF_LOCA;
                refFounded=(BITX|BITZ|(Yavailable?BITY:0));
            }
        }else if((DSPState&BIT_CODE_OVER)&&(locateState&(BITX|BITZ|(Yavailable?BITY:0))))
        {
            //FAIL IN reference finding ,make alarm
            //sysAlarm[sysAlarmPtr++]=ALARM_REFERR_XPOS;
            if(!(referenceState&BITX))
            {
                ALARM_GRP0|=ALM_GRP0_X_NOREFER;
            }
            if(!(referenceState&BITZ))
            {
                ALARM_GRP0|=ALM_GRP0_Z_NOREFER;
            }
            if((!(referenceState&BITY))&&Yavailable)
            {
                ALARM_GRP0|=ALM_GRP0_Y_NOREFER;
            }
            //FPGA_renableHWL();
            sysState=SYS_STATE_MDI;
            sysMode=SYS_MODE_MDI;
        }
    }else if(sysState==SYS_STATE_REF_LOCA){
        armCMDB0(ARMCMDB0_REF_LOCA);
        sysState=SYS_STATE_REF_WAITLOCA;
    }else if(sysState==SYS_STATE_REF_WAITLOCA){
        armCMDB0(ARMCMDB0_REF_LOCA_WAIT);
        if(coordStable==TRUE)
        {
            //set the current work coord to the same value with mach
            //check the stop point of ref finding is the same with record
            if(SYSparam[147].val!=0)
            {
                if((SYSparam[143].val!=0)
                    &&((abs(coordMACH.x-SYSparam[143].val*10))>(SYSparam[147].val*10)))
                {
                    refFounded&=~BITX;
                    ALARM_GRP0|=ALM_GRP0_X_NOREFER;
                }
                if(Yavailable)
                {
                    if((SYSparam[144].val!=0)
                        &&((abs(coordMACH.y-SYSparam[144].val*10))>(SYSparam[147].val*10)))
                    {
                        refFounded&=~BITY;
                        ALARM_GRP0|=ALM_GRP0_Y_NOREFER;
                    }
                }
                if((SYSparam[145].val!=0)
                    &&((abs(coordMACH.z-SYSparam[145].val*10))>(SYSparam[147].val*10)))
                {
                    refFounded&=~BITZ;
                    ALARM_GRP0|=ALM_GRP0_Z_NOREFER;
                }
                if(ALARM_GRP0&(ALM_GRP0_X_NOREFER|ALM_GRP0_Z_NOREFER|ALM_GRP0_Y_NOREFER))
                {
                    sysState=SYS_STATE_MDI;
                    sysMode=SYS_MODE_MDI;
                }
            }
            //FPGA_renableHWL();
            if(DSPparam.sysbyte[86]==0)
                sysState=SYS_STATE_REF_END;
            else
                sysState=SYS_STATE_REF_GOZERO;
        }
    }else if(sysState==SYS_STATE_REF_GOZERO){
        //goto the mach zero
        coordWork.x=0-coordOrginWork.x-coordShiftWork.x;
        coordWork.y=0-coordOrginWork.y-coordShiftWork.y;
        coordWork.z=0-coordOrginWork.z-coordShiftWork.z;
        coordSPCGend=coordWork;
        coordCurGend=coordWork;
        coordCurGendMach.x=coordCurGend.x+coordOrginWork.x+coordShiftWork.x;
        coordCurGendMach.y=coordCurGend.y+coordOrginWork.y+coordShiftWork.y;
        coordCurGendMach.z=coordCurGend.z+coordOrginWork.z+coordShiftWork.z;
        SPCsendcount=0;
        SPCruncount=1;
        armCMDB4();
        DSPState&=~BIT_CODE_OVER;
        locateState&=~(BITX|BITZ|BITY);
        coordStableCheckDelay=COOORD_STABLE_CHECK_DELAY;
        sysState=SYS_STATE_REF_END;
    }else if(sysState==SYS_STATE_REF_END)
    {
        armCMDB0(ARMCMDB0_REF_LOCA_WAIT);
        //ref done ,go back to mdi mode
        if((DSPState&BIT_CODE_OVER)&&(locateState&(BITX|BITZ|(Yavailable?BITY:0))))
        {
            U8 index=curTool%100;
            IIC_Write4(IICADDR_TOOL, curTool);
            //change the work coord origin
            coordShiftWork.x=toolCompensation[index].x;
            coordShiftWork.y=toolCompensation[index].y;
            coordShiftWork.z=toolCompensation[index].z;
            coordOrginWorkG5x[0].x=IIC_Read4(IICADDR_G5X_X);
            coordOrginWorkG5x[0].y=IIC_Read4(IICADDR_G5X_Y);
            coordOrginWorkG5x[0].z=IIC_Read4(IICADDR_G5X_Z);
            coordOrginWork.x=coordOrginWorkG5x[0].x+coordOrginWorkG5x[gWorkState.GG05].x;
            coordOrginWork.y=coordOrginWorkG5x[0].y+coordOrginWorkG5x[gWorkState.GG05].y;
            coordOrginWork.z=coordOrginWorkG5x[0].z+coordOrginWorkG5x[gWorkState.GG05].z;
            if(DSPparam.sysbyte[86]==0)
            {
                coordWork.x=coordMACH.x-coordOrginWork.x-coordShiftWork.x;
                coordWork.y=coordMACH.y-coordOrginWork.y-coordShiftWork.y;
                coordWork.z=coordMACH.z-coordOrginWork.z-coordShiftWork.z;
            }else{
                coordWork.x=0-coordOrginWork.x-coordShiftWork.x;
                coordWork.y=0-coordOrginWork.y-coordShiftWork.y;
                coordWork.z=0-coordOrginWork.z-coordShiftWork.z;
            }
            coordSPCGend=coordWork;
            coordCurGend=coordWork;
            coordCurGendMach.x=coordCurGend.x+coordOrginWork.x+coordShiftWork.x;
            coordCurGendMach.y=coordCurGend.y+coordOrginWork.y+coordShiftWork.y;
            coordCurGendMach.z=coordCurGend.z+coordOrginWork.z+coordShiftWork.z;
            sysState=SYS_STATE_MDI;
            sysMode=SYS_MODE_MDI;
        }
    }
}
/*
*------------------------------------------------------------------------------
* function: task2FindReferenceAck
* parameter:
* return   : void
* description : control the task2 to finish the auto find ref function
*-----------------------------------------------------------------------------
* /
void task2FindReferenceAck(void)
{
    armDSPackCMD1();
    if((sysMode==SYS_MODE_REF))
    {
        taskEventState=EVENT_STATE_REQ;
    }else{
        taskEventState=EVENT_STATE_ACKED;
    }
}
/*
*----------------------------------------------------------------------------
* function: autoRepositionAfterAlarm
* parameter: void
* return   : void
* description :
*-----------------------------------------------------------------------------
*/
S32 prevPulse=0;
S32 smothPulse=0;
S32 smothFlag=0;
void limitAlarmAutoClear(void)
{
    if(autoAlarmClrFlag>0)
    {
        goto AFTER_CLEAR;
    }
    //if condiction is ok to clear limit alarm
    if(SYS_STATE_ALARM!=sysState) //in alarm
        return;
    if(((ALARM_GRP0&ALM_GRP0_LIMITS)==0) //is limit alarm
      &&((ALARM_GRP1&ALM_GRP1_RSAREA)==0))
        return;
AFTER_CLEAR:
    if(!((SYS_MODE_JOG==sysMode)||(SYS_MODE_WHEEL==sysMode))) //in jog or whell
        return;
    if(!((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER))) //prev code is done
        return;
    if(autoAlarmClrFlag==0){
        alarmLimitClear();
        return;
    }

    if(autoAlarmClrFlag==1)
    {
        if(!((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER)))
            return;
        //autoRepositionAfterAlarm();
        //if(sysState==SYS_STATE_WHEEL)
        /*if(sysMode==SYS_MODE_WHEEL)
        {
            sysState=SYS_STATE_JOG; //cheat it as jog mode
            sysModeChange(KEY_WHELL);
        }else
        {
            sysState=SYS_STATE_WHEEL; //cheat it as jog mode
            sysModeChange(KEY_JOG);
        }*/
        autoAlarmClrFlag=2;
    }else //(autoAlarmClrFlag==2)
    {
        if(!(DSPState&(BIT_CODE_OVER|BIT_LOCA_OVER)))
            return;
        autoAlarmClrFlag=0;
        prevPulse=0;
        smothPulse=0;
        smothFlag=0;
    }
}
/*
*------------------------------------------------------------------------------
* function: jogCode
* parameter:
* return   : void
* description : handle the mode change keys,change system mode
*-----------------------------------------------------------------------------
*/
U8 clearprevjog=0;
//extern AREA_CONTROL SPC_A_Control;
void jogCode(U16 jogkey)
{
    #define CHANGE_DIR_DELAY (4)
    #define JOGKEY_INTERVAL (10)   //ms SECONDS
    F32 g0speedums,g0speedums1,g0speedums2,g0speedumsx,g0speedumsz,g0speedumsy;
    //U16 jogkey=(taskEvent>>16);
    S32 jogDirX,jogDirZ,jogDirY;
    static S16 prevx=0,prevz=0,prevy=0;
    U8 hasx=((jogkey&(JOGKEY_XN|JOGKEY_XP))!=0),hasz=((jogkey&(JOGKEY_ZN|JOGKEY_ZP))!=0),
        hasy=((jogkey&(JOGKEY_YN|JOGKEY_YP))!=0);
    if(!Yavailable)
        hasy=0;
    if(!((DSPState&BIT_SPCGEN)&&(coordStable==TRUE)/*&&((SPCsendcount-SPCruncount)<2)*/))
        return;
    if(jogkey==0)
        return;
    if(!((sysState==SYS_STATE_JOG)||(sysState==SYS_STATE_ZERO)||
        ((sysState==SYS_STATE_ALARM)&&(sysMode==SYS_MODE_JOG)&&ALM_IS_LIMITS)))
        return;
    //cal distance
    if(clearprevjog==1)
    {
        prevx=0;
        prevz=0;
        clearprevjog=0;
    }
    if(rapidGrade!=0)
    {
        if(hasx)
        {
            if(DSPparam.sysbyte[23]==0)
                jogDirX=1;
            else
                jogDirX=-1;
            if((jogkey&JOGKEY_XP)!=0)
                jogDirX=-1*jogDirX;
            g0speedums = 0.1*(rapidGrade)*jogFeed/60;
            g0speedums1=SYSparam[21].val*1000.0/60;//单轴速度限制
            if((g0speedums1<g0speedums))
            {
                g0speedums = g0speedums1;
            }
            g0speedums1 = 10.0*g0speedums*JOGKEY_INTERVAL;
            g0speedumsx = g0speedums1;
            if(SYSparam[91].val==0)
            {
                if((jogDirX==1)&&((hardLimitPosState&BITX)||(softLimitPosState&BITX)))
                    jogDirX=0;
                if((jogDirX==-1)&&((hardLimitNegState&BITX)||(softLimitNegState&BITX)))
                    jogDirX=0;
            }else{//hardlimit disable
                if((jogDirX==1)&&(softLimitPosState&BITX))
                    jogDirX=0;
                if((jogDirX==-1)&&(softLimitNegState&BITX))
                    jogDirX=0;
            }
            coordSPCGend.x+=jogDirX*g0speedumsx;
            prevx+=jogDirX;
            if(prevx>CHANGE_DIR_DELAY)
            {
                prevx=CHANGE_DIR_DELAY;
            }else if(prevx<-CHANGE_DIR_DELAY){
                prevx=-CHANGE_DIR_DELAY;
            }
        }
        if(hasz)
        {
            if(DSPparam.sysbyte[25]==0)
                jogDirZ=1;
            else
                jogDirZ=-1;
            if((jogkey&JOGKEY_ZP)!=0)
                jogDirZ=-1*jogDirZ;
            g0speedums = 0.1*(rapidGrade)*jogFeed/60;
            g0speedums1=SYSparam[23].val*1000.0/60;
            if((g0speedums1<g0speedums))
            {
                g0speedums = g0speedums1;
            }
            g0speedums1 = 10.0*g0speedums*JOGKEY_INTERVAL;
            g0speedumsz = g0speedums1;
            if(SYSparam[91].val==0)
            {
                if((jogDirZ==1)&&((hardLimitPosState&BITZ)||(softLimitPosState&BITZ)))
                    jogDirZ=0;
                if((jogDirZ==-1)&&((hardLimitNegState&BITZ)||(softLimitNegState&BITZ)))
                    jogDirZ=0;
            }else{//hardlimit disable
                if((jogDirZ==1)&&(softLimitPosState&BITZ))
                    jogDirZ=0;
                if((jogDirZ==-1)&&(softLimitNegState&BITZ))
                    jogDirZ=0;
            }
            coordSPCGend.z+=jogDirZ*g0speedumsz;
            prevz+=jogDirZ;
            if(prevz>CHANGE_DIR_DELAY)
            {
                prevz=CHANGE_DIR_DELAY;
            }else if(prevz<-CHANGE_DIR_DELAY){
                prevz=-CHANGE_DIR_DELAY;
            }
        }
        if((hasy)&&(Yavailable))
        {
            if(DSPparam.sysbyte[24]==0)
                jogDirY=1;
            else
                jogDirY=-1;
            if((jogkey&JOGKEY_YP)!=0)
                jogDirY=-1*jogDirY;
            g0speedums = 0.1*(rapidGrade)*jogFeed/60;
            g0speedums1=SYSparam[22].val*1000.0/60;
            if((g0speedums1<g0speedums))
            {
                g0speedums = g0speedums1;
            }
            g0speedums1 = 10.0*g0speedums*JOGKEY_INTERVAL;
            g0speedumsy = g0speedums1;
            if(SYSparam[91].val==0)
            {
                if((jogDirY==1)&&((hardLimitPosState&BITY)||(softLimitPosState&BITY)))
                    jogDirY=0;
                if((jogDirY==-1)&&((hardLimitNegState&BITY)||(softLimitNegState&BITY)))
                    jogDirY=0;
            }else{//hardlimit disable
                if((jogDirY==1)&&(softLimitPosState&BITY))
                    jogDirY=0;
                if((jogDirY==-1)&&(softLimitNegState&BITY))
                    jogDirY=0;
            }
            if(Yavailable)
            {
                coordSPCGend.y+=jogDirY*g0speedumsy;
            }
            prevy+=jogDirY;
            if(prevy>CHANGE_DIR_DELAY)
            {
                prevy=CHANGE_DIR_DELAY;
            }else if(prevy<-CHANGE_DIR_DELAY){
                prevy=-CHANGE_DIR_DELAY;
            }
        }

    }else{
        g0speedumsx=0;
        g0speedumsz=0;
        g0speedumsy=0;
    }
}
/*
*------------------------------------------------------------------------------
* function: whellInterval
* parameter:
* return   : void
* description :count 5 ms and handle one key package; systick is 500us,
* it only send or recv in one time, so time interval is set to 5
*
*------------------------------------------------------------------------------
*/
//----------------------------------
//test vars to find bast result of whell
/*
S32 maxDeltaRecord=0;
U32 maxSpeedRecord=0;
U32 decCT=0;
U32 whellRecord[2000];
U32 deltaRecord[2000];
U32 wrIndex=0;
U32 dtIndex=0;
*/
static S32 whellPulseHistory[5]={0,0,0,0,0};
static U32 pulseDeltaLimit=10; //need insert delta
static U32 pulseRealLimit=3;  //if pulse shoulde be send out as real
static U32 pulseSmothLimit=1;  //smoth delta of pulse
U8 newwhellmode=1;
U32 whell_run_time=10;
void whellInterval(void)
{
    #if 0
    //#define WHELL_SAMPLET  (4)
    static U32 prevWhellTick;
    static U32 nowWhellTick;
    static U8 prevIsWhellMode=FALSE;
    static U32 prevWhellCTValue;
    static U32 prevWhellpulse;
    static U8 prevGUI=0;
    U8 nowGUI=0;
    S32 delta=0;
    U8 whellio;
    if(realFeedSpeed!=0)
    {
        GetDeltaTick();
    }
    if((sysMode==SYS_MODE_AUTO)&&(whellRunFlag==TRUE))
    {
        whellRunInterval();
        return;
    }else{
        whelldir=0;
    }
    if(sysState!=SYS_STATE_WHEEL)
    {
        if((sysState!=SYS_STATE_ALARM)||((sysState==SYS_STATE_ALARM)&&(sysMode!=SYS_MODE_WHEEL)&&ALM_IS_LIMITS))
        {
            if(prevIsWhellMode==TRUE)
                prevIsWhellMode=FALSE;
            return;
        }
    }

//    whellio = (~rWHELLIO)&0x7f;
    if(whellio&0x7)
    {//当无轴被选择时手轮IO无效，如此则手轮无档位选择时，键盘档位可用
        if(whellio&0x1)
        {
            whellControlAxis=AXISX;
        }else if(whellio&0x2){
            whellControlAxis=AXISY;
        }else if(whellio&0x4){
            whellControlAxis=AXISZ;
        }
        if(whellio&0x10)
        {
            whellGrade=100;
            if(softLimitNegState&BITA4)
            { // if in restrect area
                whellGrade=10;
            }
        }else if(whellio&0x8){
            whellGrade=10;
        }else{
            whellGrade=1;
        }

    }

    //for DGN test,if we are in whell mode and DGN, show the whell value
    nowGUI=currentGUI;
    if((nowGUI!=prevGUI)&&((nowGUI==GUINUM_DGN)||(prevGUI==GUINUM_DGN)))
    {
        clear_W_encoder();
        prevGUI=currentGUI;
        prevIsWhellMode=FALSE;
        return;
    }else if(nowGUI==GUINUM_DGN)
    {   //we are in DGN test GUI, just get the
        if(pre_get_MACH_counter(&W_Encoder))
        {
            get_MACH_value(&W_Encoder);             //读w轴编码器值
        }
        whellTestCT=(W_Encoder.MACH_PositionValue>>2);
        prevGUI=currentGUI;
        prevIsWhellMode=FALSE;
        return;
    }
    if(!(DSPState&BIT_LOCA_OVER))
    {
        prevIsWhellMode=FALSE;
        return;
    }
    //the real whell work
    if(prevIsWhellMode==FALSE)
    {
        prevIsWhellMode=TRUE;
        prevWhellTick=nowWhellTick;
        //rest the whell counter;
        clear_W_encoder();
        //vinge 20090325
        WHELL_SIMPLE_TIME=SYSparam[19].val;
        whell_run_time=SYSparam[19].val*10;
        if(WHELL_SIMPLE_TIME<10)
            WHELL_SIMPLE_TIME=10;
        else if(WHELL_SIMPLE_TIME>30)
            WHELL_SIMPLE_TIME=30;
        /*
        if(WHELL_SIMPLE_TIME<=15)
        {
            pulseDeltaLimit=6;
            pulseRealLimit=4;
            pulseSmothLimit=2;
        }else{
            pulseDeltaLimit=10;
            pulseRealLimit=6;
            pulseSmothLimit=3;
        }*/
        if(WHELL_SIMPLE_TIME<20)
            WHELL_CODE_TIME=WHELL_SIMPLE_TIME+3;
        else if(WHELL_SIMPLE_TIME<30)
            WHELL_CODE_TIME=WHELL_SIMPLE_TIME+5;
        else
            WHELL_CODE_TIME=35;

        /*
        if(whellGrade<100)
            WHELL_SIMPLE_TIME=20;
        else
            WHELL_SIMPLE_TIME=50;
        WHELL_CODE_TIME=WHELL_SIMPLE_TIME+2;
        whellPulseHistory[0]=0;
        whellPulseHistory[1]=0;
        whellPulseHistory[2]=0;
        */
        prevWhellCTValue=(W_Encoder.MACH_PositionValue>>2);
        return;
    }
    nowWhellTick=OSGetTimeTick();
    if(newwhellmode)
    {
        U32 code_time=(whell_run_time/5);
        static S32 whellhis=0;
        static S32 prevdelta=0;
        static S16 dirhis[3]={0,0,0};
        S32 i;
        if(pre_get_MACH_counter(&W_Encoder))
        {
            get_MACH_value(&W_Encoder);             //读w轴编码器值
        }
        delta = (W_Encoder.MACH_PositionValue>>2)-prevWhellCTValue;
        if(delta!=0)
        {
            SetStartTick();
        }
        prevWhellCTValue = (W_Encoder.MACH_PositionValue>>2);
        whellhis += delta;
        if((nowWhellTick-prevWhellTick)>=code_time)
        {
            prevWhellTick = nowWhellTick;
            if((feedGrade==0)||(rapidGrade==0))
            {
                return;
            }
            if((DSPState&BIT_SPCGEN)&&(whellhis!=0))
            {
                whellFeedRate=60.0l*abs(whellhis)*whellGrade/code_time;  //mm/minute

                if((dirhis[0]*dirhis[1]<0)&&((delta*dirhis[0]<0)||(dirhis[1]*dirhis[2]<0)))
                {
                    delta=whellhis/2;
                    whellhis -= delta;
                    delta=delta*whellGrade*10;
                }else{
                    delta=whellhis*whellGrade*10;
                    whellhis = 0;
                }
                whellGenEvent(delta);
                for(i=2;i>=0;i--)
                {
                    dirhis[i+1]=dirhis[i];
                }
                dirhis[0] = delta;
            }
        }
        return;
    }else{
        WHELL_SIMPLE_TIME=whell_run_time/5;
        if(pre_get_MACH_counter(&W_Encoder))
        {
            get_MACH_value(&W_Encoder);             //读w轴编码器值
        }
        delta = (W_Encoder.MACH_PositionValue>>2)-prevWhellpulse;
        if(delta!=0)
        {
            SetStartTick();
        }
        prevWhellpulse = (W_Encoder.MACH_PositionValue>>2);
    }
    if((nowWhellTick-prevWhellTick)>WHELL_SIMPLE_TIME)
    {
        prevWhellTick=nowWhellTick;
        //--------------------------------------
        if(pre_get_MACH_counter(&W_Encoder))
        {
            get_MACH_value(&W_Encoder);             //读w轴编码器值
        }
        if((feedGrade==0)||(rapidGrade==0))
        {
            prevWhellCTValue=(W_Encoder.MACH_PositionValue>>2);
            return;
        }
        if((DSPState&BIT_SPCGEN)/*&&((SPCsendcount-SPCruncount)<2)*/)
        {
            if((prevWhellCTValue!=(W_Encoder.MACH_PositionValue>>2))
                //||(whellPulseHistory[0]!=0)
                ||(whellPulseHistory[1]!=0)||(whellPulseHistory[2]!=0)
            )
            {
                whellPuseGen(prevWhellCTValue);
                prevWhellCTValue=(W_Encoder.MACH_PositionValue>>2);
            }
        }/*else{
            //if it is whell grade 1 and 10 ,don't omit this cycle's pulse
            //keep it for next cycle
            if(whellGrade>=100)
            {
                prevWhellCTValue=(W_Encoder.MACH_PositionValue>>2);
            }
        }*/
    }/*else if(smothFlag==1)
    {
        if((nowWhellTick-prevWhellTick)>=(WHELL_SIMPLE_TIME/2))
            whellPuseGen(prevWhellCTValue);
    }*/
    #endif
}
/*
*-----------------------------------------------------------------------------
* function: runBatCode
* parameter: key value
* return   : void
* description : handle the mode change keys,change system mode
*-----------------------------------------------------------------------------
*/
void whellPuseGen(U32 prevWhellCTValue)
{
    #if 0
    //#define WHELL_CODE_TIME (WHELL_SIMPLE_TIME+5)

    static U32 maxWhellSpeed=12000;
    static U32 prevSpeed=0;
    S32 delta=0;
    S32 sum=0;
    U32 tempPulseHis[3];
    if(autoAlarmClrFlag!=0)
        return;
    /*if(smothFlag==1)
        goto SMOTH_INSERT;*/
    //whellPulseHistory[2]=whellPulseHistory[1];
    //whellPulseHistory[1]=whellPulseHistory[0];
    whellPulseHistory[0]=(W_Encoder.MACH_PositionValue>>2)-prevWhellCTValue;
    //whellRecord[dtIndex]=whellPulseHistory[0];
    if(whellGrade==100)
    {
        sum=(whellPulseHistory[2]+whellPulseHistory[1]+whellPulseHistory[0]);
        whellPulseHistory[3]=sum/3;
        whellPulseHistory[2]=whellPulseHistory[3];
        //whellPulseHistory[1]=whellPulseHistory[2];
        whellPulseHistory[1]=sum-whellPulseHistory[3]-whellPulseHistory[2];
        whellPulseHistory[0]=0;
    if((whellPulseHistory[3]==0)
        &&(whellPulseHistory[2]==0))
    {
            whellPulseHistory[3]=whellPulseHistory[1];
            whellPulseHistory[1]=0;
    }
    }else{
        whellPulseHistory[3]=whellPulseHistory[0];
        whellPulseHistory[0]=0;
    }
    //deltaRecord[dtIndex]=whellPulseHistory[3];
    //dtIndex++;
    //if(dtIndex==2000)
    //    dtIndex=0;
    //if(whellGrade<100)
    {  //just send out the pulse  if grade is not 100
        delta=whellPulseHistory[3];

        whellFeedRate=60.0l*abs(delta)*whellGrade/WHELL_CODE_TIME;  //mm/minute
        delta=delta*whellGrade*10;
            //not less then ref search speed
    if(whellFeedRate<DSPparam.sysdword[35])
        whellFeedRate=DSPparam.sysdword[35];
        /*
        if((dimMode)&&(whellControlAxis==AXISX))
        {
           //if low speed,make it equ= pulse,
            delta=delta/2;
            whellFeedRate/=2;
        }*/
        whellGenEvent(delta);
        return;
    }
    /*
    //check if the speed is in real limit
    tempPulseHis[2]=abs(whellPulseHistory[2]);
    tempPulseHis[1]=abs(whellPulseHistory[1]);
    tempPulseHis[0]=abs(whellPulseHistory[0]);
    if(((tempPulseHis[1]<=(pulseRealLimit+1))
        &&(tempPulseHis[2]<=pulseRealLimit)
        &&(tempPulseHis[2]<=pulseRealLimit))
    ||((tempPulseHis[1]<=pulseRealLimit)&&
       (tempPulseHis[2]<=pulseRealLimit))
    ||((tempPulseHis[1]<=pulseRealLimit)&&
       (tempPulseHis[0]<=pulseRealLimit))
    )
    {   //code should be send out as long as whell pulse
        delta=whellPulseHistory[1];

        whellFeedRate=60.0l*abs(delta)*whellGrade/WHELL_CODE_TIME;  //mm/minute
        delta=delta*whellGrade*10;
        /*
        if((dimMode)&&(whellControlAxis==AXISX))
        {
           //if low speed,make it equ= pulse,
            delta=delta/2;
            whellFeedRate/=2;
        }* /
        whellGenEvent(delta);
        return;
    }
    //below ,is grade=100 and hight speed need to be smothed.
SMOTH_SHAKE:
    {
    S32 ac1,ac2,dir;
    ac1=whellPulseHistory[1]-whellPulseHistory[2];
    ac2=whellPulseHistory[0]-whellPulseHistory[1];
    dir=ac1*ac2;
    if((abs(ac1)<=pulseSmothLimit)
        &&(abs(ac2)<=pulseSmothLimit)
        &&(dir<0))
    { // a shake with two different acclerate direction
        whellPulseHistory[1]=whellPulseHistory[2];
        delta=whellPulseHistory[1];

        whellFeedRate=60.0l*abs(delta)*whellGrade/WHELL_CODE_TIME;  //mm/minute
        delta=delta*whellGrade*10;
        goto FEED_CHECK;
    }
    }

SMOTH_INSERT:
    if((smothFlag==0)&&
        (abs(whellPulseHistory[1]-whellPulseHistory[2])>pulseDeltaLimit))
    { //need to gen a somth fail pulse
        smothPulse=whellPulseHistory[1];
        smothFlag=1;
        delta=(whellPulseHistory[2]+whellPulseHistory[1])/2;

        whellFeedRate=60.0l*abs(delta)*whellGrade/WHELL_CODE_TIME;
        delta=delta*whellGrade*10;//*0.8;//2;
        if((delta%(whellGrade*10))!=0)
                delta=delta-(delta%(whellGrade*10))+(whellGrade*10);
        //prevPulse=delta;
       // decCT++;
    }else{
        //prevPulse=delta;
        delta=whellPulseHistory[1];

        whellFeedRate=60.0l*abs(delta)*whellGrade/WHELL_CODE_TIME;
        delta=delta*whellGrade*10;
        if(smothFlag==1)
        {
            //delta=delta*0.8;//2;
            if((delta%(whellGrade*10))!=0)
                delta=delta-(delta%(whellGrade*10))+(whellGrade*10);
            smothFlag=0;
        }
    }

FEED_CHECK:
    //not less then ref search speed
    if(whellFeedRate<DSPparam.sysdword[35])
        whellFeedRate=DSPparam.sysdword[35];

    //it should be limit by the max speed of system too
    if(whellFeedRate>maxWhellSpeed)
    {
        //int debug;
        whellFeedRate=maxWhellSpeed;
        prevSpeed=whellFeedRate;
        if(delta>0)
            delta=10*whellFeedRate*WHELL_CODE_TIME/60;  //get direction
        else
            delta=0-10*whellFeedRate*WHELL_CODE_TIME/60;
        //make it look like a whell gened pulse
        if((delta%(whellGrade*10))!=0)
            delta=delta-(delta%(whellGrade*10))+(whellGrade*10);
    }
    whellGenEvent(delta);*/
    #endif
}
/*
*------------------------------------------------------------------------------
* function: whellGenEvent
* parameter: delta of pulse
* return   : void
* description : generate event of whell code .
*-----------------------------------------------------------------------------
*/
void whellGenEvent(S32 delta)
{
    //limit checks
    if((dimMode)&&(whellControlAxis==AXISX))
    {
        //if low speed,make it equ= pulse,
        delta=delta/2;
        whellFeedRate/=2;
    }
    if(whellControlAxis==AXISX)
    {
        if(SYSparam[91].val==0)
        {//hardlimit enable
            if(((hardLimitPosState&BITX)&&(delta>0))  //if limit hit lock it
               ||((hardLimitNegState&BITX)&&(delta<0)))
                delta=0;
        }
        if(((softLimitPosState&BITX)&&(delta>0))  //if limit hit lock it
        ||((softLimitNegState&BITX)&&(delta<0)))
            delta=0;

        coordSPCGend.x+=delta;//*whellGrade;
    }else if(whellControlAxis==AXISZ){

        if(SYSparam[91].val==0)
        {//hardlimit enable
            if(((hardLimitPosState&BITZ)&&(delta>0))
            ||((hardLimitNegState&BITZ)&&(delta<0)))
                delta=0;
        }
        if(((softLimitPosState&BITZ)&&(delta>0))  //if limit hit lock it
        ||((softLimitNegState&BITZ)&&(delta<0)))
            delta=0;
        coordSPCGend.z+=delta;//*whellGrade;
    }else if((whellControlAxis==AXISY)){
        if(!Yavailable)delta=0;
        if(SYSparam[91].val==0)
        {//hardlimit enable
            if(((hardLimitPosState&BITY)&&(delta>0))
            ||((hardLimitNegState&BITY)&&(delta<0)))
                delta=0;
        }
        if(((softLimitPosState&BITY)&&(delta>0))  //if limit hit lock it
        ||((softLimitNegState&BITY)&&(delta<0)))
            delta=0;
        coordSPCGend.y+=delta;//*whellGrade;
    }

    if(delta!=0)
    {
//        taskEventBuf[taskEventCount]=TEVENT_SENT_JOGCODE;
            //jogCode(1);
            armCMDB4();
//        taskEventCount++;
    }
}

/*
*------------------------------------------------------------------------------
* function: runBatCode
* parameter: key value
* return   : void
* description : handle the mode change keys,change system mode
*-----------------------------------------------------------------------------
*/
void whellRunInterval(void)
{
    #if 0
    //#define WHELL_RUN_SAMPLET  (50)
    U32 WHELL_RUN_SAMPLET;
    GCODE  *GCodeRunPointer;
    U32 ri;
    static U32 prevWhellTick;
    static U32 nowWhellTick;
    static U32 prevWhellValue;
    static U16 grade=12;
    //static U8 g0time=10;
    static U16 prevwhelldir;
    U32 nowVal,delta;
    if(whellRunState==0)
    {
        whellRunState=1;
        clear_W_encoder();
        prevWhellTick=OSGetTimeTick();
        return;
    }

    ri = (STDNCState.RealRunCount-1) % STDGCODE_MOD;
    GCodeRunPointer = &GCodeBuffer[ri];
    if(GCodeRunPointer->CMD1==0)         //G0 慢一点
    {
        WHELL_RUN_SAMPLET=10;
        grade=12;
    }else
    {
        WHELL_RUN_SAMPLET=30;
        grade=6;
    }
    nowWhellTick=OSGetTimeTick();
    if((nowWhellTick-prevWhellTick)<WHELL_RUN_SAMPLET)
        return;

    prevWhellTick=nowWhellTick;
    if(pre_get_MACH_counter(&W_Encoder))
    {
        get_MACH_value(&W_Encoder);             //读w轴编码器值
    }
    nowVal=W_Encoder.MACH_PositionValue;
    delta=nowVal-prevWhellValue;
    prevWhellValue=nowVal;
    if(delta!=0)
    {
        if(delta<0x80000000)
        {
            if(prevwhelldir==0)
            {
                whelldir=0;
            }else{
                if((DSPState&BIT_LOCA_OVER)&&(locateState&(BITX|BITZ|(Yavailable?BITY:0))&&(realFeedSpeed==0)))
                {
                    whelldir=0;
                }else{
                    whellRunGrade=0;
                    return;
                }
            }
        }else{
            if(prevwhelldir==1)
            {
                whelldir=1;
            }else{
                if((DSPState&BIT_LOCA_OVER)&&(locateState&(BITX|BITZ|(Yavailable?BITY:0))&&(realFeedSpeed==0)))
                {
                    whelldir=1;
                }else{
                    whellRunGrade=0;
                    return;
                }
            }
        }
        delta=abs(delta);
        whellRunGrade=(delta/grade);
        if(whellRunGrade>10)
            whellRunGrade=10;
        else if(whellRunGrade==0)
            whellRunGrade=1;
        if((whelldir==1)&&(whellreachstart==1))
        {
            whellRunGrade=0;
        }
    }else{
        whellRunGrade=0;
        whelldir=0;
    }
    prevwhelldir=whelldir;
    #endif
}

/*
*------------------------------------------------------------------------------
* function: runBatCode
* parameter: key value
* return   : void
* description : handle the mode change keys,change system mode
*-----------------------------------------------------------------------------
*/
void runBatCode()
{
    //if not in auto mode or pause if set
    static U8 CMDB0Interval=0;
    if((sysState!=SYS_STATE_AUTO)||(0!=pauseFlag))
        return;
    CMDB0Interval++;
    if((taskEventCount==0)
    &&(DSPState&BIT_STDGEN)
    &&(!CYCLE_BUF_EMPTY(DGwptr,DGrptr))
    &&(assistenFlag==FALSE))
    {
        if((sysMode!=SYS_MODE_AUTO)||(sysState==SYS_STATE_ALARM))\
            return;
        SendSTDGcode();
    /*
        taskEventBuf[taskEventCount]=TEVENT_SENT_BATCODE;
        taskEventCount++; 
        if(CMDB0Interval>10)
        {
            CMDB0Interval=0;
            //make a idle event to sent grade info to dsp
            taskEventBuf[taskEventCount]=TEVENT_IDLE;
            taskEventCount++;             
        }*/        
    }    
}
/*
*------------------------------------------------------------------------------
* function: sysModeChange
* parameter: key value
* return   : void
* description : handle the mode change keys,change system mode
*------------------------------------------------------------------------------
*/
void sysModeChange(U8 keyval)
{
    //U8 changed=FALSE;
    if(sysState<=SYS_STATE_INIT7)
        return;   //not finish init yet
        /*
    if(refFounded)
    {
        if((gexecState>=GEXEC_RUNINIT)&&(gexecState<GEXEC_DONE))
            return;
    }*/
    if(sysMode==SYS_MODE_REF)
    {
        return;
    }

    if((sysState==SYS_STATE_WHEEL)||(sysState==SYS_STATE_JOG))
    {
        if(!(DSPState&BIT_CODE_OVER))
        {
            return;
        }
    }
    if((sysMode==SYS_MODE_EDIT)&&(keyval!=KEY_EDIT))
    {
        //auto save edit file if we left edit
//        editSaveFile();
    }
    if(GEXEC_STATE_RUNING)
    { //is runing bat code in auto mode ,only single mode stoped can change mode
        if((pauseFlag==1)||
          ((singleModeFlag==TRUE)&&(DSPState&BIT_SINGLE_END)))
        {
            if((keyval!=KEY_WHEEL)&&(keyval!=KEY_JOG))
                return;
            else{
                //it case special out from auto mode
                if(mdimode.mdirunning!=1)
                    addLineMode=1;
            }
        }else{
            return;
        }
    }

    switch(keyval)
    {
        case(KEY_EDIT):
            if(addLineMode==1)
                return;
            if(sysState!=SYS_STATE_EDIT)
            {
                if(taskEventCount<TASK2EVENT_MAX)
                {
                    sysState=SYS_STATE_EDIT;
                    sysMode=SYS_MODE_EDIT;
                    //spinRunSign=0;
                }
            }
            //change to edit file gui if it has a file
            if(editHasFile)
            {
                currentGUI=GUINUM_EDIT;
                gexecState=GEXEC_RESET;
                sourceCT=0; //rest the compiled
               // compile
            }
            //set spindle stop
            //spinRunSign=0;
            //gWorkState.sdir=5;
            //setIOOUT(IOOUT_SPIN_RUN, FALSE);
            ////PLC_NCSTAT_SSTOP;
            break;
        case(KEY_AUTO):
            if(sysState==SYS_STATE_ALARM)
                return;
            if(refFounded==0)
            {
                //showHint(OPERR_NOREF,SHOW_TIME_NORMAL);
                return;
            }
            if(sysState==SYS_STATE_AUTO)
                return;
            if(taskEventCount<TASK2EVENT_MAX)
            {

                if(addLineMode==0)
                {
                    sysState=SYS_STATE_AUTO;
                    sysMode=SYS_MODE_AUTO;
                    STDruncount=0;  //clear g code counter
                    STDrealsendcount=0;
                    STDsendcount=0;
                    //singleModeFlag=0; //clear singel mode
                    coordGend[0]=coordWork;
                    STDsendcount++;
                    gWorkState.f=0;
                    //gWorkState.s=0;
                    gWorkState.fseted=0;
                    taskEventBuf[taskEventCount]=TEVENT_MOD_AUTO;
                    taskEventCount++;
                }else{
                    //check chuck state since it may be changed in pause
                    if(chuckAutoStateChanged==TRUE)
                    {
                        //if(gWorkState.chuck!=chuckAutoStateBak)
                        if((gWorkState.chuck==13)&&
                          (chuckAutoStateBak==12))
                        {
                            //showHint(GERR_STATE_NORESUM, SHOW_TIME_NORMAL);
                            return;
                        }else{
                            chuckAutoStateChanged=FALSE;
                        }
                    }
                    //check tail state since it may be change
                    if(tailAutoStateChanged==TRUE)
                    {
                        //if(gWorkState.chuck!=chuckAutoStateBak)
                        if(((gWorkState.tail==11)&&(tailAutoStateBak==10))
                         ||((gWorkState.tail==10)&&(tailAutoStateBak==11)))
                        {
                            //showHint(GERR_STATE_NORESUM, SHOW_TIME_NORMAL);
                            return;
                        }else{
                            tailAutoStateChanged=FALSE;
                        }
                    }
                    if(spindleAutoStateChanged==TRUE)
                    {
                        if(gWorkState.sdir!=spindleAutoStateBak)
                        {
                            //showHint(GERR_STATE_NORESUM, SHOW_TIME_NORMAL);
                            return;
                        }else{
                            spindleAutoStateChanged=FALSE;
                        }
                    }
                    sysState=SYS_STATE_AUTO;
                    sysMode=SYS_MODE_AUTO;
                    addLineMode=2;
                    pauseFlag=1;
                    taskEventBuf[taskEventCount]=TEVENT_MOD_AUTO;
                    taskEventCount++;
                }
            }
            break;
        case(KEY_MDI):
            if(addLineMode==1)
                return;
            if(sysState==SYS_STATE_MDI)
                return;
            if(sysState!=SYS_STATE_ALARM) //MDI MODE can be change form alarm
                sysState=SYS_STATE_MDI;
            sysMode=SYS_MODE_MDI;
            //spinRunSign=0;
            //gWorkState.sdir=5;
            ////PLC_NCSTAT_SSTOP;
            //setIOOUT(IOOUT_SPIN_RUN, FALSE);
            break;
        case(KEY_REF):
            if(DSPparam.sysbyte[92]==1)
                return;
            if(addLineMode==1)
                return;
            if((sysState>=SYS_STATE_REF)&&(sysState<=SYS_STATE_REF_END))
                return;
            if((rapidGrade==0)||(feedGrade==0))
                return;
            //if we are just after start up and with on ref, do it
            if((!REFERENCE_ALLOK))
            {
                refFounded=0;
    /*            Reference.FindRefSign.X=0;
                Reference.FindRefSign.Z=0;
                Reference.FindRefSign.Y=0;*/
                sysState=SYS_STATE_REF;
                sysMode=SYS_MODE_REF;
                refFindAxis=0;
                spinRunSign=0;
                SPCsendcount=0;
                SPCruncount=0;
                SPCsendcount=0;
                coordSPCGend=coordWork;
                //coordGend[0]=coordWork;
                coordGendSPC[0]=coordWork;
                taskEventBuf[taskEventCount]=TEVENT_FIND_REF;
                taskEventCount++;
                //changed=TRUE;
            }else{
                //go to the mach coord origin as g28
                if(sysState==SYS_STATE_ZERO)
                    return;
                if(sysState!=SYS_STATE_ALARM)
                    sysState=SYS_STATE_ZERO;
                sysMode=SYS_MODE_ZERO;
                //spinRunSign=0;
                SPCsendcount=0;
                SPCruncount=0;
                SPCsendcount=0;
                //gWorkState.sdir=5;
                coordSPCGend=coordWork;
                //coordGend[0]=coordWork;
                coordGendSPC[0]=coordWork;
                taskEventBuf[taskEventCount]=TEVENT_MOD_ZERO;
                taskEventCount++;
            }
            break;
        case(KEY_WHEEL): //whell mode is the only mode can be change to while limit hit
            if(sysState==SYS_STATE_WHEEL)
                return;
            if(sysState!=SYS_STATE_ALARM)
                sysState=SYS_STATE_WHEEL;
            sysMode=SYS_MODE_WHEEL;
            //spinRunSign=0;
            SPCsendcount=0;
            SPCruncount=0;
            if(softLimitNegState&BITA4)
            { // if in restrect area
                if(whellGrade==100)
                    whellGrade=10;
            }
            /*
            if(addLineMode==0)
            {   //if we are in scecpial mode, not chane s
                if(gWorkState.sSetVal!=0)
                    gWorkState.s=gWorkState.sSetVal;
                else
                    gWorkState.s=DSPparam.sysdword[39];
            }*/
            coordSPCGend=coordWork;
            //coordGend[0]=coordWork;
            coordGendSPC[0]=coordWork;
            taskEventBuf[taskEventCount]=TEVENT_MOD_WHELL;
            taskEventCount++;
            break;
        case(KEY_JOG):
            if(sysState==SYS_STATE_JOG)
                return;
            if(softLimitNegState&BITA4)
            { // if in restrect area
                return;
            }
            if(taskEventCount<TASK2EVENT_MAX)
            {
                sysState=SYS_STATE_JOG;
                sysMode=SYS_MODE_JOG;
                SPCruncount=0;
                SPCsendcount=0;
                /*
                if(addLineMode==0)
                {   //if we are in scecpial mode, not chane s
                    if(gWorkState.sSetVal!=0)
                        gWorkState.s=gWorkState.sSetVal;
                    else
                        gWorkState.s=DSPparam.sysdword[39];
                }*/
                coordSPCGend=coordWork;
                //coordGend[0]=coordWork;
                coordGendSPC[0]=coordWork;
                taskEventBuf[taskEventCount]=TEVENT_MOD_JOG;
                taskEventCount++;
            }
            break;
    }
}

/*
*------------------------------------------------------------------------------
* function: mannualrun
* parameter: key value
* return   : void
* description : handle the mannual run keys ,make g code.
*------------------------------------------------------------------------------
*/
void mannualrun(U16 keyval, U16 prev)
{
    //check if thers's a job code in event buffer if so, do nothing
    //static U32 errjog=0;
    U8 axis=0;
    if(sysState==SYS_STATE_ZERO)
    {   //triger go zero even
        if(keyval&(JOGKEY_XN|JOGKEY_XP))
            axis|=1;
        if(keyval&(JOGKEY_ZN|JOGKEY_ZP))
            axis|=2;
        if((keyval&(JOGKEY_YN|JOGKEY_YP))&&(Yavailable))
            axis|=4;
        if(axis!=0)
            goZero(0, axis);
		return;
    }
    if((!REFERENCE_ALLOK)&&(sysMode==SYS_MODE_REF)&&(sysState==SYS_STATE_REF_STANDBY))
    {
        axis=(keyval&(JOGKEY_XP|JOGKEY_XN|JOGKEY_ZP|JOGKEY_ZN|(Yavailable?JOGKEY_YP|JOGKEY_YN:0)));
        if(axis==0)
            return;
        refFindAxis=axis;
        refFounded=0;
        sysState=SYS_STATE_REF;
        sysMode=SYS_MODE_REF;
        spinRunSign=0;
        SPCsendcount=0;
        SPCruncount=0;
        SPCsendcount=0;
        coordSPCGend=coordWork;
        coordGend[0]=coordWork;
        coordGendSPC[0]=coordWork;
        taskEventBuf[taskEventCount]=TEVENT_FIND_REF;
        taskEventCount++;
    }
    if(!((sysState==SYS_STATE_JOG)||
        ((sysState==SYS_STATE_ALARM)&&(sysMode==SYS_MODE_JOG)&&ALM_IS_LIMITS)))
        return;
    if((feedGrade==0)||(rapidGrade==0))
        return;
    if(!(DSPState&BIT_LOCA_OVER))
    {
        return;
    }

    if(!((DSPState&BIT_SPCGEN)&&(coordStable==TRUE)))
        return;
    if(taskEventCount<(TASK2EVENT_MAX-3))
    {
        keyval&=(JOGKEY_XP|JOGKEY_XN|JOGKEY_ZP|JOGKEY_ZN|(Yavailable?JOGKEY_YP|JOGKEY_YN:0));
        if(keyval==0) //not x and z ,do nothing
            return;
        //taskEventBuf[taskEventCount]=(keyval<<16)|TEVENT_SENT_JOGCODE;
        //taskEventCount++;
        jogCode(keyval);
        armCMDB4();
    }
}
/*
*------------------------------------------------------------------------------
* function: coordUpdate
* parameter: which coord to go zero 0 mach 1 abs,xz 1,x 2 z 3 both
* return   : void
* description : update the coordinate info showing
*------------------------------------------------------------------------------
*/
void goZero(U8 isABS,U8 xz)
{
    if(!((SYS_MODE_ZERO==sysMode)||(SYS_MODE_JOG==sysMode)||(SYS_MODE_WHEEL==sysMode)))
        return;
    if(!refFounded)
        return;
    if((rapidGrade==0)||(feedGrade==0))
        return;
    //goZeroSign=1;
    if(isABS==0) //goto mach zero
    {
        if(xz&0x01)
        {
            coordWork.x=0-coordOrginWork.x-coordShiftWork.x;
        }
        if(xz&0x02)
        {
            coordWork.z=0-coordOrginWork.z-coordShiftWork.z;
        }
        if(xz&0x04)
        {
            coordWork.y=0-coordOrginWork.y-coordShiftWork.y;
        }
    }else{
        TCoord tmach;
        if(SYS_MODE_ZERO!=sysMode)
            return;
        tmach.x=IIC_Read4(IICADDR_PROGX);
        tmach.z=IIC_Read4(IICADDR_PROGZ);
        tmach.y=IIC_Read4(IICADDR_PROGY);
        coordWork.x=tmach.x-coordOrginWork.x-coordShiftWork.x;
        coordWork.z=tmach.z-coordOrginWork.z-coordShiftWork.z;
        coordWork.y=tmach.y-coordOrginWork.y-coordShiftWork.y;
        programZeroFlag=1;
    }
    coordSPCGend=coordWork;
    coordCurGend=coordWork;
    if(SYS_MODE_WHEEL==sysMode)
    {
        whellFeedRate=jogFeed;
    }
    //taskEventBuf[taskEventCount]=TEVENT_SENT_JOGCODE;
    //taskEventCount++;
    //jogCode(0);
    armCMDB4(); 
}
/*
*------------------------------------------------------------------------------
* function: coordUpdate
* parameter: new coord value
* return   : void
* description : update the coordinate info showing
*------------------------------------------------------------------------------
*/
void coordUpdate()
{
    //update coordinate
    coordWorkBack.x=coordMACH.x-coordOrginWork.x-coordShiftWork.x;
    coordWorkBack.z=coordMACH.z-coordOrginWork.z-coordShiftWork.z;
    coordWorkBack.y=coordMACH.y-coordOrginWork.y-coordShiftWork.y;
    coordRemain.x=abs(coordCurGendMach.x-coordMACH.x);
    coordRemain.z=abs(coordCurGendMach.z-coordMACH.z);
    coordRemain.y=abs(coordCurGendMach.y-coordMACH.y);
    coordRelate.x=coordMACH.x-coordOrginRelate.x;
    coordRelate.z=coordMACH.z-coordOrginRelate.z;
    coordRelate.y=coordMACH.y-coordOrginRelate.y;
    coordWorkShow.x=coordWorkBack.x;
    coordWorkShow.z=coordWorkBack.z;
    coordWorkShow.y=coordWorkBack.y;
    coordMACHShow.x=coordMACH.x;
    coordMACHShow.z=coordMACH.z;
    coordMACHShow.y=coordMACH.y;
    //filter x
    if(SYSparam[71].val==0)
    {
        if((coordRemain.x!=0)&&(coordRemain.x<=10))
        {
            coordWorkShow.x=coordWorkShow.x+coordCurGendMach.x-coordMACH.x;
            coordRemain.x=0;
            coordMACHShow.x=coordCurGendMach.x;
            coordRelate.x=coordRelate.x+coordCurGendMach.x-coordMACH.x;
        }
        if((coordRemain.z!=0)&&(coordRemain.z<=10))
        {
            coordWorkShow.z=coordWorkShow.z+coordCurGendMach.z-coordMACH.z;
            coordRemain.z=0;
            coordMACHShow.z=coordCurGendMach.z;
            coordRelate.z=coordRelate.z+coordCurGendMach.z-coordMACH.z;
        }
        if((coordRemain.y!=0)&&(coordRemain.y<=10))
        {
            coordWorkShow.y=coordWorkShow.y+coordCurGendMach.y-coordMACH.y;
            coordRemain.y=0;
            coordMACHShow.y=coordCurGendMach.y;
            coordRelate.y=coordRelate.y+coordCurGendMach.y-coordMACH.y;
        }
    }
    Trace_Real_Coord(); 
    //alarmSoftLimitCheck();
}
//*****************************************************************************
/*
*------------------------------------------------------------------------------
* function: coordClear
* parameter: new coord value for witch to clear ,
* return   : void
* description : lclear the x or z value in coord currently showing
*------------------------------------------------------------------------------
* /
void coordClear(U8 xz)
{
    if((sysMode==SYS_MODE_AUTO)
        ||(sysMode==SYS_MODE_REF)
        ||(sysMode==SYS_MODE_ZERO))
        return;
    else if(currentGUI==GUINUM_COORDR) //relate
    {
        if(xz==0)
        {
            coordOrginRelate.x=coordRelate.x+coordOrginRelate.x;
            coordRelate.x=0;
            IIC_Write4(IICADDR_ORGRX, coordOrginRelate.x);
        }else if(xz==1)
        {
            coordOrginRelate.z=coordRelate.z+coordOrginRelate.z;
            coordRelate.z=0;
            IIC_Write4(IICADDR_ORGRZ, coordOrginRelate.x);
        }

    }
}

/ *
*------------------------------------------------------------------------------
* function: workCoordSet
* parameter: new coord value
* return   : void
* description : set a new work coord value;
*------------------------------------------------------------------------------
*/
void workCoordSet(S32 Newval,U8 xz)
{
    if((sysMode==SYS_MODE_AUTO)
        ||(sysMode==SYS_MODE_REF)
        ||(sysMode==SYS_MODE_ZERO))
        return;
    if((currentGUI!=GUINUM_MAIN)
        &&(currentGUI!=GUINUM_COORD)
        &&(currentGUI!=GUINUM_COORDS))
    {
        return;
    }
    if(xz==AXISX)
    {
        if(dimMode)
        {
            Newval=Newval/2;
        }
        coordOrginWork.x=coordWork.x+coordOrginWork.x-Newval;
        coordOrginWorkG5x[gWorkState.GG05].x=coordOrginWork.x-coordOrginWorkG5x[0].x;
        coordWork.x=Newval;
        if(machLockFlag==FALSE)
        {
            IIC_Write4(IICADDR_G5X_X+(gWorkState.GG05)*4,coordOrginWorkG5x[gWorkState.GG05].x);
            IIC_Write4(IICADDR_PROGX,coordWork.x+coordOrginWork.x+coordShiftWork.x);
        }
    }else if(xz==AXISZ){
        coordOrginWork.z=coordWork.z+coordOrginWork.z-Newval;
        coordOrginWorkG5x[gWorkState.GG05].z=coordOrginWork.z-coordOrginWorkG5x[0].z;
        coordWork.z=Newval;
        if(machLockFlag==FALSE)
        {
            IIC_Write4(IICADDR_G5X_Z+(gWorkState.GG05)*4,coordOrginWorkG5x[gWorkState.GG05].z);
            IIC_Write4(IICADDR_PROGZ,coordWork.z+coordOrginWork.z+coordShiftWork.z);
        }
    }else if(xz==AXISY){
        coordOrginWork.y=coordWork.y+coordOrginWork.y-Newval;
        coordOrginWorkG5x[gWorkState.GG05].y=coordOrginWork.y-coordOrginWorkG5x[0].y;
        coordWork.y=Newval;
        if(machLockFlag==FALSE)
        {
            IIC_Write4(IICADDR_G5X_Y+(gWorkState.GG05)*4,coordOrginWorkG5x[gWorkState.GG05].y);
            IIC_Write4(IICADDR_PROGY,coordWork.y+coordOrginWork.y+coordShiftWork.y);
        }
    }
    coordSPCGend=coordWork;
    coordGend[0]=coordSPCGend;
    coordCurGend=coordSPCGend;
    //coordRef[0]=coordOrginWork;
    if(sysMode==SYS_MODE_AUTO)
    {
        taskEventBuf[taskEventCount++]=TEVENT_COORDOFFSET;
    }else if(sysMode==SYS_MODE_JOG)
    {
        taskEventBuf[taskEventCount++]=TEVENT_MOD_JOG;
        SPCruncount=0;
        SPCsendcount=0;
    }else if(sysMode==SYS_MODE_WHEEL)
    {
        taskEventBuf[taskEventCount++]=TEVENT_MOD_WHELL;
        SPCruncount=0;
        SPCsendcount=0;
    }

    //SPCruncount=0;
    //SPCsendcount=0;
}


/*
*------------------------------------------------------------------------------
* function: workCoordClear
* parameter: void
* return   : void
* description : set  work coord to half or its orignal value;
*------------------------------------------------------------------------------
*/
void relateCoordSet(S32 Newval,U8 xz)
{
    if((sysMode==SYS_MODE_AUTO)
        ||(sysMode==SYS_MODE_REF)
        ||(sysMode==SYS_MODE_ZERO))
        return;
    if((currentGUI!=GUINUM_MAIN)
        &&(currentGUI!=GUINUM_COORD)
        &&(currentGUI!=GUINUM_COORDS))
    {
        return;
    }
    if(xz==AXISX)
    {
        if(dimMode)
        {
            Newval=Newval/2;
        }
        coordOrginRelate.x=coordRelate.x+coordOrginRelate.x-Newval;
        coordRelate.x=Newval;
        if(machLockFlag==FALSE)
            IIC_Write4(IICADDR_ORGRX, coordOrginRelate.x);
    }else if(xz==AXISZ){
        coordOrginRelate.z=coordRelate.z+coordOrginRelate.z-Newval;
        coordRelate.z=Newval;
        if(machLockFlag==FALSE)
            IIC_Write4(IICADDR_ORGRZ, coordOrginRelate.z);
    }else if(xz==AXISY){
        coordOrginRelate.y=coordRelate.y+coordOrginRelate.y-Newval;
        coordRelate.y=Newval;
        if(machLockFlag==FALSE)
            IIC_Write4(IICADDR_ORGRZ, coordOrginRelate.y);
    }
}
/*
*------------------------------------------------------------------------------
* function: coordOffsetAck
* parameter: void
* return   : void
* description : check if we had set the coord offset ok
*------------------------------------------------------------------------------
*/
void coordOffsetAck(void)
{
    if((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER))
    {
        assistStart=FALSE;
        assistenFlag=FALSE;
    }
}
/*
*------------------------------------------------------------------------------
* function: fileSystemHandle
* parameter: void
* return   : void
* description : handle the sd insert or not
*------------------------------------------------------------------------------
*/
void fileSystemHandle(void)
{
    #if 0
   static U8 prevstate;
   if((sysMode==SYS_MODE_AUTO)&&
        (gexecState>=GEXEC_RUNINIT)&&(gexecState<GEXEC_DONE))
   { // to avoid efect real time preformence
     //do not detect sd insert in runing gcode,
     //but the card reject must be detect
        if(!(prevstate&SD_INSERTED))
        return;
   }
   SD_Detect();
   if(prevstate!=SDstate)
   {
       if(SDstate&SD_INSERTED)
       {

            FATdir[0]='\0';
            f_mount(0, &SDfs);
            FileMangeEnter();
       }else{
            FATfileCT=0;
            FATcurFile=0;
            FAToffset=0;
            FATdir[0]='\0';
            f_mount(0, NULL);
       }
       prevstate=SDstate;
   }
   #endif
}
/*
*------------------------------------------------------------------------------
* function: //showHint
* parameter: void
* return   : void
* description :  set a message in cmdline to be show, set the delay time;
*------------------------------------------------------------------------------
*/
void showHint(U16 hint, U16 delay)
{
    cmderr=hint;
    showTime=delay;
    showMsg=TRUE;
}

//****************************************************************************
//IO FUNCTIONS

/*
*------------------------------------------------------------------------------
* function: AssistenFunction
* parameter: void
* return   : void
* description :  handle IO input or output, do io related job
*------------------------------------------------------------------------------
*/
void AssistenFunction()
{

    U32 sendCount;
    if(assistenFlag==FALSE)
    {
        return;
    }
    switch(assistenCode.gnum)
    {
        case(GCODE_S):
        case(GCODE_SCREW):
        case(GCODE_T):
        case(GCODE_M65):
        case(GCODE_54):
            sendCount=((PDGBmfst)&assistenCode)->sendCount;
            break; 
        case(GCODE_M00):
        case(GCODE_M03):
        case(GCODE_M04):
        case(GCODE_M05):
        case(GCODE_M08):
        case(GCODE_M09):
        case(GCODE_M10):
        case(GCODE_M11):
        case(GCODE_M12):
        case(GCODE_M13):
        case(GCODE_M19):
        case(GCODE_M32):
        case(GCODE_M33):
        case(GCODE_M41):
        case(GCODE_M42):
        case(GCODE_M43):
        case(GCODE_M44):
            sendCount=((PDGBmfst)&assistenCode)->sendCount;
            break;
        case(GCODE_50):
            sendCount=((PDGBline)&assistenCode)->sendCount;
            break;
        default:
            DEBUGMSG(4,"Assisten warning: unkown gcode type\n");
            while(1);
    }
    //if an assistenFlag is set,we had to wait the prev code tobe finish
    if((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER)
    &&(STDruncount==sendCount))
    {
        if(((assistenCode.gnum>=GCODE_M08)&&(assistenCode.gnum<=GCODE_M13))
        ||(assistenCode.gnum==GCODE_M32)
        ||(assistenCode.gnum==GCODE_M33)
        ||(assistenCode.gnum==GCODE_M65))
        {
            if(assistStart==FALSE) //wait for start
            {
                if((!(CYCLE_BUF_EMPTY(mbufwptr, mbufrptr)))
                ||(mfuncState!=MFUNCS_OFF))
                {
                    return;
                }
            }else{ //wait for plc process end
                //wait autoAssistenPlcRequest=2;
                if(autoAssistenPlcRequest<2)
                    return;
                else{
                    autoAssistenPlcRequest=0;
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                    return;
                }
            }
            //assistStart=TRUE;*/
            //assistenTimer=OSGetTimeTick();
        }
         //   return; //action had done ,just wait for result
        switch(assistenCode.gnum)
        {
            case(GCODE_50):
                coordSetInRun();
                assistStart=FALSE;
                assistenFlag=FALSE;
                break;
            case(GCODE_54):
                {
                    PDGBmfst pt=(PDGBmfst)&assistenCode;
                    if(pt->value>=G5X_MAX||pt->value==0)
                    {
                        break;
                    }
                    coordWork.x=coordWork.x-coordOrginWorkG5x[gWorkState.GG05].x+coordOrginWorkG5x[pt->value].x;
                    coordWork.z=coordWork.z-coordOrginWorkG5x[gWorkState.GG05].z+coordOrginWorkG5x[pt->value].z;
                    coordWork.y=coordWork.y-coordOrginWorkG5x[gWorkState.GG05].y+coordOrginWorkG5x[pt->value].y;
                    coordOrginWork.x=coordOrginWork.x-coordOrginWorkG5x[gWorkState.GG05].x+coordOrginWorkG5x[pt->value].x;
                    coordOrginWork.z=coordOrginWork.z-coordOrginWorkG5x[gWorkState.GG05].z+coordOrginWorkG5x[pt->value].z;
                    coordOrginWork.y=coordOrginWork.y-coordOrginWorkG5x[gWorkState.GG05].y+coordOrginWorkG5x[pt->value].y;
                    gWorkState.GG05=pt->value;
                    toolReposition=2;
                    taskEventBuf[taskEventCount++]=TEVENT_COORDOFFSET;
                    coordSPCGend=coordWork;
                    coordCurGend=coordWork;
                    coordSentedGend=coordWork;
                    coordCurGstart=coordWork;
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                    break;
                }
            case(GCODE_T):
            	{
	        		U8 tool_num;
	            	PDGBmfst pt=(PDGBmfst)&assistenCode;
	            	nextTool=pt->value;
	            	//here the tool val should had been check
	            	//in gcode compile, save it
					if(Toolchange==0)
					{
		            	tool_num = nextTool/100;
			            if((tool_num<=SYSparam[170].val)
			                ||(SYSparam[170].val==1))
			            {
							Toolchange = 1;
			            }
					}
	            }
                break;
            case(GCODE_M00):
                //set the hold key to be true
                pauseFlag=1;
                assistStart=FALSE;
                assistenFlag=FALSE;
                break;
            case(GCODE_S):
                {
                PDGBmfst pt=(PDGBmfst)&assistenCode;
                gWorkState.s=pt->value;
                }
                if(gWorkState.sdir==5) //stoped
                {
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                    return;
                }
            case(GCODE_M03):
            case(GCODE_M04):
                //here we wait spindle to turn stable
                {
                    U32 sdelta;
                    U32 curTime;
                    U32 sreq;//=gWorkState.s*spindleGrade/10;
                    U32 rate=SYSparam[46].val%10;
                    if(rate<2)
                        rate=2;
                    if(assistenTimer==0)
                    {
                        assistenTimer=SYSparam[46].val/10;
                        if(assistenTimer==0)
                            assistenTimer=10000;
                        else
                            assistenTimer*=1000;
                    }
                    //if we are in g96, we just as it to turn on

                    sreq=gWorkState.s*spindleGrade/10;
                    sdelta=abs(spindleRealSpeed-sreq);
                    sreq=(sreq*(10-rate)/10);
                    if(((SYSparam[46].val<10)||(gWorkState.GG02==GCODE_96))
                        &&(spindleRealSpeed!=0))
                    {
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                        assistenTimer=0;
                    }else if((sdelta<=sreq)
                        ||((sreq==0)&&(spindleRealSpeed<50)))
                    {
                    	extern U32 errspeed;
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                        DEBUGMSG(4,"spindle stable at %d\n",assistenTimer);
                        errspeed=assistenTimer;
                        assistenTimer=0;
                    }else{
                        //wait more time;
                        //static U32 delay=2000;
                        //curTime=OSGetTimeTick();
                        //if((curTime-assistenTimer)>10000) SPIN_RUN_TIME_LIMIT)
                        if(assistenTimer<2)
                        {
                            DEBUGMSG(4,"spindle unstable stop\n",spindleRealSpeed);
                            //gexecState=GEXEC_EXERR;
                            assistStart=FALSE;
                            assistenFlag=FALSE;
                            assistenTimer=0;
                            ALARM_GRP1|=ALM_GRP1_SPIN_FAIL;
                            ////showHint(GERR_OK, SHOW_TIME_FEVER);
                        }else{
                            assistenTimer--;
                            DEBUGMSG(4,"wait spindle stable\n");
                            //return;
                        }
                    }
                }
                break;
            case(GCODE_M05):
                assistStart=FALSE;
                assistenFlag=FALSE;
                break;
            case(GCODE_M08):
                if(coolSign==0)
                {
                    coolSign=1;
                    if(machLockFlag==0)
                    {
                        mfuncBuf[mbufwptr]=MFUNC_COOLON;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }

                break;
            case(GCODE_M09):
                if(coolSign==1)
                {
                    coolSign=0;
                    if(machLockFlag==0)
                    {
                        mfuncBuf[mbufwptr]=MFUNC_COOLOFF;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M10):
                //if(tailSign==0)
                if(gWorkState.tail!=10)
                {
                    tailSign=1;
                    gWorkState.tail=10;
                    if(machLockFlag==0)
                    {
                        mfuncBuf[mbufwptr]=MFUNC_TAILON;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M11):
                //assistStart=FALSE;
                //assistenFlag=FALSE;
                if(gWorkState.tail!=11)
                {
                    tailSign=0;
                    gWorkState.tail=11;
                    if(machLockFlag==0)
                    {
                        mfuncBuf[mbufwptr]=MFUNC_TAILOFF;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M12):
                if(gWorkState.chuck!=12)
                {
                    gWorkState.chuck=12;
                    if(machLockFlag==0)
                    {
                        //PLC_NCCMD_CHUCK_TIRE;
                        mfuncBuf[mbufwptr]=MFUNC_CHUCKON;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{ //it is m12 now
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M13):
                if(gWorkState.chuck!=13)
                {
                    gWorkState.chuck=13;
                    if(machLockFlag==0)
                    {
                        mfuncBuf[mbufwptr]=MFUNC_CHUCKOFF;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{ //it is m13 now
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M19):
                assistStart=FALSE;
                assistenFlag=FALSE;
                break;
            case(GCODE_M32):  //do nothing now
                if(oilSign==0)
                {
                    if(machLockFlag==0)
                    {
                        oilSign=1;
                        mfuncBuf[mbufwptr]=MFUNC_OILON;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M33):
                if(oilSign==1)
                {
                    if(machLockFlag==0)
                    {
                        oilSign=0;
                        mfuncBuf[mbufwptr]=MFUNC_OILOFF;
                        CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                        assistStart=TRUE;
                        autoAssistenPlcRequest=1;
                    }else{
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M41):
            case(GCODE_M42):
            case(GCODE_M43):
            case(GCODE_M44):
                if(machLockFlag==0)
                {
                    gWorkState.m4x = (assistenCode.gnum&0xff00)>>8;
                    IIC_Write1(IICADDR_SPIN_M,gWorkState.m4x);
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            case(GCODE_M65):
                //self defineded m code , p must be 100-199
                if((machLockFlag==0)||(SYSparam[69].val==2))
                {
                    PDGBmfst pt=(PDGBmfst)&assistenCode;
                    mfuncBuf[mbufwptr]=pt->value;
                    CYCLE_BUF_WINC(mbufwptr, MBUF_MAX);
                    assistStart=TRUE;
                    autoAssistenPlcRequest=1;
                }else{
                    assistStart=FALSE;
                    assistenFlag=FALSE;
                }
                break;
            default:
                assistStart=FALSE;
                assistenFlag=FALSE;
                break;
        }
    }
}
/*
*------------------------------------------------------------------------------
* function: coordSetInRun
* parameter: void
* return   : void
* description :  handle G50 coord setting in auto run
*------------------------------------------------------------------------------
*/
void coordSetInRun(void)
{
        PDGBline pline=(PDGBmfst)&assistenCode;
        if(autoBreakPoint.flag>100)
        {
            coordOrginWork.x=autoBreakPoint.coord.x+coordOrginWork.x-pline->x;
            coordWork.x=pline->x;
            autoBreakPoint.coord.x=pline->x;
            coordOrginWork.z=autoBreakPoint.coord.z+coordOrginWork.z-pline->z;
            coordWork.z=pline->z;
            autoBreakPoint.coord.z=pline->z;
            coordOrginWork.y=autoBreakPoint.coord.y+coordOrginWork.y-pline->y;
            coordWork.y=pline->y;
            autoBreakPoint.coord.z=pline->y;
        }else{
            coordOrginWork.x=coordWork.x+coordOrginWork.x-pline->x;
            coordWork.x=pline->x;
            coordOrginWork.z=coordWork.z+coordOrginWork.z-pline->z;
            coordWork.z=pline->z;
            coordOrginWork.y=coordWork.y+coordOrginWork.y-pline->y;
            coordWork.y=pline->y;
        }


        coordOrginWorkG5x[0].x=coordOrginWork.x-coordOrginWorkG5x[gWorkState.GG05].x;
        coordOrginWorkG5x[0].z=coordOrginWork.z-coordOrginWorkG5x[gWorkState.GG05].z;
        coordOrginWorkG5x[0].y=coordOrginWork.y-coordOrginWorkG5x[gWorkState.GG05].y;
        if(machLockFlag==FALSE)
        {
            IIC_Write4(IICADDR_G5X_X, coordOrginWorkG5x[0].x);
            IIC_Write4(IICADDR_G5X_Z, coordOrginWorkG5x[0].z);
            IIC_Write4(IICADDR_G5X_Y, coordOrginWorkG5x[0].y);
            //record the current mach value as program orgin
            IIC_Write4(IICADDR_PROGX,coordWork.x+coordOrginWork.x+coordShiftWork.x);
            IIC_Write4(IICADDR_PROGZ,coordWork.z+coordOrginWork.z+coordShiftWork.z);
            IIC_Write4(IICADDR_PROGY,coordWork.y+coordOrginWork.y+coordShiftWork.y);
        }
        //use bo cmd to send it to dsp
        //DSPState&=(~BIT_LOCA_OVER);
        toolReposition=2;
        taskEventBuf[taskEventCount++]=TEVENT_COORDOFFSET;
        //coordWork.x=coordCurGendMach.x-coordOrginWork.x-coordShiftWork.x;
        //coordWork.z=coordCurGendMach.z-coordOrginWork.z-coordShiftWork.z;
        coordSPCGend=coordWork;
        coordCurGend=coordWork;
        coordSentedGend=coordWork;
        coordCurGstart=coordWork;
        // this may be bug
        //coordCurGendMach=coordMACH;

        //assistenFlag=FALSE;
}
/*
*------------------------------------------------------------------------------
* function: chunkChange
* parameter: void
* return   : void
* description :  chuck state change
*------------------------------------------------------------------------------
* /
void chuckChange(void)
{
    static U32 chucktimer;
    static U8 chuckRequire=13;
    if(chuckchange==0)
        return;
    if(chuckchanging==0)
    {
        if(gWorkState.chuck==12)
        {
            PLC_NCCMD_CHUCK_LOOSE;
            //PLC_NCCMD_M_ON;
            chuckRequire=13;
        }else{
            PLC_NCCMD_CHUCK_TIRE;
            //PLC_NCCMD_M_ON;
            chuckRequire=12;
        }
        chucktimer=1000;
        chuckchanging= 1;
    }else{
        if(chucktimer>0)
        {
            if(PLC_STAT_MFUN_FIN)
            {
                //PLC_NCCMD_M_OFF;
                if((chuckRequire==12)&&(!PLC_SIG_CHUCK_LOOSE))
                {
                    gWorkState.chuck=12;
                }else if((chuckRequire==13)&&(PLC_SIG_CHUCK_LOOSE))
                {
                    gWorkState.chuck=13;
                }
                chuckchange=0;
                chuckchanging=0;
                chucktimer=0;
            }else
                chucktimer--;
        }else{
            //fail to tire or lose the chuck
            ALARM_GRP1|=ALM_GRP1_MCODE_RUN;
            if(PLC_SIG_CHUCK_LOOSE)
            {
                gWorkState.chuck=13;
            }else
                gWorkState.chuck=12;
        }
    }
}
/ *
*------------------------------------------------------------------------------
* function: TOOLstand
* parameter: void
* return   : void
* description :  handle tool change
*------------------------------------------------------------------------------
*/
void TOOLstand(void)
{
    //static U8 delay;
    U8 toolnum;
    if(Toolchange == 0)
        return;

    //if(((SYSparam[170].val==1))//||//swiss style mach
       // ((nextTool/100)==(curTool/100)))  //just offset change
    //    ||(machLockFlag==1)) //simulating
    {
        //gWorkState.t=nextTool;
        ToolChangeHandle();
        toolChangingFlag=0;
        Toolchange=0;
        return;
    }
    #if 0
    if((curTool==nextTool)&&(SYSparam[170].val==1))
    {
        assistenFlag=FALSE;
        assistStart=FALSE;
        toolChangingFlag=0;
        Toolchange=0;
        return;
    }
    if(SYSparam[170].val>1)
    {
        //call plc to finish the mach action
        toolnum=nextTool/100;
        if(toolChangingFlag==0)
        {
            /*
            if(PLC_SIG_TOOL_EQUAL(toolnum))
            {
                ToolChangeHandle();
                assistStart=FALSE;
                assistenFlag=FALSE;
                toolChangingFlag=0;
                Toolchange=0;
            }else{
                toolChangingFlag=1;
                toolChangeTimer=10000;
                PLC_NCTOOL_NUM(toolnum);
                PLC_NCCMD_TCHANGE;
            }*/
            toolChangingFlag=1;
            toolChangeTimer=10000;
            PLC_NCTOOL_NUM(toolnum);
            PLC_NCCMD_TCHANGE;
        }else{

            if(toolChangingFlag==1)
            {
                if(PLC_SIG_TOOL_CHANGING)
                {
                    toolChangingFlag=2;
                    //PLC_NCCMD_TCSTOP;
                }
                toolChangeTimer--;
                if(toolChangeTimer<1900)
                {
                    toolChangingFlag=2;
                    //PLC_NCCMD_TCSTOP;
                }
            }else if (toolChangingFlag==2)
            {
                if(PLC_SIG_TOOL_CHANGING)
                {
                    toolChangeTimer--;
                    if(toolChangeTimer==0)
                    {   //alarm
                        ALARM_GRP1|=ALM_GRP1_TOOL_FAIL;
                        //PLC_NCCMD_TCSTOP;
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                        toolChangingFlag=0;
                        Toolchange=0;
                    }
                }else{
                    if(PLC_SIG_TOOL_EQUAL(toolnum))
                    {
                        ToolChangeHandle();
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }else{
                        ALARM_GRP1|=ALM_GRP1_TOOL_FAIL;
                        //PLC_NCCMD_TCSTOP;
                        assistStart=FALSE;
                        assistenFlag=FALSE;
                    }
                    toolChangingFlag=0;
                    Toolchange=0;
                }
            }
        }
    }
    #endif
}
/*
*------------------------------------------------------------------------------
* function: ToolChangeHandle
* parameter: void
* return   : void
* description :  handle IO input or output, do io related job
*------------------------------------------------------------------------------
*/
void ToolChangeHandle()
{
    U32 curTime;
    U8 index=0;
    /*
    if(curTool==nextTool)
    {
        assistenFlag=FALSE;
        return;
    }*/
    switch(SYSparam[170].val)
    {
        case(1):
            break;
        default: //wait tool change mach done
            /*curTime=OSGetTimeTick();
            if(abs(curTime-assistenTimer)>TOOL_CHANGE_TIME_LIMIT)
            {
                goto SET_TOOLSHIFT;
            }else{
                return;
            } */
            break;
    }
SET_TOOLSHIFT:
    curTool=nextTool;
    index=curTool%100;
    gWorkState.t=curTool;
    if(machLockFlag==FALSE)
        IIC_Write4(IICADDR_TOOL, curTool);
    //change the work coord origin
    coordShiftWork.x=toolCompensation[index].x;
    coordShiftWork.y=toolCompensation[index].y;
    coordShiftWork.z=toolCompensation[index].z;
    assistenFlag=FALSE;
    assistStart=FALSE;

    if(sysMode==SYS_MODE_AUTO)
    {
        //DSPState&=(~BIT_LOCA_OVER);
        toolReposition=1;
        taskEventBuf[taskEventCount++]=TEVENT_COORDOFFSET;
        //coordWork.x=coordMACH.x-coordOrginWork.x-coordShiftWork.x;
        //coordWork.z=coordMACH.z-coordOrginWork.z-coordShiftWork.z;
        coordWork.x=coordCurGendMach.x-coordOrginWork.x-coordShiftWork.x;
        coordWork.y=coordCurGendMach.y-coordOrginWork.y-coordShiftWork.y;
        coordWork.z=coordCurGendMach.z-coordOrginWork.z-coordShiftWork.z;
        coordSPCGend=coordWork;
        coordCurGend=coordWork;
        coordCurGstart=coordWork;
        //coordCurGendMach=coordMACH;
        coordSentedGend=coordWork;

    }else if(sysMode==SYS_MODE_JOG)
    {
        taskEventBuf[taskEventCount++]=TEVENT_MOD_JOG;
        SPCruncount=0;
        SPCsendcount=0;
    }else if(sysMode==SYS_MODE_WHEEL)
    {
        taskEventBuf[taskEventCount++]=TEVENT_MOD_WHELL;
        SPCruncount=0;
        SPCsendcount=0;
    }else{
        coordWork.x=coordMACH.x-coordOrginWork.x-coordShiftWork.x;
        coordWork.y=coordMACH.y-coordOrginWork.y-coordShiftWork.y;
        coordWork.z=coordMACH.z-coordOrginWork.z-coordShiftWork.z;
        coordSPCGend=coordWork;
        coordCurGend=coordWork;
        coordCurGstart=coordWork;
        coordSentedGend=coordWork;
        coordCurGendMach=coordMACH;
    }
}
/*
*------------------------------------------------------------------------------
* function: chuckCtrl
* parameter: chuckCtrl
* return   : void
* description : control the chuck to be tired or loss
*------------------------------------------------------------------------------
* /
void chuckCtrl(void)
{   / *
    if(getIOIN(IOIN_FOOT))
    {
       if((spinRunSign==0)&&(spindleRealSpeed==0))
       {
            //can loss the chuck now
            setIOOUT(IOOUT_CHUCK,TRUE);
       }
    }else{
       setIOOUT(IOOUT_CHUCK,FALSE);
    }* /
    if((spinRunSign==0)&&(spindleRealSpeed==0))
    if(plcG[0]&0X08) //LOOSED
    {

    }
}*/
/*
*------------------------------------------------------------------------------
* function: roundToolCompX
* parameter: x value
* return   : rounded x value
* description :round tool compensation x value to 0.5 u or 1u
*------------------------------------------------------------------------------
*/
S32 roundToolCompX(S32 xvalue)
{
    S32 val1,val2;
    S32 tail=xvalue%10;
    S32 abstail;
    if(tail==0)
        return xvalue;
    if(xvalue>=0)
    {
        val1=5;
        val2=10;
        abstail=tail;
    }else{
        val1=-5;
        val2=-10;
        abstail=0-tail;
    }
    if(dimMode==MODE_DIM)
    {
        if(abstail<4)
            xvalue=xvalue-tail;
        else if(abstail<8)
            xvalue=xvalue-tail+val1;
        else
            xvalue=xvalue-tail+val2;
            /*
        if(abstail<5)
            xvalue=xvalue-tail;
        else
            xvalue=xvalue-tail+val2;  */
    }else{
        if(abstail<5)
            xvalue=xvalue-tail;
        else
            xvalue=xvalue-tail+val2;
    }
    return xvalue;
}
/*
*------------------------------------------------------------------------------
* function: roundToolCompZ
* parameter: Z value
* return   : rounded z value
* description :round tool compensation z value to 1u
*------------------------------------------------------------------------------
*/
S32 roundToolCompZ(S32 zvalue)
{
    S32 val1;
    S32 tail=zvalue%10;
    S32 abstail;
    if(tail==0)
        return zvalue;
    if(zvalue>=0)
    {
        val1=10;
        abstail=tail;
    }else{
        val1=-10;
        abstail=0-tail;
    }
    if(abstail<5)
        zvalue=zvalue-tail;
    else
        zvalue=zvalue-tail+val1;
    return zvalue;
}
/*
*------------------------------------------------------------------------------
* function: clearToolCompOffset
* parameter: xyz select 0 x 1 Y 2 Z
* return   : void
* description :clear the too compensation offset
*------------------------------------------------------------------------------
*/
void clearToolCompOffset(U8 xz)
{
    if(currentToolCP==0) //tool compent 0 is not use able
        return;
    if(xz==0)
    {
        toolOffset[currentToolCP].x=0;
        toolWear[currentToolCP].x=0;
        toolCompensation[currentToolCP].x=0;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp), toolOffset[currentToolCP].x);
        IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp), toolWear[currentToolCP].x);
    }else if(xz==1)
    {
        toolOffset[currentToolCP].y=0;
        toolWear[currentToolCP].y=0;
        toolCompensation[currentToolCP].y=0;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+4, toolOffset[currentToolCP].y);
        IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+4, toolWear[currentToolCP].y);
    }else if(xz==2)
    {
        toolOffset[currentToolCP].z=0;
        toolWear[currentToolCP].z=0;
        toolCompensation[currentToolCP].z=0;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+8, toolOffset[currentToolCP].z);
        IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+8, toolWear[currentToolCP].z);
    }
    adjCoordShiftAfterToolCompSet();
}
/*
*------------------------------------------------------------------------------
* function: Task2SendCMDGcode
* parameter: real coord value of the current work pieces size, respined tool num
* return   : void
* description :set the offset value of x z in current selected tool compensation
*------------------------------------------------------------------------------
*/
void setToolCompOffset(S32 newVal,U8 xz)
{
    S32 x,y,z;
    if(currentToolCP==0) //tool compent 0 is not use able
    {
        return;//newVal=0; //this is for tool compensation 0 init zero
    }//return;
    //if(!((SYS_STATE_JOG==sysState)||(SYS_STATE_WHEEL==sysState)))
    //{
    //    return;
    //}
    if(xz==AXISX)
    {
        x=newVal;
        if(dimMode==MODE_DIM)
        {
            x=x/2;
        }
        //x=coordWork.x-x;
        x=coordWork.x+coordShiftWork.x-x;
        x=roundToolCompX(x);
        toolCompensation[currentToolCP].x=x;
        toolOffset[currentToolCP].x=x;
        toolWear[currentToolCP].x=0;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp), toolOffset[currentToolCP].x);
        IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp), toolWear[currentToolCP].x);
    }else if(xz==AXISY){
        //z=coordWork.z-newVal;
        y=coordWork.y+coordShiftWork.y-newVal;
        y=roundToolCompZ(y);
        toolCompensation[currentToolCP].y=y;
        toolOffset[currentToolCP].y=y;
        toolWear[currentToolCP].y=0;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+4, toolOffset[currentToolCP].y);
        IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+4, toolWear[currentToolCP].y);
    }else if(xz==AXISZ){
        //z=coordWork.z-newVal;
        z=coordWork.z+coordShiftWork.z-newVal;
        z=roundToolCompZ(z);
        toolCompensation[currentToolCP].z=z;
        toolOffset[currentToolCP].z=z;
        toolWear[currentToolCP].z=0;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+8, toolOffset[currentToolCP].z);
        IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+8, toolWear[currentToolCP].z);
    }
    adjCoordShiftAfterToolCompSet();
}
/*
*------------------------------------------------------------------------------
* function: setToolCompOffsetSpot
* parameter: real coord value of the current work pieces size, respined tool num
* return   : void
* description :set the offset value of x z in current selected tool compensation
* using related coord u or w value
*------------------------------------------------------------------------------
* /
void setToolCompOffsetSpot(U8 xz)
{
    S32 x,z;
    if(currentToolCP==0) //tool compent 0 is not use able
        return;

    if(xz==AXISX)
    {
        x=coordRelate.x;
        toolCompensation[currentToolCP].x=x;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp), toolCompensation[currentToolCP].x);
    }else if(xz==AXISZ)
    {
        z=coordRelate.z;
        toolCompensation[currentToolCP].z=z;
        IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+4, toolCompensation[currentToolCP].z);
    }
    adjCoordShiftAfterToolCompSet();
}
/*
*------------------------------------------------------------------------------
* function: Task2SendCMDGcode
* parameter: real coord value of the current work pieces size, respined tool num
* return   : void
* description :set the offset value of x z in current selected tool compensation
*------------------------------------------------------------------------------
*/
void adjustToolCompOffset(S32 adjval,U8 xz)
{
    U32 index;
    //if((SYS_STATE_AUTO==sysState)||(SYS_STATE_REF==sysState))
    //    return;
    if(currentToolCP==0) //tool compent 0 is not use able
    {
        if((xz!=AXISX)&&(xz!=AXISY)&&(xz!=AXISZ))
            return;
        if((xz==AXISX)&&(dimMode))
        {
            adjval=adjval/2;
        }
        if(xz==AXISX)
            adjval=roundToolCompX(adjval);
        else if(xz==AXISZ||xz==AXISY)
            adjval=roundToolCompZ(adjval);
        //adj all tool comp's value
        for(index=1;index<TOOL_MAX;index++)
        {
            if(xz==AXISX)
            {
                toolOffset[index].x+=adjval;
                toolCompensation[index].x=toolOffset[index].x+toolWear[index].x;
                IIC_Write4(IICADDR_TOOLCOMP+index*sizeof(TtoolComp), toolOffset[index].x);
            }else if(xz==AXISY){
                toolOffset[index].y+=adjval;
                toolCompensation[index].y=toolOffset[index].y+toolWear[index].y;
                IIC_Write4(IICADDR_TOOLCOMP+index*sizeof(TtoolComp)+4, toolOffset[index].y);
            }else if(xz==AXISZ){
                toolOffset[index].z+=adjval;
                toolCompensation[index].z=toolOffset[index].z+toolWear[index].z;
                IIC_Write4(IICADDR_TOOLCOMP+index*sizeof(TtoolComp)+8, toolOffset[index].z);
            }
        }
        currentToolCP=curTool%100;
        adjCoordShiftAfterToolCompSet();
        currentToolCP=0;
    }else{
        //    return;
        if(xz==AXISX)
        {
            if(dimMode)
            {
                adjval=adjval/2;
            }
            adjval=roundToolCompX(adjval);
            toolOffset[currentToolCP].x+=adjval;
            toolCompensation[currentToolCP].x=toolOffset[currentToolCP].x+toolWear[currentToolCP].x;
            IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp), toolOffset[currentToolCP].x);
        }else if(xz==AXISY){
            adjval=roundToolCompZ(adjval);
            toolOffset[currentToolCP].y+=adjval;
            toolCompensation[currentToolCP].y=toolOffset[currentToolCP].y+toolWear[currentToolCP].y;
            IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+4, toolOffset[currentToolCP].y);
        }else if(xz==AXISZ){
            adjval=roundToolCompZ(adjval);
            toolOffset[currentToolCP].z+=adjval;
            toolCompensation[currentToolCP].z=toolOffset[currentToolCP].z+toolWear[currentToolCP].z;
            IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+8, toolOffset[currentToolCP].z);
        }else if(xz==AXISWX)
        {

            if(dimMode)
            {
                adjval=adjval/2;
            }
                /*
                if(SYSparam[95].val==2)
                {
                    if(abs(adjval+toolWear[currentToolCP].x)>10000)
                        return;
                }
            }else{
                if(SYSparam[95].val==2)
                {
                    if(abs(adjval+toolWear[currentToolCP].x)>20000)
                        return;
                }
            }*/
            adjval=roundToolCompX(adjval);
            toolWear[currentToolCP].x+=adjval;
            toolCompensation[currentToolCP].x=toolOffset[currentToolCP].x+toolWear[currentToolCP].x;
            IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp), toolWear[currentToolCP].x);
        }else if(xz==AXISWY)
        {
            adjval=roundToolCompZ(adjval);
            toolWear[currentToolCP].y+=adjval;
            toolCompensation[currentToolCP].y=toolOffset[currentToolCP].y+toolWear[currentToolCP].y;
            IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+4, toolWear[currentToolCP].y);
        }else if(xz==AXISWZ)
        {/*
            if(SYSparam[95].val==2)
            {
                if(abs(adjval+toolWear[currentToolCP].z)>20000)
                    return;
            }*/
            adjval=roundToolCompZ(adjval);
            toolWear[currentToolCP].z+=adjval;
            toolCompensation[currentToolCP].z=toolOffset[currentToolCP].z+toolWear[currentToolCP].z;
            IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+8, toolWear[currentToolCP].z);
        }
        adjCoordShiftAfterToolCompSet();
    }
}
/*
*------------------------------------------------------------------------------
* function: adjCoordShiftAfterToolCompSet
* parameter: real coord value of the current work pieces size, respined tool num
* return   : void
* description :make a fait tool change process to update the tool offset to
*    current coord value;
*------------------------------------------------------------------------------
*/
void adjCoordShiftAfterToolCompSet()
{
    U8 usingTCP;
    U16 nextTool;
    usingTCP=curTool%100;
    if(usingTCP==0)
        return;
    if(currentToolCP!=usingTCP)
        return;
    if(GEXEC_STATE_RUNING)
        return;
    //adjust coord shift if current tool compensation is change
    nextTool=curTool;
    curTool=curTool-usingTCP;

    ToolChangeHandle();
}
/*
*------------------------------------------------------------------------------
* function: Task2SendCMDGcode
* parameter: real coord value of the current work pieces size, respined tool num
* return   : void
* description :set the offset value of x z in current selected tool compensation
*------------------------------------------------------------------------------
*/
void setToolCompR(S32 r)
{
    if(currentToolCP==0) //tool compent 0 is not use able
        return;
    r=roundToolCompZ(r);
    toolOffset[currentToolCP].r=r;
    toolCompensation[currentToolCP].r=r;
    toolWear[currentToolCP].r=0;
    IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+12, toolOffset[currentToolCP].r);
    IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+12, toolWear[currentToolCP].r);
}

void adjToolCompR(S32 r)
{
    if(currentToolCP==0) //tool compent 0 is not use able
        return;
    r=roundToolCompZ(r);
    toolOffset[currentToolCP].r+=r;
    toolCompensation[currentToolCP].r=toolOffset[currentToolCP].r+toolWear[currentToolCP].r;
    IIC_Write4(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+12, toolOffset[currentToolCP].r);
}

void adjToolCompWR(S32 r)
{
    if(currentToolCP==0) //tool compent 0 is not use able
        return;
    r=roundToolCompZ(r);
    toolWear[currentToolCP].r+=r;
    toolCompensation[currentToolCP].r=toolOffset[currentToolCP].r+toolWear[currentToolCP].r;
    IIC_Write4(IICADDR_TOOLWEAR+currentToolCP*sizeof(TtoolComp)+12, toolWear[currentToolCP].r);
}
void setToolCompTdir(U8 dir)
{
    if(currentToolCP==0) //tool compent 0 is not use able
        return;
    if(dir>9)
        return;
    toolOffset[currentToolCP].tdir=dir;
    toolCompensation[currentToolCP].tdir=dir;
    IIC_Write1(IICADDR_TOOLCOMP+currentToolCP*sizeof(TtoolComp)+16, toolOffset[currentToolCP].tdir);
}
/*
*------------------------------------------------------------------------------
* function: setCoordRefp
* parameter: new coord value; offset index to set
* return   : void
* description :set the coord offset value
*------------------------------------------------------------------------------
*/
void setCoordRefp(S32 newval, U8 xz)
{
    U8 index=currentRef;
    if(index>=REFP_MAX)
    {
        return;
    }
    if(xz==AXISX)
    {
        if(dimMode)
        {
            newval=newval/2;
        }
        coordRef[index].x=newval;
        IIC_Write4(IICADDR_REFP+currentRef*8, coordRef[index].x);
    }else if(xz==AXISY)
    {
        coordRef[index].y=newval;
        IIC_Write4(IICADDR_REFP+currentRef*8+4, coordRef[index].y);
    }else if(xz==AXISZ)
    {
        coordRef[index].z=newval;
        IIC_Write4(IICADDR_REFP+currentRef*8+8, coordRef[index].z);
    }
}
/*
*------------------------------------------------------------------------------
* function: setCoordRefpSpot
* parameter: new coord value; offset index to set
* return   : void
* description :set the coord ref point with current mach coord
*------------------------------------------------------------------------------
*/
void setCoordRefpSpot( U8 xz)
{
    U8 index=currentRef;
    if(index>=REFP_MAX)
    {
        return;
    }
    if(xz==AXISX)
    {
        coordRef[index].x=coordMACH.x;
        IIC_Write4(IICADDR_REFP+currentRef*8, coordRef[index].x);
    }else if(xz==AXISY)
    {
        coordRef[index].y=coordMACH.y;
        IIC_Write4(IICADDR_REFP+currentRef*8+4, coordRef[index].y);
    }else if(xz==AXISZ)
    {
        coordRef[index].z=coordMACH.z;
        IIC_Write4(IICADDR_REFP+currentRef*8+8, coordRef[index].z);
    }
}
/*
*------------------------------------------------------------------------------
* function: setGlobalVar
* parameter: var new value, var index to set
* return   : void
* description :set the global var value
*------------------------------------------------------------------------------
*/
void setGlobalVar(F64 val)
{
    U16 index=currentVar;
    if(index>(GLOBAL_VAR_MAX-1))
    {
        return;
    }
    globalVar[index]=val;
    if(index>=200)
        //IIC_Write8(IICADDR_GVARS+(index-200)*8,val);
        IIC_Write(IICADDR_GVARS+(index-200)*8, &val,8);

}
/*
*------------------------------------------------------------------------------
* function: Task2SendCMDGcode
* parameter: void
* return   : void
* description : send out the g code than user input in cmd line
*   it accept one g code and mfst before it;
*------------------------------------------------------------------------------
*/
void SendSTDGcode(void)
{
    U16 i;
    
    //U8* codect;  
    PDGBline  glineptr;
    PDGBarc   garcptr,dgptr;
    PDGBmfst   fstptr;
    PDGBmfst mptr;
    //chechk if we can start trans now and have some code to send
    if((!(DSPState&BIT_STDGEN))||(CYCLE_BUF_EMPTY(DGwptr, DGrptr)))
        return;
    if(assistenFlag==TRUE)
        return;
    if(shm_cycBufFreeCount(CYCBUF_GCODE)<20)
        return;
    //send one bunch of g code to dsp
    for(i=0;i<5;i++)
    {
        //check if we got some code to send
        if(CYCLE_BUF_EMPTY(DGwptr, DGrptr))
        {
            if(gexecState==GEXEC_TOOLCE)
            {
               gexecState=GEXEC_SENDE;
            }
            goto ADD_TAIL;
        }
        //if break point is reached,handle it's state first
        if((autoBreakPoint.flag>0)&&(autoBreakPoint.flag<100))
        {
            //if(autoBreakPoint.flag<100)
            //{
                if(autoBreakPoint.sendCount==0)
                {   //if bp is the first code,send nothing
                    autoBreakPoint.flag=0;
                }else{
                    sendBreakPointState();
                    if(assistenFlag==TRUE)
                        break;
                    else
                        continue; //do not
                }
            //}
        }
        dgptr=&DGbuf[DGrptr];
        switch (dgptr->gnum)
        {
            case (GCODE_M00):
            case (GCODE_M03):
            case (GCODE_M04):
            case (GCODE_M05):
            //case (GCODE_M06):
            //case (GCODE_M07):
            case (GCODE_M08):
            case (GCODE_M09):
            case (GCODE_M10):
            case (GCODE_M11):
            case (GCODE_M12):
            case (GCODE_M13):
            case (GCODE_M19):
            case (GCODE_M30):
		    case (GCODE_M32):
			case (GCODE_M33):
            case (GCODE_M41):
            case (GCODE_M42):
            case (GCODE_M43):
            case (GCODE_M44):
			case (GCODE_20):
			case (GCODE_21):
            case (GCODE_40):
            case (GCODE_41):
            case (GCODE_42):
            case (GCODE_M254):
            case (GCODE_M255): 
                mptr=(PDGBmfst)dgptr;
                if(autoBreakPoint.flag>0)
                { //send fait code to replace it
                    if((autoBreakPoint.flag==101)
                        &&(mptr->srcLine==autoBreakPoint.tag))
                    {
                        autoBreakPoint.flag=6;
                        //autoBreakPoint.sendCount=mptr->sendCount;
                        autoBreakPoint.srcLine=mptr->srcLine;
                        autoBreakPoint.srcCode=mptr->srcCode;
                        break;
                    }else{
                        switch(mptr->gnum)
                        {
                            case (GCODE_M03):
                            case (GCODE_M04):
                            case (GCODE_M05): //store s state
                                autoBreakPoint.m345=mptr->gnum;
                                break;
                            case (GCODE_M08):
                            case (GCODE_M09):
                                autoBreakPoint.m89=mptr->gnum;
                                break;
                            case (GCODE_M12):
                            case (GCODE_M13): //stroe chuck state
                                autoBreakPoint.m1213=mptr->gnum;
                                break;
                            case (GCODE_M41):
                            case (GCODE_M42):
                            case (GCODE_M43):
                            case (GCODE_M44):
                                autoBreakPoint.m4x=mptr->gnum;
                                break;
                            default:
                                break;
                        }
                        sendFaitCode(mptr->sendCount);
                        CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                        break;
                    }
                }
                if(((dgptr->gnum>=GCODE_M00)&&(dgptr->gnum<=GCODE_M19))||
				  (dgptr->gnum==GCODE_M32)	||(dgptr->gnum==GCODE_M33))
                {
                    assistenFlag=TRUE;
                    assistenCode=*dgptr;
                }
                if((dgptr->gnum>=GCODE_M41)&&(dgptr->gnum<=GCODE_M44))
                {
                    assistenFlag=TRUE;
                    assistenCode=*dgptr;
                    if(machLockFlag==1)
                    {//machlock do not send m41-m44
                        mptr->gnum=GCODE_M08;
                    }
                } 
                //mptr->len=sizeof(TDGmfst);
                mptr->realSendCount=++STDrealsendcount;
                coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
                //memcpy(&(arm2dspPKG[len]),mptr,mptr->len);
                shm_cycBufWrite(CYCBUF_GCODE, (U32*)mptr,(sizeof(TDGmfst)>>2));
                
                //back up to sended code
                sendedBuf[SENDEDwptr].gnum=mptr->gnum;
                sendedBuf[SENDEDwptr].sendCount=mptr->realSendCount;//mptr->sendCount;
                sendedBuf[SENDEDwptr].srcLine=mptr->srcLine;
                sendedBuf[SENDEDwptr].srcCode=mptr->srcCode;
                CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
                DEBUGMSG(4,"M:%x, senccount %d, realsendcount %d \n",
                    mptr->gnum,mptr->sendCount,mptr->realSendCount);
                //len=len+mptr->len;
                //(*codect)++;
                CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                if(dgptr->gnum==GCODE_M30)
                	gexecState=GEXEC_SENDE;
                break;
            case (GCODE_F):
            case (GCODE_S):
            case(GCODE_SCREW):
            case (GCODE_T):
            case (GCODE_04):
            case (GCODE_M50):
            case (GCODE_M65):
            case (GCODE_96):
            case (GCODE_97):
            case (GCODE_98):
            case (GCODE_99):
            case (GCODE_M253):
            case (GCODE_54):
                fstptr=(PDGBmfst)dgptr;                
                if(autoBreakPoint.flag>0)
                { //send fait code to replace it
                    if((autoBreakPoint.flag==101)
                        &&(fstptr->srcLine==autoBreakPoint.tag))
                    {
                        if(fstptr->gnum==GCODE_T)
                        {
                            U32 toolcpOld,toolcpNew;
                            //cal the new coord of tool
                            toolcpNew=fstptr->value%100;
                            toolcpOld=autoBreakPoint.t%100;
                            autoBreakPoint.coord.x+=
                                (toolCompensation[toolcpOld].x-toolCompensation[toolcpNew].x);
                            autoBreakPoint.coord.z+=
                                (toolCompensation[toolcpOld].z-toolCompensation[toolcpNew].z);
                            autoBreakPoint.coord.y+=
                                (toolCompensation[toolcpOld].y-toolCompensation[toolcpNew].y);
                            autoBreakPoint.t=fstptr->value;
                        }
                        autoBreakPoint.flag=6;
                        autoBreakPoint.srcLine=fstptr->srcLine;
                        autoBreakPoint.srcCode=fstptr->srcCode;
                        break;
                    }else if((autoBreakPoint.flag==102)
                        &&((fstptr->gnum==GCODE_T)&&(autoBreakPoint.tag==(fstptr->value))))
                    {  //is a t tag
                        U32 toolcpOld,toolcpNew;
                        //cal the new coord of tool
                        toolcpNew=fstptr->value%100;
                        toolcpOld=autoBreakPoint.t%100;
                        autoBreakPoint.coord.x+=
                            (toolCompensation[toolcpOld].x-toolCompensation[toolcpNew].x);
                        autoBreakPoint.coord.z+=
                            (toolCompensation[toolcpOld].z-toolCompensation[toolcpNew].z);
                        autoBreakPoint.coord.y+=
                            (toolCompensation[toolcpOld].y-toolCompensation[toolcpNew].y);
                        autoBreakPoint.t=fstptr->value;
                        autoBreakPoint.flag=6;
                        autoBreakPoint.srcLine=fstptr->srcLine;
                        autoBreakPoint.srcCode=fstptr->srcCode;
                        break;
                    }else{
                        //if((fstptr->gnum!=GCODE_F)&&(fstptr->gnum!=GCODE_S))
                        if((fstptr->gnum==GCODE_T)
                            ||(fstptr->gnum==GCODE_04)
                            ||(fstptr->gnum==GCODE_M253))
                        {
                            if(fstptr->gnum==GCODE_T)//save tool value
                            {
                                U32 toolcpOld,toolcpNew;
                                //cal the new coord of tool
                                toolcpNew=fstptr->value%100;
                                toolcpOld=autoBreakPoint.t%100;
                                autoBreakPoint.coord.x+=
                                    (toolCompensation[toolcpOld].x-toolCompensation[toolcpNew].x);
                                autoBreakPoint.coord.z+=
                                    (toolCompensation[toolcpOld].z-toolCompensation[toolcpNew].z);
                                autoBreakPoint.coord.y+=
                                    (toolCompensation[toolcpOld].y-toolCompensation[toolcpNew].y);
                                autoBreakPoint.t=fstptr->value;
                            }
                            sendFaitCode(fstptr->sendCount);
                            CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                            break;
                        }else if (fstptr->gnum==GCODE_F)
                        {
                            autoBreakPoint.fvalue=fstptr->value;
                        }
                    }
                }
                if((dgptr->gnum==GCODE_T)||
                    (dgptr->gnum==GCODE_S)||
                    (dgptr->gnum==GCODE_M65)||
                    (dgptr->gnum==GCODE_54))
                {
                    //we handle t code after it is send;
                    assistenFlag=TRUE;
                    assistenCode=*dgptr;
                }
                if((dgptr->gnum==GCODE_98)||(dgptr->gnum==GCODE_99))
                {
                    sendedG9899=dgptr->gnum;
                    IIC_Write1(IICADDR_G98G99,sendedG9899);
                }
                if((dgptr->gnum==GCODE_96)||(dgptr->gnum==GCODE_97))
                {
                    sendedG9697=dgptr->gnum;
                    if(dgptr->gnum==GCODE_96)
                        gWorkState.slinespeed=fstptr->value;
                }

                //fstptr=(PDGBfst)dgptr;
                //fstptr->len=sizeof(TDGmfst);
                fstptr->realSendCount=++STDrealsendcount;
                coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
                //memcpy(&(arm2dspPKG[len]),fstptr,fstptr->len);
                shm_cycBufWrite(CYCBUF_GCODE, (U32*)fstptr, (sizeof(TDGmfst)>>2));
                sendedBuf[SENDEDwptr].gnum=fstptr->gnum;
                sendedBuf[SENDEDwptr].sendCount=fstptr->realSendCount;
                if(autoBreakPoint.flag>100)
                    autoBreakPoint.sendCount=fstptr->sendCount;
                sendedBuf[SENDEDwptr].x=fstptr->value;
                if((fstptr->gnum==GCODE_F)&&(fstptr->value!=0))
                {
                    gWorkState.fseted=1;
                }
                sendedBuf[SENDEDwptr].srcLine=fstptr->srcLine;
                sendedBuf[SENDEDwptr].srcCode=fstptr->srcCode;
                CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
                DEBUGMSG(4,"FST:0x%X, val %d, sendcount %d, realsendcount %d\n",
                    fstptr->gnum,fstptr->value,fstptr->sendCount,fstptr->realSendCount);
                //len=len+fstptr->len;
                //(*codect)++;
                CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                break;
            case (GCODE_00):
            case (GCODE_01):
            case (GCODE_50):
                glineptr=(PDGBline)dgptr;
                if(autoBreakPoint.flag>0)
                { //send fait code to replace it
                    if((autoBreakPoint.flag==101)
                        &&(glineptr->srcLine==autoBreakPoint.tag))
                    {
                        autoBreakPoint.flag=6;
                        //autoBreakPoint.sendCount=glineptr->sendCount;
                        autoBreakPoint.srcLine=glineptr->srcLine;
                        autoBreakPoint.srcCode=glineptr->srcCode;
                        break;
                    }else{
                        if(glineptr->gnum!=GCODE_50)
                        {
                            autoBreakPoint.coord.x=glineptr->x;
                            autoBreakPoint.coord.z=glineptr->z;
                            autoBreakPoint.coord.y=glineptr->y;
                            sendFaitCode(glineptr->sendCount);
                            CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                            break;
                        } //g50's offset my be cal in coordsetInrun function
                    }
                }
                if(glineptr->gnum==GCODE_50)
                {
                    //U16 index,index1;
                    assistenFlag=TRUE;
                    assistenCode=*dgptr;
                }else
                {
                    coordSentedGend.x=glineptr->x;
                    coordSentedGend.z=glineptr->z;
                    coordSentedGend.y=glineptr->y;
                }
                //check f is ok
                if(dgptr->gnum==GCODE_01)
                {
                    if((gWorkState.fseted==0)||
                    ((sendedG9899==GCODE_99)&&(sendedG9697==GCODE_97)&&
                        ((gWorkState.s==0)||(gWorkState.sdir==5)))||
                    ((sendedG9697==GCODE_96)&&
                        ((gWorkState.slinespeed==0)||(gWorkState.sdir==5)))
                    ){
                        gexecError=GERR_NOFEED_G1;
                        gexecState=GEXEC_EXERR;
                        gexecErrInsend=TRUE;
                        break;
                    }
                }
                //glineptr->len=sizeof(TDGline);
                glineptr->realSendCount=++STDrealsendcount;
                coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
                //SYSLOG(LOGTYPE_DEBUG,LOGSRC_ARM,0,"line %d,x%d,z%d,sendcount %d, realsenccount %d\n",
                DEBUGMSG(4,"DGbuf line %d,x%d,z%d,sendcount %d, realsenccount %d\n",
                    glineptr->gnum,glineptr->x,glineptr->z,
                    glineptr->sendCount,glineptr->realSendCount);
                //memcpy(&(arm2dspPKG[len]),glineptr,glineptr->len);
                shm_cycBufWrite(CYCBUF_GCODE, (U32*)glineptr, (sizeof(TDGline)>>2));
                sendedBuf[SENDEDwptr].gnum=glineptr->gnum;
                sendedBuf[SENDEDwptr].sendCount=glineptr->realSendCount;
                if(autoBreakPoint.flag>100)
                    autoBreakPoint.sendCount=glineptr->sendCount;
                sendedBuf[SENDEDwptr].srcLine=glineptr->srcLine;
                sendedBuf[SENDEDwptr].srcCode=glineptr->srcCode;
                sendedBuf[SENDEDwptr].x=glineptr->x;
                sendedBuf[SENDEDwptr].z=glineptr->z;
                sendedBuf[SENDEDwptr].y=glineptr->y;
                CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
                //len=len+glineptr->len;
                //(*codect)++;
                CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                break;
            case (GCODE_02):
            case (GCODE_03):
                garcptr=(PDGBarc)dgptr;
                if(autoBreakPoint.flag>0)
                { //send fait code to replace it
                    if((autoBreakPoint.flag==101)
                        &&(garcptr->srcLine==autoBreakPoint.tag))
                    {
                        autoBreakPoint.flag=6;
                        //autoBreakPoint.sendCount=garcptr->sendCount;
                        autoBreakPoint.srcLine=garcptr->srcLine;
                        autoBreakPoint.srcCode=garcptr->srcCode;
                        break;
                    }else{
                        autoBreakPoint.coord.x=garcptr->x;
                        autoBreakPoint.coord.z=garcptr->z;
                        sendFaitCode(garcptr->sendCount);
                        CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                        break;
                    }
                }
                if(garcptr->s==garcptr->enagle) //filter
                {
                    CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                    break;
                }
                //check f is ok
                if((gWorkState.fseted==0)||
                ((sendedG9899==GCODE_99)&&(sendedG9697==GCODE_97)&&
                    ((gWorkState.s==0)||(gWorkState.sdir==5)))||
                ((sendedG9697==GCODE_96)&&
                    ((gWorkState.slinespeed==0)||(gWorkState.sdir==5)))
                ){
                    gexecError=GERR_NOFEED_G1;
                    gexecState=GEXEC_EXERR;
                    gexecErrInsend=TRUE;
                    break;
                }
                coordSentedGend.x=garcptr->x;
                coordSentedGend.z=garcptr->z;
                //garcptr->len=sizeof(TDGarc);
                garcptr->realSendCount=++STDrealsendcount;
                coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
                //memcpy(&(arm2dspPKG[len]),garcptr,garcptr->len);
                shm_cycBufWrite(CYCBUF_GCODE, (U32*)garcptr, (sizeof(TDGarc)>>2));
                sendedBuf[SENDEDwptr].gnum=garcptr->gnum;
                sendedBuf[SENDEDwptr].sendCount=garcptr->realSendCount;
                sendedBuf[SENDEDwptr].srcLine=garcptr->srcLine;
                sendedBuf[SENDEDwptr].srcCode=garcptr->srcCode;
                sendedBuf[SENDEDwptr].x=garcptr->x;
                sendedBuf[SENDEDwptr].z=garcptr->z;
                CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
                DEBUGMSG(4,"DGbuf arc %d,x%d,z%d,i%d,k%d,r%d,s%d,e%d,send count %d, realsendcount %d\n",
                    garcptr->gnum,garcptr->x,garcptr->z,garcptr->i,garcptr->k,garcptr->r,
                    garcptr->s,garcptr->e,garcptr->sendCount,garcptr->realSendCount);
                //len=len+garcptr->len;
                //(*codect)++;
                CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
                break;
            default:
                //ALARM_GRP1|=ALM_GRP1_GCODE_UNDEF;
                gexecError=GERR_G_UNKOWN;
                gexecState=GEXEC_EXERR;
                gexecErrInsend=TRUE;
                DEBUGMSG(4,"G code unkonw in DG buffer: %x\n", dgptr->gnum);
                break;
        }
        //CYCLE_BUF_RINC(TCGrptr, TCG_BUF_MAX );
        //CYCLE_BUF_RINC(DGrptr, DG_BUF_MAX);
        if(assistenFlag==TRUE)
            break; //if T code is set package done;
        if(gexecState==GEXEC_EXERR)
            break;
    }
    if(CYCLE_BUF_EMPTY(DGwptr, DGrptr))
    {
        if(gexecState==GEXEC_TOOLCE)
        {
            gexecState=GEXEC_SENDE;
        }
    }
ADD_TAIL:    
	;
    //DEBUGMSG(4,"packed %d gcodes\n",*codect);
	/*
    #ifdef FAIT_SEND2DSP
    arm2dspREQ=FALSE;
    #else
    arm2dspREQ=TRUE;
    #endif 
    */
    //gcodeSendOver=TRUE;
}
/*
*------------------------------------------------------------------------------
* function: sendFaitCode
* parameter: void
* return   : void
* description : send a fait code to dsp, used int breakpoint mode,
  to replace all cods that need run time
*------------------------------------------------------------------------------
*/
void sendFaitCode(U32 sendcount)
{
    TDGmfst  fakeF;
    //fakeF.len=sizeof(TDGmfst);
    fakeF.gnum=GCODE_F; 
    fakeF.value=autoBreakPoint.fvalue;
    fakeF.realSendCount=++STDrealsendcount;
    fakeF.sendCount=sendcount;
    autoBreakPoint.sendCount=sendcount;
    coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
    //memcpy(&(arm2dspPKG[*pkglen]),&fakeF,fakeF.len);
    shm_cycBufWrite(CYCBUF_GCODE,&fakeF,sizeof(TDGmfst)>>2);
    sendedBuf[SENDEDwptr].gnum=fakeF.gnum;
    sendedBuf[SENDEDwptr].sendCount=sendcount;
    sendedBuf[SENDEDwptr].x=fakeF.value;
    //use the src line and code of fait code ,so that src display to break point
    sendedBuf[SENDEDwptr].srcLine=compiledGbuf[autoBreakPoint.codeIndex].srcline;
    sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.codeIndex;
    CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
    DEBUGMSG(4,"faitF, sendcount %d, realsendcount %d\n",fakeF.sendCount,fakeF.realSendCount);
    //*pkglen=*pkglen+fakeF.len;
    //(*codect)++;
}
/*
*------------------------------------------------------------------------------
* function: sendBreakPointState
* parameter: void
* return   : void
* description : here we reach the break point of program but not resote
*     preview state to dsp, so, send them before real program run
*------------------------------------------------------------------------------
*/
void sendBreakPointState()
{
    TDGBarc gcode;

    PDGBmfst mptr;
    PDGBmfst tptr;
    PDGBline lineptr;
    if(SYSparam[96].val==0)
    {
        autoBreakPoint.flag=0;
        return;
    }
    switch(autoBreakPoint.flag)
    {
        case(6): //m4x state
            mptr=(PDGBmfst)&gcode;
            //mptr->len=sizeof(TDGmfst);
            mptr->gnum=(autoBreakPoint.m4x<<8)|(0x65);          
            mptr->realSendCount=++STDrealsendcount;
            mptr->sendCount=autoBreakPoint.sendCount;
            mptr->srcCode=autoBreakPoint.srcCode;
            mptr->srcLine=autoBreakPoint.srcLine;
            coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
            //memcpy(&(arm2dspPKG[*pkglen]),mptr,mptr->len);
            shm_cycBufWrite(CYCBUF_GCODE, mptr, sizeof(TDGmfst));
            //back up to sended code
            sendedBuf[SENDEDwptr].gnum=(autoBreakPoint.m4x<<8)|(0x65);
            sendedBuf[SENDEDwptr].sendCount=autoBreakPoint.sendCount;
            sendedBuf[SENDEDwptr].srcLine=autoBreakPoint.srcLine;
            sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.srcCode;
            CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
            DEBUGMSG(4,"M:%x, senccount %d, realsendcount %d \n",
                mptr->gnum,mptr->sendCount,mptr->realSendCount);
            //*pkglen=*pkglen+mptr->len;
            //(*codect)++; 
            assistenFlag=TRUE;
            assistenCode=gcode;
            autoBreakPoint.flag=5;
            break;
        case(5): //cool state
            mptr=(PDGBmfst)&gcode;
            //mptr->len=sizeof(TDGmcode);
            mptr->gnum=autoBreakPoint.m89;            
            mptr->realSendCount=++STDrealsendcount;
            mptr->sendCount=autoBreakPoint.sendCount;
            mptr->srcCode=autoBreakPoint.srcCode;
            mptr->srcLine=autoBreakPoint.srcLine;
            coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
            //memcpy(&(arm2dspPKG[*pkglen]),mptr,mptr->len);
            shm_cycBufWrite(CYCBUF_GCODE, mptr, sizeof(TDGmfst));
            //back up to sended code
            sendedBuf[SENDEDwptr].gnum=autoBreakPoint.m89;
            sendedBuf[SENDEDwptr].sendCount=autoBreakPoint.sendCount;
            sendedBuf[SENDEDwptr].srcLine=autoBreakPoint.srcLine;
            sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.srcCode;
            CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
            DEBUGMSG(4,"M:%x, senccount %d, realsendcount %d \n",
                mptr->gnum,mptr->sendCount,mptr->realSendCount);
            //*pkglen=*pkglen+mptr->len;
            //(*codect)++; 
            assistenFlag=TRUE;
            assistenCode=gcode;
            autoBreakPoint.flag=4;
            break;
        case(4): //chunk state
            mptr=(PDGBmfst)&gcode;
            //mptr->len=sizeof(TDGmfst);
            mptr->gnum=autoBreakPoint.m1213;            
            mptr->realSendCount=++STDrealsendcount;
            mptr->sendCount=autoBreakPoint.sendCount;
            mptr->srcCode=autoBreakPoint.srcCode;
            mptr->srcLine=autoBreakPoint.srcLine;
            coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
            //memcpy(&(arm2dspPKG[*pkglen]),mptr,mptr->len);
            shm_cycBufWrite(CYCBUF_GCODE, mptr, sizeof(TDGmfst));
            //back up to sended code
            sendedBuf[SENDEDwptr].gnum=autoBreakPoint.m1213;
            sendedBuf[SENDEDwptr].sendCount=autoBreakPoint.sendCount;
            sendedBuf[SENDEDwptr].srcLine=autoBreakPoint.srcLine;
            sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.srcCode;
            CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
            DEBUGMSG(4,"M:%x, senccount %d, realsendcount %d \n",
                mptr->gnum,mptr->sendCount,mptr->realSendCount);
            //*pkglen=*pkglen+mptr->len;
           // (*codect)++; 
            assistenFlag=TRUE;
            assistenCode=gcode;
            autoBreakPoint.flag=3;
            break;
        case(3):// spindle state
            mptr=(PDGBmfst)&gcode;
            //mptr->len=sizeof(TDGmcode);
            mptr->gnum=autoBreakPoint.m345;            
            mptr->realSendCount=++STDrealsendcount;
            mptr->sendCount=autoBreakPoint.sendCount;
            mptr->srcCode=autoBreakPoint.srcCode;
            mptr->srcLine=autoBreakPoint.srcLine;
            coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
            //memcpy(&(arm2dspPKG[*pkglen]),mptr,mptr->len);
            shm_cycBufWrite(CYCBUF_GCODE, mptr, sizeof(TDGmfst));
            //back up to sended code
            sendedBuf[SENDEDwptr].gnum=autoBreakPoint.m345;
            sendedBuf[SENDEDwptr].sendCount=autoBreakPoint.sendCount;
            sendedBuf[SENDEDwptr].srcLine=autoBreakPoint.srcLine;
            sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.srcCode;
            CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
            DEBUGMSG(4,"M:%x, senccount %d, realsendcount %d \n",
                mptr->gnum,mptr->sendCount,mptr->realSendCount);
            //*pkglen=*pkglen+mptr->len;
            //(*codect)++; 
            assistenFlag=TRUE;
            assistenCode=gcode;
            autoBreakPoint.flag=2;
            break;
        case(2): //tool state
            tptr=(PDGBmfst)&gcode;
            //tptr->len=sizeof(TDGfst);
            tptr->gnum=GCODE_T;
            tptr->realSendCount=++STDrealsendcount;
            tptr->sendCount=autoBreakPoint.sendCount;
            tptr->value=autoBreakPoint.t;
            tptr->srcCode=autoBreakPoint.srcCode;
            tptr->srcLine=autoBreakPoint.srcLine;
            coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
            //memcpy(&(arm2dspPKG[*pkglen]),tptr,tptr->len);
            shm_cycBufWrite(CYCBUF_GCODE, tptr, sizeof(TDGmfst));
            sendedBuf[SENDEDwptr].gnum=autoBreakPoint.m345;
            sendedBuf[SENDEDwptr].sendCount=autoBreakPoint.sendCount;
            sendedBuf[SENDEDwptr].srcLine=autoBreakPoint.srcLine;
            sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.srcCode;
            sendedBuf[SENDEDwptr].x=tptr->value;
            CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
            DEBUGMSG(4,"FST:0x%X, val %d, sendcount %d, realsendcount %d\n",
                tptr->gnum,tptr->value,tptr->sendCount,tptr->realSendCount);
            //*pkglen=*pkglen+tptr->len;
            //(*codect)++; 
            assistenFlag=TRUE;
            assistenCode=gcode;
            autoBreakPoint.flag=1;
            break;
        case(1): //position
            lineptr=(PDGBline)&gcode;

            //lineptr->len=sizeof(TDGline);
            lineptr->gnum=GCODE_00;
            lineptr->x=autoBreakPoint.coord.x;
            lineptr->z=autoBreakPoint.coord.z;
            lineptr->y=autoBreakPoint.coord.y;
            coordSentedGend.x=lineptr->x;
            coordSentedGend.z=lineptr->z;
            coordSentedGend.y=lineptr->y;
            lineptr->realSendCount=++STDrealsendcount;
            lineptr->sendCount=autoBreakPoint.sendCount;
            lineptr->srcCode=autoBreakPoint.srcCode;
            lineptr->srcLine=autoBreakPoint.srcLine;
            coordGend[STDrealsendcount%SENDED_BUF_MAX]=coordSentedGend;
            //SYSLOG(LOGTYPE_DEBUG,LOGSRC_ARM,0,"line %d,x%d,z%d,sendcount %d, realsenccount %d\n",
            DEBUGMSG(4,"line %d,x%d,z%d,sendcount %d, realsenccount %d\n",
                lineptr->gnum,lineptr->x,lineptr->z,
                lineptr->sendCount,lineptr->realSendCount);
            //memcpy(&(arm2dspPKG[*pkglen]),lineptr,lineptr->len);
            shm_cycBufWrite(CYCBUF_GCODE, lineptr, sizeof(TDGline));
            sendedBuf[SENDEDwptr].gnum=GCODE_00;
            sendedBuf[SENDEDwptr].sendCount=autoBreakPoint.sendCount;
            sendedBuf[SENDEDwptr].srcLine=autoBreakPoint.srcLine;
            sendedBuf[SENDEDwptr].srcCode=autoBreakPoint.srcCode;
            sendedBuf[SENDEDwptr].x=autoBreakPoint.coord.x;
            sendedBuf[SENDEDwptr].z=autoBreakPoint.coord.z;
            sendedBuf[SENDEDwptr].y=autoBreakPoint.coord.y;
            CYCLE_BUF_WINC(SENDEDwptr,SENDED_BUF_MAX);
            //*pkglen=*pkglen+lineptr->len;
            //(*codect)++;            
            autoBreakPoint.flag=0;
            break;
        default:
            autoBreakPoint.flag=0;
            break;
    }
}
/*
*------------------------------------------------------------------------------
* function: Task2SendCMDGcode
* parameter: void
* return   : void
* description : send out the g code than user input in cmd line
*   it accept one g code and mfst before it;
*------------------------------------------------------------------------------
*/
void traceDSPrun(void)
{

    PSEDgcode pgcode;
    if((sysMode!=SYS_MODE_AUTO)
        ||(gexecState==GEXEC_RESET)
        //||(gexecState==GEXEC_DONE)
        ||(gexecState==GEXEC_CERR)
        ||(addLineMode!=0))
    {
        return;
    }

    if(CYCLE_BUF_EMPTY(SENDEDwptr, SENDEDrptr))
    {
        return;
    }
    if(STDruncount==0)
        return;

    pgcode=&sendedBuf[SENDEDrptr];
    if(pgcode->sendCount>SPCruncount)//逆行时显示退回
    {
        U16 i=0;
        while(pgcode->sendCount>SPCruncount)
        {
            i++;
            if(i>SENDED_BUF_MAX)
            {
                return;
            }
            pgcode=&sendedBuf[(SENDEDrptr+SENDED_BUF_MAX-i)%SENDED_BUF_MAX];
            switch (pgcode->gnum)
            {
                case (GCODE_F):
                    gWorkState.f=pgcode->x;
                    break;
                case (GCODE_00):
                case (GCODE_01):
                case (GCODE_02):
                case (GCODE_03):
                    //HERE we had to fine the src gnum in cimpiled g code
                    {
                        U32 temp;
                        temp=compiledGbuf[pgcode->srcCode].gtype;
                        if((temp<=3)||(temp==32)||(temp==90)
                            ||(temp==92)||(temp==92))
                        {
                            gWorkState.GG01=temp;
                        }else if((temp==71)||(temp==72))
                        {
                            gWorkState.GG01=pgcode->gnum;
                        }
                    }
                    break;
            }
        }
        SENDEDrptr = (SENDEDrptr+SENDED_BUF_MAX-i)%SENDED_BUF_MAX;
        return;
    }
    while(pgcode->sendCount<=SPCruncount)
    {
        switch (pgcode->gnum)
        {
            //mcode
            case (GCODE_M03):
                spinRunSign=1;
                gWorkState.sdir=3;
                //PLC_NCSTAT_SRUN;
                //setIOOUT(IOOUT_SPIN_RUN, TRUE);
                goto PASS_ONEGCODE;
            case (GCODE_M04):
                spinRunSign=2;
                gWorkState.sdir=4;
                //PLC_NCSTAT_SRUN;
                //setIOOUT(IOOUT_SPIN_RUN, TRUE);
                goto PASS_ONEGCODE;
            case (GCODE_M05):
                spinRunSign=0;
                gWorkState.sdir=5;
                ////PLC_NCSTAT_SSTOP;
                //setIOOUT(IOOUT_SPIN_RUN, FALSE);
                goto PASS_ONEGCODE;
            //case (GCODE_M06):
            //case (GCODE_M07):
            case (GCODE_M08):
            case (GCODE_M09):
            case (GCODE_M12):
            case (GCODE_M13):
                goto PASS_ONEGCODE;
            case (GCODE_M19):
                spinRunSign=0;
                gWorkState.sdir=5;
                //PLC_NCSTAT_SRUN;
                goto PASS_ONEGCODE;
            case (GCODE_M32):
            case (GCODE_M33):
            case (GCODE_M41):
            case (GCODE_M42):
            case (GCODE_M43):
            case (GCODE_M44):
            case (GCODE_M30):
            case (GCODE_M65):
            case (GCODE_M254):
            case (GCODE_M255):
            case (GCODE_54):
                goto PASS_ONEGCODE;
	        case (GCODE_20):
            case (GCODE_21):
				gWorkState.GG06=pgcode->gnum;
				goto PASS_ONEGCODE;
            case (GCODE_40):
            case (GCODE_41):
            case (GCODE_42):
				gWorkState.GG04=pgcode->gnum;
				goto PASS_ONEGCODE;
            //fst code
            case (GCODE_F):
                gWorkState.f=pgcode->x;
                goto PASS_ONEGCODE;
            case (GCODE_S):
            case(GCODE_SCREW):
                //gWorkState.s=pgcode->x;
                goto PASS_ONEGCODE;
            case (GCODE_T):
                //gWorkState.t=pgcode->x;
                goto PASS_ONEGCODE;
            case (GCODE_04):
            case (GCODE_M50):
                goto PASS_ONEGCODE;
            case (GCODE_96):
            case (GCODE_97):
                gWorkState.GG02=pgcode->gnum;
                G9697=pgcode->gnum;
                goto PASS_ONEGCODE;
            case (GCODE_98):
            case (GCODE_99):
                gWorkState.GG03=pgcode->gnum;
                G9899=pgcode->gnum;
                goto PASS_ONEGCODE;
            case (GCODE_M253):
                goto PASS_ONEGCODE;
            case (GCODE_50):
                goto PASS_ONEGCODE;
            case (GCODE_00):
            case (GCODE_01):
            case (GCODE_02):
            case (GCODE_03):
                //HERE we had to fine the src gnum in cimpiled g code
                {
                    U32 temp;
                    temp=compiledGbuf[pgcode->srcCode].gtype;
                    if((temp<=3)||(temp==32)||(temp==90)
                        ||(temp==92)||(temp==92))
                    {
                        gWorkState.GG01=temp;
                    }else if((temp==71)||(temp==72))
                    {
                        gWorkState.GG01=pgcode->gnum;
                    }
                }
                goto PASS_ONEGCODE;
            default:
                DEBUGMSG(4,"G code unkonw: %x\n", pgcode->gnum);
                break;
        }
PASS_ONEGCODE:
        sendedPtr=SENDEDrptr;
        CYCLE_BUF_RINC(SENDEDrptr,SENDED_BUF_MAX);
        if(CYCLE_BUF_EMPTY(SENDEDwptr, SENDEDrptr))
        {
            break;
        }else{
            pgcode=&sendedBuf[SENDEDrptr];
        }
    }
}

/*
*------------------------------------------------------------------------------
* function: IOhandle
* parameter: void
* return   : void
* description :  handle IO input or output, do io related job
*------------------------------------------------------------------------------
*/
void IOhandle(void)
{
    #if 0
 #define PLCBT_RUN   (0)
 #define PLCBT_PAUSE (1)
 #define PLCBT_CHUCK (2)
 #define PLCBT_SCW   (3)
 #define PLCBT_SCCW  (4)
 #define PLCBT_SSTOP (5)
 #define PLCBT_COOL  (6)
 #define PLCBT_TAIL  (7)
 #define PLCBT_OIL   (8)
 #define PLCBT_SAFEDOOR (9)
 static U8 plcButtonState[16]={0,};
 /*
    if(oilSign==1)
    {
        if(oilTimer>0)
        {
            oilTimer--;
        }else{
            oilSign=0;
        }
    } */
    if(PLC_SIG_OIL_BT)
    {
        if(plcButtonState[PLCBT_OIL]==0)
        {
            plcButtonState[PLCBT_OIL]=1;
            mfuncNum=MFUNC_OILON;
        }
    }else{
        plcButtonState[PLCBT_OIL]=0;
    }
    //if(plcG[0]&0x0c) //auto run or run key pressed
    if(PLC_SIG_RUN_BT)
    {
        if(plcButtonState[PLCBT_RUN]==0)
        {
            plcButtonState[PLCBT_RUN]=1;
            runKeyHandle();
        }
    }else{
        plcButtonState[PLCBT_RUN]=0;
    }
    //CHECK PAUSE
    if(PLC_SIG_PAUSE_BT)
    {
        if(plcButtonState[PLCBT_PAUSE]==0)
        {
            plcButtonState[PLCBT_PAUSE]=1;
            pauseKeyHandle();
        }
    }else{
        plcButtonState[PLCBT_PAUSE]=0;
    }
    //check cool
    if(PLC_SIG_COOL_BT)
    {
        if(plcButtonState[PLCBT_COOL]==0)
        {
            plcButtonState[PLCBT_COOL]=1;
            assistenKeyHandle(KEY_COOL);
        }
    }else{
        plcButtonState[PLCBT_COOL]=0;
    }
    //check chuck
    if((SYSparam[172].val&0X4)==0)
    {
        if(PLC_SIG_CHUCK_BT)
        {
            if(plcButtonState[PLCBT_CHUCK]==0)
            {
                plcButtonState[PLCBT_CHUCK]=1;
                chuckKeyHandle();
            }
        }else{
            plcButtonState[PLCBT_CHUCK]=0;
        }
    }else{
        if((CYCLE_BUF_EMPTY(mbufwptr,mbufrptr))&&(mfuncState==MFUNCS_OFF))
        {
            if(PLC_SIG_CHUCK_BT) //PRESS DOWN= M13
            {
                if(gWorkState.chuck==12)
                    chuckKeyHandle();
            }else{
                if(gWorkState.chuck==13)
                    chuckKeyHandle();
            }
        }
    }
    //check tail
    if(PLC_SIG_TAIL_BT)
    {
        if(plcButtonState[PLCBT_TAIL]==0)
        {
            plcButtonState[PLCBT_TAIL]=1;
            tailKeyHandle();
        }
    }else{
        plcButtonState[PLCBT_TAIL]=0;
    }
    //check save door is closed or not
    if(PLC_SIG_SAFEDOOR_BT)
    {
        plcButtonState[PLCBT_SAFEDOOR]=1;
        safedoorFlag=1;
    }else{
        if((safedoorFlag==1)
           &&(sysMode==SYS_MODE_AUTO)
           &&(SYSparam[90].val!=0))
        {
            if((GEXEC_STATE_RUNING)
              &&(!((singleModeFlag==1)&&(DSPState&BIT_SINGLE_END))) //not single
              &&(pauseFlag==FALSE))//not pause
            {
                //check if we need to make a alarm or warning
                if(SYSparam[90].val==1)
                {  //alarm
                   //showHint(OPERR_SAFEDOOROPEN, SHOW_TIME_FEVER);
                }else{
                   //warning
                   ALARM_GRP2|=ALM_GRP2_SAFEDOOR_OPEN;
                }
            }
        }
        safedoorFlag=0;
        plcButtonState[PLCBT_SAFEDOOR]=0;
    }
    //tell plc what state cnc is in
    if((sysMode==SYS_MODE_AUTO)&&
    ((pauseFlag==1)||((singleModeFlag==1)&&(DSPState&BIT_SINGLE_END))))
    {
        //PLC_NCSTAT_AUTOPAUSE;
    }else{
        //PLC_NCSTAT_AUTOCONT;
    }
    #endif
}


void callPlcLight(void)
{
    U32 now;//,i;
    //static U8 pin=0;
    now=OSGetTimeTick();

    if((now%200)>5)
    {
        return; //update led 100 cycle pre time;
    }
    if(inAlarm)
    {
        //PLC_NCSTAT_ALARM;
        return;
    }
    if((sysMode==SYS_MODE_EDIT)||(sysMode==SYS_MODE_MDI))
    {
        //PLC_NCSTAT_FREE;
        return;
    }
    //PLC_NCSTAT_RUNING;

}
/*
*------------------------------------------------------------------------------
* function: plcInterface()
* parameter: void
* return   : void
* description : comminucate with plc,
*------------------------------------------------------------------------------
*/
void plcInterface()
{
    autoAssistenPlcRequest=2;
    #if 0
    static U32 mtimer=0;
    callPlcLight();
    IOhandle();
    //handle io of plc inputs
    if((mfuncState==MFUNCS_OFF)&&
    (!((PLC_SIG_MFUN_FIN)||(PLC_SIG_MFUN_PROC))))
    {
        if(CYCLE_BUF_EMPTY(mbufwptr, mbufrptr))
        {
            return;
        }else{
            if((machLockFlag!=1)||(SYSparam[69].val==2))
            {
                mfuncState=MFUNCS_REQ;
                mfuncNum=mfuncBuf[mbufrptr];
                CYCLE_BUF_RINC(mbufrptr, MBUF_MAX);
            }else{ //ignore it if in machlock
                CYCLE_BUF_RINC(mbufrptr, MBUF_MAX);
            }
        }
    }
    //handle mfucntion of plc communicate
    if(mfuncState==MFUNCS_REQ)
    {
        if(SYSparam[171].val==0)
            mtimer=1000;
        else
            mtimer=SYSparam[171].val;
        PLC_NCMCODE_NUM(mfuncNum);
        //PLC_NCCMD_M_ON;
        mfuncState=MFUNCS_PROC;
    }else if(mfuncState==MFUNCS_PROC)
    {
        if(PLC_SIG_MFUN_FIN)
        {
            if(((mfuncNum==MFUNC_CHUCKON)&&(!PLC_SIG_CHUCK_ON))
              ||((mfuncNum==MFUNC_CHUCKOFF)&&(PLC_SIG_CHUCK_ON))
              ||((mfuncNum==MFUNC_TAILON)&&(!PLC_SIG_TAIL_ON))
              ||((mfuncNum==MFUNC_TAILOFF)&&(PLC_SIG_TAIL_ON))
            )
            {
                ALARM_GRP1|=ALM_GRP1_MCODE_RUN;
                mfuncState=MFUNCS_OFF;
                //PLC_NCCMD_M_OFF;

            }
            mfuncState=MFUNCS_OFF;
            //PLC_NCCMD_M_OFF;
            mfuncNum=0;
            mtimer=0;
            if(autoAssistenPlcRequest==1)
            {
                autoAssistenPlcRequest=2;
            }
        }else  //(PLC_SIG_MFUN_PROC)
        {
            mtimer--;
            if(mtimer==0)
            {
                ALARM_GRP1|=ALM_GRP1_MCODE_RUN;
                mfuncState=MFUNCS_OFF;
                //PLC_NCCMD_M_OFF;
                mfuncNum=0;
                mtimer=0;
                if(autoAssistenPlcRequest==1)
                {
                    autoAssistenPlcRequest=2;
                }
            }
        }
    }else{
        mfuncState=MFUNCS_OFF;
        //PLC_NCCMD_M_OFF;
        mfuncNum=0;
        mtimer=0;

    }
    #endif
}
U8 dspfinish=0;//mdi跑完会切换模式，以此变量保证缓冲区里没有脉冲未发
void MDIFunction(void)
{
    if(EventSaveEdit==1)
    {
        EventSaveEdit=0;
//        editSaveFile();
    }
    if(currentGUI==GUINUM_MDI)
    {
        if(mdimode.inmdi==0)
        {//进入MDI模式，MDI需重编译
            MDI_sourceCT=0;
            gexecState = GEXEC_RESET;
        }
        mdimode.inmdi=1;
    }else if(mdimode.runO9XXX==0)
    {
        if(mdimode.inmdi==1)
        {//退出MDI模式，G代码需要重编译
            //editSaveFile_MDI();
            sourceCT = 0;
        }
        mdimode.inmdi=0;
    }else if(mdimode.runO9XXX==1)
    {
        mdimode.inmdi=1;
    }
    if((mdimode.mdirunning == 1)&&((gexecState==GEXEC_DONE)||(gexecState==GEXEC_CERR)))
    {//MDI运行完成，MDI只能在GEXEC_RESET状态开始
        if(dspfinish==1)
        {
            mdimode.mdirunning = 0;
            manMakeRunKeyDelay = 0;
            gexecState = GEXEC_RESET;
            if(mdimode.runO9XXX)
            {
                switch(modeBackup)
                {
                    case(SYS_MODE_EDIT):
                        sysModeChange(KEY_EDIT);
                        break;
                    case(SYS_MODE_WHEEL):
                        sysModeChange(KEY_WHEEL);
                        break;
                    case(SYS_MODE_JOG):
                        sysModeChange(KEY_JOG);
                        break;
                    default:
                        sysModeChange(KEY_MDI);
                }
                mdimode.runO9XXX=0;
            }else
                sysModeChange(KEY_MDI);
        }
    }
    if(manMakeRunKeyDelay>0)
    {
        manMakeRunKeyDelay--;
        if(manMakeRunKeyDelay==0)
        {
            runKeyHandle();
        }
    }
}
void Trace()
{
    S32 sx,sz,ex,ez;
    TRACEDATA *p;
    static U8 prev,exit=0,enter=0;
    U16 colour;
    colour=trace_colour_pool[trace_colour_select[0]];//得到仿真轨迹颜色
    if((prev==GUINUM_SIMTRACE)&&(currentGUI!=GUINUM_SIMTRACE))
    {
        exit=1;
        enter=0;
        if((trace_zoom_on==1)||(trace_move_on==1))
        {
            trace_move_on=0;
            trace_zoom_on=0;
            showMsg=FALSE;
        }
    }
    if((exit==1)&&(!GEXEC_STATE_RUNING))
    {//进入和退出时正在跑程序则不能虚拟运行
        trace_virtual_run=0;
        /*if((machLockFlag==1)&&(prevmachlock==0))
        {
            machLockKeyHanle();
        }*/
        exit=0;
    }
    if((currentGUI==GUINUM_SIMTRACE)&&(prev!=GUINUM_SIMTRACE))
    {
        enter=1;
        exit=0;
    }
    if((enter==1)&&(!GEXEC_STATE_RUNING))
    {
        if(((gexecState!=GEXEC_EXERR)&&(gexecState!=GEXEC_CERR))
            &&((sysMode==SYS_MODE_AUTO)&&((gexecState<GEXEC_CMPLE)||(trace_data_record==0))))
        {//进入时还没有仿真图形时虚拟运行以得到轨迹
            trace_virtual_run=1;
            trace_data_record=0;
            gexecState=GEXEC_AUTO_START;
            Trace_Re_Print();
            trace_real_clear=0;
        }
        /*if(machLockFlag==0)
        {
            //prevmachlock=0;
            machLockKeyHanle();
        }else{
            prevmachlock=1;
        }*/
        enter=0;
    }
    prev=currentGUI;
    if(trace_autpfix_run==1)
    {
        if(trace_virtual_run==0)
        {
            if(trace_data_record!=0)
            {
                trace_autpfix_run=0;
                Trace_Autofix();
            }else{
                trace_autpfix_run=0;
            }
        }
    }
    while(trace_has_print<trace_data_record)
    {
        p=&(trace_data[trace_has_print%TRACE_DATA_MAX]);
        if(p->gnum==0||p->gnum==1)
        {
            sx=Trace_GetX(p->sx);
            sz=Trace_GetZ(p->sz);
            ex=Trace_GetX(p->ex);
            ez=Trace_GetZ(p->ez);
            if(p->gnum==1)
            {
                Trace_LineDraw(sz,sx,ez,ex,65535,0,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
                if(trace_x_symmetry)
                {//X对称，实线
                    sx=Trace_GetX(-p->sx);
                    ex=Trace_GetX(-p->ex);
                    Trace_LineDraw(sz,sx,ez,ex,65535,0,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
                }
            }else{
                if(trace_g0_on)
                {//G00为虚线
                    Trace_LineDraw(sz,sx,ez,ex,6,3,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
                }
            }
        }else if(p->gnum==2||p->gnum==3){
            sx=Trace_GetX(p->sx);
            sz=Trace_GetZ(p->sz);
            if(p->gnum==2)
            {
                Trace_ArcDraw(sz,sx,p->r/trace_scale,p->ez,p->ex,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
            }else{
                Trace_ArcDraw(sz,sx,p->r/trace_scale,p->ex,p->ez,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
            }
            if(trace_x_symmetry)
            {
                sx=Trace_GetX(-p->sx);
                if(p->gnum==3)
                {
                    Trace_ArcDraw(sz,sx,p->r/trace_scale,360000-p->ez,360000-p->ex,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
                }else{
                    Trace_ArcDraw(sz,sx,p->r/trace_scale,360000-p->ex,360000-p->ez,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colour);
                }
            }
        }
        trace_has_print++;
    }
}
void Trace_Re_Print(void)
{
    U32 i;
    static S32 prevtrace_scale=0;//修改图形参数都要调用clear，于是在这里记录
    static S32 prevtrace_cen_x=0;
    static S32 prevtrace_cen_z=0;
    static U8  prevcolour[TRACE_MENU3_MAX];
    U16 colourback,colourline1,colourline2;
    return;
    colourback=trace_colour_pool[trace_colour_select[5]];//得到背景颜色
    colourline1=trace_colour_pool[trace_colour_select[6]];//得到坐标系颜色
    colourline2=trace_colour_pool[trace_colour_select[7]];//得到坐标系颜色
    for(i=0;i<TRACE_MENU3_MAX;i++)
    {
        if(prevcolour[i]!=trace_colour_select[i])
        {
            IIC_Write1(IICADDR_TRACECOLOUR+i,trace_colour_select[i]);
            prevcolour[i]=trace_colour_select[i];
        }
    }
    if(prevtrace_scale!=trace_scale)
    {
        IIC_Write4(IICADDR_TRACECS, trace_scale);
        prevtrace_scale=trace_scale;
    }
    if(prevtrace_cen_x!=trace_cen_x)
    {
        IIC_Write4(IICADDR_TRACECX, trace_cen_x);
        prevtrace_cen_x=trace_cen_x;
    }
    if(prevtrace_cen_z!=trace_cen_z)
    {
        IIC_Write4(IICADDR_TRACECZ, trace_cen_z);
        prevtrace_cen_z=trace_cen_z;
    }
    for(i=0;i<TRACE_GWIDTH*TRACE_GHEIGHT;i++)
    {//清空仿真图形
        trace_sim_image[i]=colourback;
    }
    for(i=(TRACE_GWIDTH/2)%TRACE_BIG_GRID;i<TRACE_GWIDTH;i+=TRACE_SMALL_GRID)
    {
        if((i%TRACE_BIG_GRID)==(TRACE_GWIDTH/2)%TRACE_BIG_GRID)
        {
            Trace_DrawVLine(i,0,TRACE_GHEIGHT,5,7,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colourline1);
        }else{
            Trace_DrawVLine(i,0,TRACE_GHEIGHT,5,7,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colourline2);
        }
    }
    for(i=(TRACE_GHEIGHT/2)%TRACE_BIG_GRID;i<TRACE_GHEIGHT;i+=TRACE_SMALL_GRID)
    {
        if((i%TRACE_BIG_GRID)==(TRACE_GHEIGHT/2)%TRACE_BIG_GRID)
        {
            Trace_DrawHLine(0,i,TRACE_GWIDTH,5,7,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colourline1);
        }else{
            Trace_DrawHLine(0,i,TRACE_GWIDTH,5,7,TRACE_GWIDTH,TRACE_GHEIGHT,trace_sim_image,colourline2);
        }
    }
    if(trace_scale<TRACE_MIN_SCALE)
    {
        trace_scale=TRACE_MIN_SCALE;
    }
    if(trace_scale>TRACE_MAX_SCALE)
    {
        trace_scale=TRACE_MAX_SCALE;
    }
    if(trace_scale*TRACE_SMALL_GRID>=1000)
    {
        if((trace_cen_x%1000)!=0)
        {
            if((trace_cen_x%1000)>(1000/2))
            {
                trace_cen_x=(trace_cen_x/1000+1)*1000;
            }else{
                trace_cen_x=(trace_cen_x/1000)*1000;
            }
        }
        if((trace_cen_z%1000)!=0)
        {
            if((trace_cen_z%1000)>(1000/2))
            {
                trace_cen_z=(trace_cen_z/1000+1)*1000;
            }else{
                trace_cen_z=(trace_cen_z/1000)*1000;
            }
        }
    }
    trace_has_print=0;
    trace_real_clear=1;//清空实际刀路，若不想清除则在调用clear后自行置0
    if(trace_data_record>=TRACE_DATA_MAX)
    {//由于轨迹记录数有限，超过后每次重画必须重编译
        if(!(GEXEC_STATE_RUNING))
        {
            if(sysMode==SYS_MODE_AUTO)
            {
                trace_virtual_run=1;
                gexecState=GEXEC_AUTO_START;
            }
        }
    }
}

void Trace_Record_Data(U8 gnum,S32 sx,S32 sz,S32 ex,S32 ez,S32 cx,S32 cz,S32 sa,S32 ea,S32 r)
{
    if(trace_data_record==0)
    {//trace_data_record为0时必须重编译，此时自适应初始化
        trace_autofix_max_x=0x80000000,trace_autofix_max_z=0x80000000,trace_autofix_min_x=0x7fffffff,trace_autofix_min_z=0x7fffffff;
    }
    if(gnum==0||gnum==1)
    {
        trace_data[trace_data_record%TRACE_DATA_MAX].gnum=gnum;
        trace_data[trace_data_record%TRACE_DATA_MAX].sx=sx;
        trace_data[trace_data_record%TRACE_DATA_MAX].sz=sz;
        trace_data[trace_data_record%TRACE_DATA_MAX].ex=ex;
        trace_data[trace_data_record%TRACE_DATA_MAX].ez=ez;
        trace_data_record++;
    }else if(gnum==2||gnum==3){//圆弧记录圆心和起终角角度
        trace_data[trace_data_record%TRACE_DATA_MAX].gnum=gnum;
        trace_data[trace_data_record%TRACE_DATA_MAX].sx=cx;
        trace_data[trace_data_record%TRACE_DATA_MAX].sz=cz;
        trace_data[trace_data_record%TRACE_DATA_MAX].ex=sa;
        trace_data[trace_data_record%TRACE_DATA_MAX].ez=ea;
        trace_data[trace_data_record%TRACE_DATA_MAX].r=r;
        trace_data_record++;
    }
    if(gnum!=0)
    {//记录xz的最大最小，自适应用，忽略G00
        if(sx>trace_autofix_max_x)
        {
            trace_autofix_max_x=sx;
        }
        if(sz>trace_autofix_max_z)
        {
            trace_autofix_max_z=sz;
        }
        if(sx<trace_autofix_min_x)
        {
            trace_autofix_min_x=sx;
        }
        if(sz<trace_autofix_min_z)
        {
            trace_autofix_min_z=sz;
        }
        if(ex>trace_autofix_max_x)
        {
            trace_autofix_max_x=ex;
        }
        if(ez>trace_autofix_max_z)
        {
            trace_autofix_max_z=ez;
        }
        if(ex<trace_autofix_min_x)
        {
            trace_autofix_min_x=ex;
        }
        if(ez<trace_autofix_min_z)
        {
            trace_autofix_min_z=ez;
        }
    }
}
void Trace_Autofix()
{

    S32 tempx,tempz;
    if((trace_autofix_max_x==0x80000000)&&(trace_autofix_max_z==0x80000000)
       &&(trace_autofix_min_x==0x7fffffff)&&(trace_autofix_min_z==0x7fffffff))
    {
        Trace_Re_Print();
        return;
    }
    //算出xz的最大距离，乘1.2为使自适应后图形不碰图形界面边界
    tempx=1.2*(trace_autofix_max_x-trace_autofix_min_x)/TRACE_GHEIGHT;
    tempz=1.2*(trace_autofix_max_z-trace_autofix_min_z)/TRACE_GWIDTH;
    if(trace_x_symmetry)
    {//若开启X对称，则X的最大距离为X到0的2倍
        tempx=(abs(trace_autofix_max_x)>abs(trace_autofix_min_x)?abs(trace_autofix_max_x):abs(trace_autofix_min_x))*2/TRACE_GHEIGHT/0.8;;
    }
    trace_scale=tempx>tempz?tempx:tempz;
    if(trace_scale<TRACE_MIN_SCALE)
    {
        trace_scale=TRACE_MIN_SCALE;
    }
    trace_cen_x=(trace_autofix_max_x+trace_autofix_min_x)/2;
    if(trace_x_symmetry)
    {//若开启X对称，则X中心为X0
        trace_cen_x=0;
    }
    trace_cen_z=(trace_autofix_max_z+trace_autofix_min_z)/2;
    trace_scale=Trace_Fix_Scale(trace_scale);
    Trace_Fix_Center();
    Trace_Re_Print();
}

void Trace_DrawHLine(S32 x,S32 y,S32 len,S32 solid,S32 broken,S32 maxx,S32 maxy,U16* buf,U16 colour)
{
    S32 i=0;
    if(len<0)
    {
        len=-1*len;
    }
    while(len>0)
    {
        if(i==solid+broken)
        {
            i=0;
        }
        if(i<solid)
        {
            Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
        }
        len--;
        x++;
        i++;
    }
}

void Trace_DrawVLine(S32 x, S32 y,S32 len,S32 solid,S32 broken,S32 maxx,S32 maxy,U16* buf,U16 colour)
{
    S32 i=0;
    if(len<0)
    {
        len=-1*len;
    }
    while(len >0)
    {
        if(i==solid+broken)
        {
            i=0;
        }
        if(i<solid)
        {
            Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
        }
        len--;
        y++;
        i++;
    }
}
void Trace_LineDraw(S32 Sx,S32 Sy,S32 Ex,S32 Ey,S32 solid,S32 broken,S32 maxx,S32 maxy,U16* buf,U16 colour)
{
    S32 i=0;
    S32 Dx,Dy;
    Dx=Ex-Sx;
    Dy=Ey-Sy;
    //*LcdColor=GUI_Context.Color;
    if((Dx==0)||(Dy==0))        //特殊直线情况
    {
        if((Dx==0) && (Dy==0))
        {
            Trace_DrawPixel(Sx,Sy,maxx,maxy,buf,colour);
        }
        else
        {
            if(Dx==0)
            {
                if(Dy<0)
                {
                    i=Sy;
                    Sy=Ey;
                    Ey=i;
                }
                if((Sx<0)||(Sx>maxx))
                {
                    return;
                }
                if(Sy<0)
                {
                    Sy=0;
                }
                if(Ey>maxy)
                {
                    Ey=maxy;
                }
                Trace_DrawVLine(Sx, Sy, Ey-Sy,solid,broken,maxx,maxy,buf,colour);  //垂直线
            } else
            {
                if(Dx<0)
                {
                    i=Sx;
                    Sx=Ex;
                    Ex=i;
                }
                if((Sy<0)||(Sy>maxy))
                {
                    return;
                }
                if(Sx<0)
                {
                    Sx=0;
                }
                if(Ex>maxx)
                {
                    Ex=maxx;
                }
                Trace_DrawHLine(Sx, Sy, Ex-Sx,solid,broken,maxx,maxy,buf,colour);  //水平线
            }
        }
    } else
    {
        if(abs(Dx)>=abs(Dy))
        {
            F64 k,b;
            S32 vx;
            S32 x,y;
            vx = (Dx>0)?1:-1;
            k = (F64)Dy/Dx;
            b = Sy-k*Sx;
            if(Sx<0)
            {
                Sx=0;
            }
            if(Ex<0)
            {
                Ex=0;
            }
            if(Sx>maxx)
            {
                Sx=maxx;
            }
            if(Ex>maxx)
            {
                Ex=maxx;
            }
            for(x=Sx;x!=Ex;x+=vx)
            {
                if(i==solid+broken)
                {
                    i=0;
                }
                if(i<solid)
                {
                    Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
                }
                i++;
                y=round(k*x+b);
            }
        }else{
            F64 k,b;
            S32 vy;
            S32 x,y;
            vy= (Dy>0)?1:-1;
            k = (F64)Dx/Dy;
            b = Sx-k*Sy;
            if(Sy<0)
            {
                Sy=0;
            }
            if(Ey<0)
            {
                Ey=0;
            }
            if(Sy>maxy)
            {
                Sy=maxy;
            }
            if(Ey>maxy)
            {
                Ey=maxy;
            }
            for(y=Sy;y!=Ey;y+=vy)
            {
                if(i==solid+broken)
                {
                    i=0;
                }
                if(i<solid)
                {
                    Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
                }
                i++;
                x=round(k*y+b);
            }
        }

        /*
        S32 Judge;    //象限
        S32 Ve,Vx,Vy;
        Vx= (Dx>0)?1:-1;
        Vy= (Dy>0)?1:-1;
        if(Dx>0)
        {
            if(Dy > 0)
                Judge=(Dx>Dy)?1:2;
            else
            {
                Dy=-Dy;
                Judge=(Dx>Dy)?8:7;
            }
        } else
        {
            Dx=-Dx;
            if(Dy>0)
                Judge=(Dx>Dy)?4:3;
            else
            {
                Dy=-Dy;
                Judge=(Dx>Dy)?5:6;
            }
        }
        switch(Judge)
        {
            case 1:
            case 4:
            case 5:
            case 8:
                Ve=Dy-(Dx>>1);
                while(Sx!=Ex)
                {
                    if(i==solid+broken)
                    {
                        i=0;
                    }
                    if(i<solid)
                    {
                        Trace_DrawPixel(Sx,Sy,maxx,maxy,buf,colour);
                    }
                    i++;
                    if(Ve>0)
                    {
                        Sy+=Vy;Ve-=Dx;
                    }
                    Sx+=Vx;
                    Ve+=Dy;
                }
                break;
            case 2:
            case 3:
            case 6:
            case 7:
                Ve=Dx-(Dy>>1);
                while(Sy!=Ey)
                {
                    if(i==solid+broken)
                    {
                        i=0;
                    }
                    if(i<solid)
                    {
                        Trace_DrawPixel(Sx,Sy,maxx,maxy,buf,colour);
                    }
                    i++;
                    if(Ve>0)
                    {
                        Sx+=Vx;Ve-=Dy;
                    }
                    Sy+=Vy;
                    Ve+=Dx;
                }
                break;
            default:
                break;
        }*/
    }
}


void Trace_ArcDraw(S32 Cx,S32 Cy,S32 R,S32 S,S32 E,S32 maxx,S32 maxy,U16* buf,U16 colour)
{
    S32 angle,x,y,delta;
    if(((Cx-R)>maxx)||((Cx+R)<0)||((Cy-R)>maxy)||((Cy+R)<0))
    {
        return;
    }
    if(R==0)
    {
        return;
    }
    delta=45000/R;
    if(delta<10)
    {
        delta=10;
    }
    if(S==E)
    {
        for(angle=0;angle<360000;angle+=delta)
        {
            x=round(cos(1.0L*angle*PI/180/1000)*R)+Cx;
            y=round(sin(1.0L*angle*PI/180/1000)*R)+Cy;
            if(x>maxx||x<0||y>maxy||y<0)
            {
                angle+=(1000>delta?1000:delta);
                continue;
            }
            Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
        }
    } else if(S<E)
    {
        for(angle=S;angle<E;angle+=delta)
        {
            x=round(cos(1.0L*angle*PI/180/1000)*R)+Cx;
            y=round(sin(1.0L*angle*PI/180/1000)*R)+Cy;
            if(x>maxx||x<0||y>maxy||y<0)
            {
                angle+=(1000>delta?1000:delta);
                continue;
            }
            Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
        }
    } else
    {

        for(angle=S;angle<360000;angle+=delta)
        {
            x=round(cos(1.0L*angle*PI/180/1000)*R)+Cx;
            y=round(sin(1.0L*angle*PI/180/1000)*R)+Cy;
            if(x>maxx||x<0||y>maxy||y<0)
            {
                angle+=(1000>delta?1000:delta);
                continue;
            }
            Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
        }
        for(angle=0;angle<E;angle+=delta)
        {
            x=round(cos(1.0L*angle*PI/180/1000)*R)+Cx;
            y=round(sin(1.0L*angle*PI/180/1000)*R)+Cy;
            if(x>maxx||x<0||y>maxy||y<0)
            {
                angle+=(1000>delta?1000:delta);
                continue;
            }
            Trace_DrawPixel(x,y,maxx,maxy,buf,colour);
        }
    }
}
void  Trace_DrawPixel(S32 x,S32 y,S32 maxx,S32 maxy,U16* buf,U16 colour)
{
    if((x<maxx)&&(y<maxy)&&(x>0)&&(y>0))
    {
        *(buf+(y*maxx+x))=colour;
    }
}
S32 Trace_GetX(S32 x)
{//使用rint和1.0使仿真图形与实际刀路基本重合
    return round(1.0*(x-trace_cen_x)/trace_scale+TRACE_GHEIGHT/2);
}
S32 Trace_GetZ(S32 z)
{
    return round(1.0*(z-trace_cen_z)/trace_scale+TRACE_GWIDTH/2);
}

/*
*------------------------------------------------------------------------------
* function: Trace_Real_Coord
* parameter:
* return   : void
* description : trace the coord value change ,draw a graphy
*------------------------------------------------------------------------------
*/
void Trace_Real_Coord()
{//单纯记录实际刀路点，画图和后刀架在gui中处理
    TCoord tempCoord;
    if(trace_real_clear==1)
    {
        memset(trace_real_image,0,TRACE_GHEIGHT*TRACE_GWIDTH);
        trace_real_clear=0;
    }
    if((trace_real_enable==1)&&
        ((sysMode==SYS_MODE_AUTO)||(sysMode==SYS_MODE_JOG)||
        (sysMode==SYS_MODE_WHEEL)))
    {
    }else{
        return;
    }
    tempCoord=coordWorkShow;
    tempCoord.x=Trace_GetX(tempCoord.x);
    tempCoord.z=Trace_GetZ(tempCoord.z);
    if((tempCoord.x>0)&&(tempCoord.x<TRACE_GHEIGHT)&&
       (tempCoord.z>0)&&(tempCoord.z<TRACE_GWIDTH))
    {
        trace_real_image[tempCoord.z][tempCoord.x]=1;
    }
}
S32 Trace_Zoom_In(S32 scale)
{
    S32 i,power;
    scale*=TRACE_SMALL_GRID;
    if(scale<100)
    {
        power=50;
    }else if(scale<1000){
        power=100;
    }else if(scale<10000){
        power=1000;
    }else if(scale<100000){
        power=5000;
    }else{
        power=10000;
        for(i=100000;i<=TRACE_MAX_SCALE*TRACE_SMALL_GRID;i*=10)
        {
            if(scale<i)
            {
                power=i/100;
                break;
            }
        }
    }
    if(scale%power!=0)
    {
        scale=(scale/power+1)*power;
    }else{
        scale+=power;
    }
    scale/=TRACE_SMALL_GRID;
    if(scale>TRACE_MAX_SCALE)
    {
        scale=TRACE_MAX_SCALE;
    }
    if(scale<TRACE_MIN_SCALE)
    {
        scale=TRACE_MIN_SCALE;
    }
    return scale;
}
S32 Trace_Zoom_Out(S32 scale)
{
    S32 i,power;
    scale*=TRACE_SMALL_GRID;
    if(scale<=100)
    {
        power=50;
    }else if(scale<=1000){
        power=100;
    }else if(scale<=10000){
        power=1000;
    }else if(scale<=100000){
        power=5000;
    }else{
        power=10000;
        for(i=100000;i<=TRACE_MAX_SCALE*TRACE_SMALL_GRID;i*=10)
        {
            if(scale<=i)
            {
                power=i/100;
                break;
            }
        }
    }
    if(scale%power!=0)
    {
        scale=scale/power*power;
    }else{
        scale-=power;
    }
    scale/=TRACE_SMALL_GRID;
    if(scale>TRACE_MAX_SCALE)
    {
        scale=TRACE_MAX_SCALE;
    }
    if(scale<TRACE_MIN_SCALE)
    {
        scale=TRACE_MIN_SCALE;
    }
    return scale;
}
S32 Trace_Fix_Scale(S32 scale)
{
    S32 i,power;
    scale*=TRACE_SMALL_GRID;
    if(scale<=100)
    {
        power=50;
    }else if(scale<=1000){
        power=100;
    }else if(scale<=10000){
        power=1000;
    }else if(scale<=100000){
        power=5000;
    }else{
        power=10000;
        for(i=100000;i<=TRACE_MAX_SCALE*TRACE_SMALL_GRID;i*=10)
        {
            if(scale<=i)
            {
                power=i/100;
                break;
            }
        }
    }
    if((scale%power)!=0)
    {
        if((scale%power)>(power/2))
        {
            scale=(scale/power+1)*power;
        }else{
            scale=(scale/power)*power;
        }
    }
    scale/=TRACE_SMALL_GRID;
    if(scale>TRACE_MAX_SCALE)
    {
        scale=TRACE_MAX_SCALE;
    }
    if(scale<TRACE_MIN_SCALE)
    {
        scale=TRACE_MIN_SCALE;
    }
    return scale;
}
void Trace_Fix_Center(void)
{
    S32 i,power=10000;
    for(i=10;i<TRACE_MAX_SCALE*TRACE_SMALL_GRID/10;i*=10)
    {
        if(trace_scale*TRACE_SMALL_GRID<i)
        {
            power=i/10;
            break;
        }
    }
    if((trace_cen_z%power)!=0)
    {
        if((trace_cen_z%power)>(power/2))
        {
            trace_cen_z=(trace_cen_z/power+1)*power;
        }else{
            trace_cen_z=(trace_cen_z/power)*power;
        }
    }
    power/=2;
    if((trace_cen_x%power)!=0)
    {
        if((trace_cen_x%power)>(power/2))
        {
            trace_cen_x=(trace_cen_x/power+1)*power;
        }else{
            trace_cen_x=(trace_cen_x/power)*power;
        }
    }
}

