/*************************************************************
* file: gcompile.c
* author: vinge
* data: 20090302
* description:
*    this the g code compiler functions, it take string form
* any stream and write the correct g code to a compiled buf ;
* for any error in gcode ,it stop and break there
*
* version log:
*    20090302 :v 0.01: init version, it can handle g00 --03;mfst
**************************************************************
*/
//#define DEBUG
//#include <stdio.h>
//#include <stdlib.h>
#include "def.h"
#include "gcompile.h"
#include "../include/sharemem.h"
#include "../include/structcode.h"
#include <math.h>
//#define TEST_COMPLIE

#if 1  //define some debug message
#define DBMSG_GLINE(gnum,x,z,sendcount) DEBUGMSG(1,\
        "GCP LINE :%d X %d,Z %d,sendcount %ld \n",gnum,x,z,sendcount);
#define DBMSG_GARC(gnum,x,z,i,k,r,sendcount)  	DEBUGMSG(1,\
        "GCP ARC %d: X %d,Z %d, I %d,K %d, R %d, send count %ld\n",\
 	    gnum,x,z,i,k,r,sendcount);
#define DBMSG_M(gnum,sendcount)DEBUGMSG(1,\
    "GCP M 0x%04x, sendcount %ld\n",gnum,sendcount);
#define DBMSG_FST(gnum,value,sendcount) DEBUGMSG(1,\
    "GCP FST 0x%04x: val %ld, sendcount %ld \n",gnum,value,sendcount);
#define DBMSG_GCODE(...) DEBUGMSG(1,__VA_ARGS__);
#else
#if defined(__MINGW32__)
#define DBMSG_GLINE(...)
#define DBMSG_GARC(...)
#define DBMSG_M(...)
#define DBMSG_FST(...)
#define DBMSG_GCODE(...)
#else
#define DBMSG_GLINE()
#define DBMSG_GARC()
#define DBMSG_M()
#define DBMSG_FST()
#define DBMSG_GCODE()
#endif
#endif
//**************************************************************
U8 compileDigit=3; //digit tail len allowed in gcode values; can be 3 4 5
U8 unitMode=0;// if 0 meter 1 inch ,use both in comile, in exec use sysUnit
//**************************************************************
// U8 compiledGbuf[1024*1000]; //for g code form file
//buffer to store the compiled source g code
TcompiledG23 compiledGbuf[COMPILE_BUF_MAX];
//U32 subGbuf[SUB_PROG_MAX][SUB_LEN_MAX];
U32 gsrc2compiled[COMPILE_BUF_MAX];

 U8 subProgramBuf[SUB_PROG_MAX][SUB_PROG_LENMAX];
U32 subProgramBufPtr;
PcompiledG23 compiledGPointer;
PcompiledG23 execGptr;
#define G7XBUF_MAX 400
TcompiledG23 G7xcompiledbuf[G7XBUF_MAX];
PcompiledG23 execG7Xptr;
U32 g7xgrunPtr;

U8 srcJumpFlag=0; //if 1 current src line has jump / sign

 U8 cmdlineGBuf[256];  //for g code input form cmd line

// buffet to hole the g code compiler send to tool compent
TTCGarc TCGbuf[TCG_BUF_MAX];
U16 TCGrptr,TCGwptr;
//buffer to hole the g code had been tool compented,wait for send
TDGBarc DGbuf[DG_BUF_MAX];
U16 DGrptr, DGwptr;
//U16 DGprptr; //add this var to sync the send event construct and real send
//it case a double send bat code event when the prev bat code is call to send
//bu not send immideately.


//sened buf isuse to trace the runing of dsp side,
//the size is equot to dsp buffer
TSEDgcode sendedBuf[SENDED_BUF_MAX];
U16 SENDEDwptr,SENDEDrptr;
U8  sendedPtr;  //current runing ptr;

TgProgramAddress programList[PROG_MAX];
U8 programCount,O9XXXcount;
U16 subProgramFileCount;
TgJumpPointAddress jumpPointList[JUMP_POINT_MAX];
U16 jumpPointCount;
Tjumpreq jumpList[JUMP_POINT_MAX];  //h8x jump macro calls
U16 jumpCount;
Tm98req m98Request[JUMP_POINT_MAX];
U16 m98Count; //all m98 call

Tm99req m99Request[JUMP_POINT_MAX];
U16 m99Count;  //this include only the m99 specify return address,not all m99
TgcallStack gcallStack[CALL_DEEP_MAX];
U8 callDeep;

U8 pushTCGcounter=0;
//------------------------------------------------------
U8* streamPtr;
U32 srcline=1;
U32 errannotatesrcline=0;
U16 G7Xbufline;
U16 G7Xbufline1;
U32 g7xg00;
//////////////////////////////////////////////////////
//倒角
S32 chamfer=0; // 倒斜角的长度
S32 hasround=0;   //倒圆角的半径
Point endPoint1,endPoint2,endPoint3; //连续的3个线段终点，做临时存储
Point chamferPoint1,chamferPoint2,chamferCenter; //倒角后新直线的起点。
//用于记住直线前部已经执行过倒角，判断前后倒角会否交错
Point chamferReg; //倒角后的点，即上次倒角的chamferPoint2
double chamferLenReg; //倒角长
//////////////////////////////////////////////////////
//extern sign;     //the last param value sign
Tgstate gCompileState; //stauts record in compile
Tgstate gC2TCState;    //status in exec compiled gcode
Tgstate gWorkState;    //g code state
TgParamBuf gParamBuf; //prevgParamBuf;
TkeyWordBuf gparam;
TkeyWordBuf gparamBak;
//gpramBak uset to sore the gparam if there more than one m or g in the same line
//**********************************************************************
// vars for g7x compound g code compile
U16 compoundGcode; //if execing compand g code g7x 1, else 0,
U32 cpdStart,cpdEnd; //start N and end N index in jumpPointlist;
U32 cpdPtr;          // int index of cpdGptr
U32 cpdNextPtr;      //where to go when compound finish, g70 the next;
PcompiledG23 cpdGptr; //compound gcode runing pointer
S32 di,dk; //x go back move distance, z go back move distace
S32 du,dw;// left for actual cuting
S32 d,enagle;    // compound code
S32 stepx,stepz;
S32 g7xorgx,g7xorgz;
//S32 g73orgx,g73orgz;
S32 g7xstartx,g7xstartz;
S32 g7xendx,g7xendz;
S32 g7xstartx1,g7xstartz1;
S32 g7xendx1,g7xendz1;
S32 g7475step;
//U8 g7xpos,g7xneg;
U8 g7xcutlast;
S32 g7xRunPtr; //to show a correct src code in src win ,save the code g71
S32 g7xsrcLine;
//sepcial for g76
S32 g76m,g76r;//,g76a;
double g76a,g76f,g76deep,g76ra;  //angle,later tan(angle) ,screw f ,r angle
S32 g76dmin,g76d,g76i,g76k,g76dd, g76kdir;
S32 g76rx,g76rz,g76rxd; //g76 rxd 计算螺纹实际终点与 理论终点的差 有符号
S32 g76dz,g76n;
//S32 compiledX,compiledZ;
U32 m15cycleTime;
U8 m15init=1;
U8 m15end=0;
//************************************************************
double macro_val[MACRO_VAR_END-MACRO_VAR_START]={0,};
S32 macro_use_param_num=MACRO_VAR_START;
MACRO_END_STACK macro_if_stack[MACRO_IF_LAYER_MAX][MACRO_IF_LAYER_MAX];//记录if语句的下一条位置和结束位置
U8  macro_if_stack_index;//当前if语句else和elseif的数量
U8  macro_if_stack_index_temp[MACRO_IF_LAYER_MAX]; //在if中有新if时保存当前if语句数
S32 macro_if_layer=0;//当前if嵌套层数
U32 errifsrcline=0;//用于提示哪个if无endif
U32 errwhilesrcline=0;//用于提示哪个循环无end
MACRO_END_STACK macro_while_stack[MACRO_IF_LAYER_MAX];//记录循环起点和结束点
U8  macro_while_layer=0;//当前循环嵌套层数
U32 macro_exit_buf[MACRO_IF_LAYER_MAX];//记录exit所在位置，等待end时一起处理
U8  macro_exit_index=0;
double macro_local_val[MACRO_IF_LAYER_MAX][MACRO_LOCAL_VAR_MAX];
U8  macro_calldeep_record[MACRO_IF_LAYER_MAX];
U8  macro_calldeep_record_index;
//************************************************************
//functions to scanout a key word value
Tgcode gkeywordVal[GKEYWORD_COUNT]=
{
    {'G',scanGMHnum},
    {'M',scanGMHnum},
    {'H',scanGMHnum},
    {'X',scanVal},
    {'Y',scanVal},
    {'Z',scanVal},
    {'A',scanVal},
    {'C',scanVal},
    {'I',scanVal},
    {'J',scanVal},
    {'K',scanVal},
    {'R',scanVal},
    {'F',scanVal},
    {'S',scanValP},
    {'U',scanVal},
    {'V',scanVal},
    {'W',scanVal},
    {'P',scanVal},
    {'Q',scanVal},
    {'T',scanValP},
    {'N',scanValP},
    {'O',scanValP}
};
//functkion to chek if value of a key word is ok
Tgcode gkeywordCheck[GKEYWORD_COUNT]=
{
    {'G',checkGnum},
    {'M',checkMnum},
    {'H',checkHnum},
    {'X',checkCoordVal},
    {'Y',checkCoordVal},
    {'Z',checkCoordVal},
    {'A',checkAVal},
    {'C',checkCoordVal},
    {'I',checkCoordVal},
    {'J',checkCoordVal},
    {'K',checkCoordVal},
    {'R',checkRVal},
    {'F',checkFVal},
    {'S',checkSVal},
    {'U',checkCoordVal},
    {'V',checkCoordVal},
    {'W',checkCoordVal},
    {'P',checkPVal},
    {'Q',checkQVal},//checkCoordVal},
    {'T',checkTVal},
    {'N',checkNVal},
    {'O',checkOVal},
};
//function to store keyword value
Tgcode gkeywordStore[GKEYWORD_COUNT]=
{
    {'G',storeG},
    {'M',storeM},
    {'H',storeH},
    {'X',storeX},
    {'Y',storeY},
    {'Z',storeZ},
    {'A',storeA},
    {'C',storeC},
    {'I',storeI},
    {'J',storeJ},
    {'K',storeK},
    {'R',storeR},
    {'F',storeF},
    {'S',storeS},
    {'U',storeU},
    {'V',storeV},
    {'W',storeW},
    {'P',storeP},
    {'Q',storeQ},
    {'T',storeT},
    {'N',storeN},
    {'O',storeO},
};
//function to store gcode
Tgcode gcode[GCODE_COUNT]=
{    {0,gCodeSaveCheck01},
     {1,gCodeSaveCheck01},
     {2,gCodeSaveCheck23},
     {3,gCodeSaveCheck23},
     {4,gCodeSaveCheck04},
     {17,generalGcodeSaveCheck},
     {18,generalGcodeSaveCheck},
     {19,generalGcodeSaveCheck},
     {20,gCodeSaveCheck2021},
     {21,gCodeSaveCheck2021},
     {28,gCodeSaveCheck28},
     {30,gCodeSaveCheck30},
     {32,gCodeSaveCheck32},
     {33,gCodeSaveCheck33},
     {40,gCodeSaveCheck404142},
     {41,gCodeSaveCheck404142},
     {42,gCodeSaveCheck404142},
     {50,gCodeSaveCheck50},
     {54,gCodeSaveCheck5x},
     {55,gCodeSaveCheck5x},
     {56,gCodeSaveCheck5x},
     {57,gCodeSaveCheck5x},
     {58,gCodeSaveCheck5x},
     {59,gCodeSaveCheck5x},
     {65,gCodeSaveCheck65},
     {70,gcodeSaveCheck70},
     {71,gcodeSaveCheck71},
     {72,gcodeSaveCheck72},
     {73,gcodeSaveCheck73},
     {74,gcodeSaveCheck7475},
     {75,gcodeSaveCheck7475},
     {76,gcodeSaveCheck76},
     {90,gCodeSaveCheck90},
     {92,gCodeSaveCheck92},
     {94,gCodeSaveCheck94},
     {96,gCodeSaveCheck96},
     {97,gCodeSaveCheck97},
     {98,gCodeSaveCheck98},
     {99,gCodeSaveCheck99}
};
//function to store mcode
Tgcode mcode[MCODE_COUNT]=
{
    {0,generalMcodeSaveCheck},
    {3,generalMcodeSaveCheck},
    {4,generalMcodeSaveCheck},
    {5,generalMcodeSaveCheck},
    {8,generalMcodeSaveCheck},
    {9,generalMcodeSaveCheck},
    {10,generalMcodeSaveCheck},
    {11,generalMcodeSaveCheck},
    {12,generalMcodeSaveCheck},
    {13,generalMcodeSaveCheck},
    {15,generalMcodeSaveCheck},
    {19,generalMcodeSaveCheck},
    {20,generalMcodeSaveCheck},
    {30,generalMcodeSaveCheck},
    {32,generalMcodeSaveCheck},
    {33,generalMcodeSaveCheck},
    {41,generalMcodeSaveCheck},
    {42,generalMcodeSaveCheck},
    {43,generalMcodeSaveCheck},
    {44,generalMcodeSaveCheck},
	{65,generalMcodeSaveCheck},
	//m81-m89is the self def mcode as o9011-9019
    {81,generalMcodeSaveCheck},
    {82,generalMcodeSaveCheck},
    {83,generalMcodeSaveCheck},
    {84,generalMcodeSaveCheck},
    {85,generalMcodeSaveCheck},
    {86,generalMcodeSaveCheck},
    {87,generalMcodeSaveCheck},
    {88,generalMcodeSaveCheck},
    {89,generalMcodeSaveCheck},

    {98,generalMcodeSaveCheck},
    {99,generalMcodeSaveCheck},
};
//function to store hcode
Tgcode hcode[HCODE_COUNT]=
{
    {1,hCodeSaveCheck2OP},
    {2,hCodeSaveCheck3OP},
    {3,hCodeSaveCheck3OP},
    {4,hCodeSaveCheck3OP},
    {5,hCodeSaveCheck3OP},
    {11,hCodeSaveCheck3OP},
    {12,hCodeSaveCheck3OP},
    {13,hCodeSaveCheck3OP},
    {21,hCodeSaveCheck2OP},
    {22,hCodeSaveCheck2OP},
    {23,hCodeSaveCheck3OP},
    {24,hCodeSaveCheck2OP},
    {25,hCodeSaveCheck2OP},
    {26,hCodeSaveCheck3OP},
    {27,hCodeSaveCheck3OP},
    {31,hCodeSaveCheck3OP},
    {32,hCodeSaveCheck3OP},
    {33,hCodeSaveCheck3OP},
    {34,hCodeSaveCheck3OP},
    {80,hCodeSaveCheck1OP},
    {81,hCodeSaveCheck3OP},
    {82,hCodeSaveCheck3OP},
    {83,hCodeSaveCheck3OP},
    {84,hCodeSaveCheck3OP},
    {85,hCodeSaveCheck3OP},
    {86,hCodeSaveCheck3OP},
    {99,hCodeSaveCheck1OP}
};



//********************************************************************
/***************************************************************************
*FUNCTION: passAnnotate
*PARAMETER :string start pointer
*RETURN : -1 if it reach the string end ,or offset value form the given pointer
*DESCRIPTION: this function pass over all the annotate,it search for )
* until found or file end.
****************************************************************************
*/
U8 passAnnotate(U8** strptr)
{
    S32 i=0;
    U8* tempptr=*strptr;
    while((tempptr[i]!=')')&&(tempptr[i]!='\0'))
    {
        i++;
    }
    if(tempptr[i]==')')
    {
        *strptr=(*strptr)+i+1;
        return GERR_OK;
    } else
        return GERR_ANNOTATE;
}
U8 Scan_G65(void)
{
    TcompiledG23 hmacro;
    U8  err=GERR_OK;
    U8  val;
    U8  letter_param[26]={1,2,3,7,8,9,0,11,4,5,6,0,13,0,0,16,17,18,19,20,21,22,23,24,25,26};
    U8  letter_type[26];
    S32 letter_val[26];
    U8  ptype=0,ltype=0;
    S32 pvalue,lvalue;
    U8  type=1;// 1自变量重复使用ijk表示，0使用不重复26字母表示
    U8  inum=0,jnum=0,knum=0;
    memset(letter_type,0,26);
    memset(letter_val,0,26*4);
    memset(&hmacro,0,sizeof(TcompiledG23));
    hmacro.gtype=GCODE_65;
    hmacro.r=1;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;
    gCompiledCt++;
    while(*streamPtr!=0)
    {
        while(*streamPtr==' ')
        {
            streamPtr++;
        }

        val=*streamPtr;
        if(val==' ')
        {
            streamPtr++;
            continue;
        }
        if(((val>='A')&&(val<='Z'))||((val>='a')&&(val<='z')))
        {
            if(val>'Z')
                val=val-'a'+'A';
            streamPtr++;
            err=scanVal();
            if(err!=GERR_OK)
            {
                return err;
            }
            if(val=='P')
            {
                if(ptype!=0)
                {
                    return GERR_WANT_CMD;//这里应该P不能作为自变量传入符(或字母重复)
                }
                pvalue=gparam.value;
                ptype=gparam.type;
            }else if(val=='L')
            {
                if(ltype!=0)
                {
                    return GERR_WANT_CMD;//这里应该L不能作为自变量传入符(或字母重复)
                }
                lvalue=gparam.value;
                ltype=gparam.type;
            }else{
                if((val!='A')&&(val!='B')&&(val!='C')&&(val!='I')&&(val!='J')&&(val!='K'))
                {
                    type = 0;
                }
                if(type==0)
                {
                    if((inum>1)||(jnum>1)||(knum>1))
                    {
                        return GERR_WANT_CMD;//这里应该提示方式1与方式2不能混合使用
                    }
                    if(letter_type[val-'A']==0)
                    {
                        if(gparam.type==GP_TYPE_PARAM)
                        {
                            Macro_Create_Code(letter_param[val-'A'],gparam.value,0,MACRO_ASSIGN);
                        }else if(gparam.type==GP_TYPE_VALUE){
                            valAddTail();
                            Macro_Changeinto_Param(letter_param[val-'A'],gparam.value);
                        }
                        letter_type[val-'A']=gparam.type;
                    }else{
                        return GERR_WANT_CMD;//这里提示方式1自变量使用字母不能重复(或字母重复)
                    }
                }else if(type==1){
                    if((val=='A')||(val=='B')||(val=='C')||((val=='I')&&(inum==0))||((val=='J')&&(jnum==0))||((val=='K')&&(knum==0)))
                    {//ABC只能使用一次
                        if(letter_type[val-'A']==0)
                        {
                            if(gparam.type==GP_TYPE_PARAM)
                            {
                                Macro_Create_Code(letter_param[val-'A'],gparam.value,0,MACRO_ASSIGN);
                            }else if(gparam.type==GP_TYPE_VALUE){
                                valAddTail();
                                Macro_Changeinto_Param(letter_param[val-'A'],gparam.value);
                            }
                            letter_type[val-'A']=gparam.type;
                            if(val=='I')
                            {
                                inum++;
                            }else if(val=='J')
                            {
                                jnum++;
                            }else if(val=='K')
                            {
                                knum++;
                            }
                        }else{
                            return GERR_WANT_CMD;//这里提示方式1自变量使用字母不能重复(或字母重复)
                        }
                    }else{
                        if(val=='I')
                        {
                            if(gparam.type==GP_TYPE_PARAM)
                            {
                                Macro_Create_Code(inum*3+4,gparam.value,0,MACRO_ASSIGN);
                            }else if(gparam.type==GP_TYPE_VALUE){
                                valAddTail();
                                Macro_Changeinto_Param(inum*3+4,gparam.value);
                            }
                            inum++;
                        }
                        if(val=='J')
                        {
                            if(gparam.type==GP_TYPE_PARAM)
                            {
                                Macro_Create_Code(jnum*3+5,gparam.value,0,MACRO_ASSIGN);
                            }else if(gparam.type==GP_TYPE_VALUE){
                                valAddTail();
                                Macro_Changeinto_Param(jnum*3+5,gparam.value);
                            }
                            jnum++;
                        }
                        if(val=='K')
                        {
                            if(gparam.type==GP_TYPE_PARAM)
                            {
                                Macro_Create_Code(knum*3+6,gparam.value,0,MACRO_ASSIGN);
                            }else if(gparam.type==GP_TYPE_VALUE){
                                valAddTail();
                                Macro_Changeinto_Param(knum*3+6,gparam.value);
                            }
                            knum++;
                        }
                        if((inum>9)||(jnum>9)||(knum>9))
                        {
                            return GERR_WANT_CMD;//这里应该提示IJK最多重用10次
                        }
                    }
                }
            }
        }else{
            return GERR_WANT_CMD;
            break;
        }
    }
    memset(&hmacro,0,sizeof(TcompiledG23));
    hmacro.gtype=GCODE_65;
    if(ptype==0)
    {
        return GERR_H_NEEDPARAM;
    }else if(ptype==GP_TYPE_VALUE){
        hmacro.paramType=GXU_IS_VALUE;
    }else if(ptype==GP_TYPE_PARAM){
        hmacro.paramType=GXU_IS_PARAM;
    }else{
        return GERR_H_NEEDPARAM;
    }
    hmacro.xu=pvalue;
    if(ltype==GP_TYPE_VALUE)
    {
        hmacro.paramType|=GZW_IS_VALUE;
        hmacro.zw=lvalue;
    }else if(ltype==GP_TYPE_PARAM){
        hmacro.paramType|=GZW_IS_PARAM;
        hmacro.zw=lvalue;
    }else{
        hmacro.paramType|=GZW_IS_VALUE;
        hmacro.zw=1;
    }
    hmacro.r=2;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;
    gCompiledCt++;
    return err;
}
/***************************************************************************
*FUNCTION: Scan_Macro_Special
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: 处理如IF等特殊宏代码
****************************************************************************
*/
U8 Scan_Macro_Special(void)
{
    U8  err=GERR_OK;
    S16 cmd=0;
    S32 value;
    while(*streamPtr==' ')
    {
        streamPtr++;
    }
    cmd=Scan_Macro_Cmd();
    if(cmd==-1)
    {
        return GERR_UNSUPPORT_OPERATION;
    }
    while(*streamPtr==' ')
    {
        streamPtr++;
    }
    if(cmd==MACRO_IF){
        err=Macro_Scan_Paren(0);
        if(err!=GERR_OK)
        {
            return err;
        }
        if(macro_use_param_num==MACRO_VAR_START)
        {
            return GERR_NEED_OPERAND;
        }
        if(Scan_Macro_Cmd()==MACRO_GOTO)
        {//IF GOTO 语句，无ENDIF，单行处理
            S32 judge;
            judge=macro_use_param_num-1;
            err=Macro_Scan_Paren(0);
            if(err!=GERR_OK)
            {
                return err;
            }
            if(judge==(macro_use_param_num-1))
            {
                return GERR_NEED_OPERAND;
            }
            Macro_Create_Code(macro_use_param_num,judge,macro_use_param_num-1,MACRO_IF_GOTO);
        }else{
            if(macro_if_layer>=MACRO_IF_LAYER_MAX)
            {
                return GERR_IF_OVERSTEP;
            }
            errifsrcline=srcline;
            macro_if_layer++;
            Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,gCompiledCt,MACRO_JUDGE_JUMP);
            if(macro_if_layer>1)
            {//现时只为第一层则不需要记录已有else数
                macro_if_stack_index_temp[macro_if_layer-2]=macro_if_stack_index;
            }
            macro_if_stack_index=0;
            macro_if_stack[macro_if_layer-1][macro_if_stack_index].thisct=gCompiledCt-1;//记录本条位置，macro_if_stack_index在记录完下条位置后加1
        }
    }else if(cmd==MACRO_ELSEIF){
        if(macro_if_layer==0)
        {
            return GERR_IF_LACK_IF;
        }
        Macro_Create_Code(macro_use_param_num,macro_use_param_num,gCompiledCt,MACRO_JUMP);//在每条else前添加跳到终点代码，即只有曾为真就跳到终点
        macro_if_stack[macro_if_layer-1][macro_if_stack_index++].nextct=gCompiledCt;//下条位置用于上调跳到，必须在搜索本条运算式前记录
        err=Macro_Scan_Paren(0);
        if(err!=GERR_OK)
        {
            return err;
        }
        if(macro_use_param_num==MACRO_VAR_START)
        {
            return GERR_NEED_OPERAND;
        }
        Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,gCompiledCt,MACRO_JUDGE_JUMP);
        macro_if_stack[macro_if_layer-1][macro_if_stack_index].thisct=gCompiledCt-1;
    }else if(cmd==MACRO_ELSE){
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr!=0)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }
        if(macro_if_layer==0)
        {
            return GERR_IF_LACK_IF;
        }
        Macro_Create_Code(macro_use_param_num,macro_use_param_num,gCompiledCt,MACRO_JUMP);
        macro_if_stack[macro_if_layer-1][macro_if_stack_index++].nextct=gCompiledCt;
        Macro_Create_Code(macro_use_param_num,macro_use_param_num,gCompiledCt,MACRO_NOP);
        macro_if_stack[macro_if_layer-1][macro_if_stack_index].thisct=gCompiledCt-1;
    }else if(cmd==MACRO_ENDIF){
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr!=0)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }
        if(macro_if_layer==0)
        {
            return GERR_IF_LACK_IF;
        }
        {
            PcompiledG23 hmacro;
            U8 i;
            for(i=0;i<macro_if_stack_index;i++)
            {//修改除最后一条外每条if或else跳到的下条位置
                hmacro=&(compiledGbuf[macro_if_stack[macro_if_layer-1][i].thisct]);
                hmacro->r=macro_if_stack[macro_if_layer-1][i].nextct;
            }
            //最后一条无下条位置，为假则跳到终点
            hmacro=&(compiledGbuf[macro_if_stack[macro_if_layer-1][macro_if_stack_index].thisct]);
            hmacro->r=gCompiledCt;
            for(i=0;i<macro_if_stack_index;i++)
            {//在除第一条外每条else前添加跳到终点的代码
                hmacro=&(compiledGbuf[macro_if_stack[macro_if_layer-1][i].nextct-1]);
                hmacro->r=gCompiledCt;
            }
        }
        macro_if_layer--;
        if(macro_if_layer!=0)
        {//当前end不是第一层，恢复上一层macro_if_stack_index
            macro_if_stack_index=macro_if_stack_index_temp[macro_if_layer-1];
        }
    }else if(cmd==MACRO_WHILE_START){
        if(macro_if_layer>=MACRO_IF_LAYER_MAX)
        {
            return GERR_LOOP_OVER;
        }
        macro_while_layer++;
        macro_while_stack[macro_while_layer-1].nextct=gCompiledCt;//记录start位置
        err=Macro_Scan_Paren(0);
        if(err!=GERR_OK)
        {
            return err;
        }
        if(macro_use_param_num==MACRO_VAR_START)
        {
            return GERR_NEED_OPERAND;
        }
        errwhilesrcline=srcline;
        macro_while_stack[macro_while_layer-1].thisct=gCompiledCt;
        Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,gCompiledCt,MACRO_JUDGE_JUMP);
        //此条代码需跳到end位置，但此时end位置未知，记录此条代码位置，待end时处理
    }else if(cmd==MACRO_WHILE_END){
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr!=0)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }
        if(macro_while_layer==0)
        {
            return GERR_LOOP_LACK_START;
        }else{
            PcompiledG23 hmacro;
            U8 i;
            //结尾必定跳到开头，因为如为假则不会经过此条而跳到下一条
            Macro_Create_Code(macro_use_param_num,macro_use_param_num,macro_while_stack[macro_while_layer-1].nextct,MACRO_JUMP);
            hmacro=&(compiledGbuf[macro_while_stack[macro_while_layer-1].thisct]);
            hmacro->r=gCompiledCt;
            macro_while_layer--;
            for(i=0;i<macro_exit_index;i++)
            {//处理此次循环中所有exit
                hmacro=&(compiledGbuf[macro_exit_buf[i]]);
                hmacro->r=gCompiledCt;
            }
            macro_exit_index=0;
        }
    }else if(cmd==MACRO_EXIT){
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr!=0)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }
        if(macro_while_layer==0)
        {
            return GERR_LOOP_LACK_START;
        }
        macro_exit_buf[macro_exit_index]=gCompiledCt;//记录exit位置，待end处理
        macro_exit_index++;
        Macro_Create_Code(macro_use_param_num,macro_use_param_num,gCompiledCt,MACRO_JUMP);
    }else if(cmd==MACRO_REPEAT){
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr!=0)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }
        if(macro_if_layer>=MACRO_IF_LAYER_MAX)
        {
            return GERR_LOOP_OVER;
        }
        macro_while_layer++;
        macro_while_stack[macro_while_layer-1].nextct=gCompiledCt;
        errwhilesrcline=srcline;
    }else if(cmd==MACRO_UNTIL){
        PcompiledG23 hmacro;
        U8 i;
        err=Macro_Scan_Paren(0);
        if(macro_while_layer==0)
        {
            return GERR_LOOP_LACK_START;
        }
        if(err!=GERR_OK)
        {
            return err;
        }
        if(macro_use_param_num==MACRO_VAR_START)
        {
            return GERR_NEED_OPERAND;
        }
        Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,macro_while_stack[macro_while_layer-1].nextct,MACRO_JUDGE_JUMP);
        macro_while_layer--;
        for(i=0;i<macro_exit_index;i++)
        {
            hmacro=&(compiledGbuf[macro_exit_buf[i]]);
            hmacro->r=gCompiledCt;
        }
        macro_exit_index=0;
    }else if(cmd==MACRO_FOR){//for的end直接使用while的end
        S32 useparam,startnum,endnum,plusnum;
        PcompiledG23 prevcode;
        U32 firstjumpct;
        if(macro_while_layer>=MACRO_IF_LAYER_MAX)
        {
            return GERR_LOOP_OVER;
        }
        macro_while_layer++;
        err=Macro_Scan_Paren(0);//搜索for和to之间的运算式
        //读取最后一条生成的代码，以得到最新变量，由于=的存在，最新变量不一定是macro_use_param_num
        prevcode=&(compiledGbuf[gCompiledCt-1]);
        if(err!=GERR_OK)
        {
            return err;
        }
        if(macro_use_param_num==MACRO_VAR_START)
        {
            return GERR_NEED_OPERAND;
        }
        useparam=prevcode->xu;
        if(useparam>=MACRO_VAR_START)
        {//若最新变量是临时变量，则需转存到不会更改的变量位置
            if(useparam>9000)
            {//处理#[]这种形式
                useparam=MACRO_VAR_END-macro_while_layer+9000;
                Macro_Create_Code(MACRO_VAR_END-macro_while_layer,prevcode->xu-9000,0,MACRO_ASSIGN);
            }else{
                useparam=MACRO_VAR_END-macro_while_layer;
                Macro_Create_Code(useparam,prevcode->xu,0,MACRO_ASSIGN);
            }
        }
        cmd=Scan_Macro_Cmd();
        if(cmd!=MACRO_TO)
        {
            return GERR_FOR_LACK_TO;
        }
        //Macro_Create_Code(useparam,startnum,macro_while_layer,MACRO_FOR);
        err=Macro_Scan_Paren(0);
        if(err!=GERR_OK)
        {
            return err;
        }
        //to和by后面运算式的结果只计算一次，并存放到不会更改的变量位置
        endnum=MACRO_VAR_END-macro_while_layer-MACRO_IF_LAYER_MAX;;
        Macro_Create_Code(endnum,macro_use_param_num-1,0,MACRO_ASSIGN);
        cmd=Scan_Macro_Cmd();
        plusnum=MACRO_VAR_END-macro_while_layer-MACRO_IF_LAYER_MAX*2;
        if(cmd==MACRO_BY)
        {
            err=Macro_Scan_Paren(0);
            if(err!=GERR_OK)
            {
                return err;
            }
            Macro_Create_Code(plusnum,macro_use_param_num-1,0,MACRO_ASSIGN);
        }else{//省略by的情况
            S32 temp;
            switch(sysUnit)
            {
                case(0): //input is meter 3 tail digit
                    temp=1000;
                    break;
                case(1): //input is meter 4 tail digit
                    temp=10000;
                    break;
                default:
                    temp=1000;
                    break;
            }
            Macro_Changeinto_Param(plusnum,temp);
        }
        errwhilesrcline=srcline;
        firstjumpct=gCompiledCt;
        Macro_Create_Code(macro_use_param_num,macro_use_param_num,gCompiledCt+2,MACRO_JUMP);
        macro_while_stack[macro_while_layer-1].nextct=gCompiledCt;
        Macro_Create_Code(useparam,useparam,plusnum,MACRO_PLUS);
        Macro_Create_Code(macro_use_param_num++,useparam,endnum,MACRO_LESSOREQUAL);
        macro_while_stack[macro_while_layer-1].thisct=gCompiledCt;
        Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,gCompiledCt,MACRO_JUDGE_JUMP);
    }else if(cmd==MACRO_WAIT){
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr!=0)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }
        Macro_Create_Code(macro_use_param_num,macro_use_param_num,0,cmd);
    }else if(cmd>MACRO_SPECIAL){
        err=Macro_Scan_Paren(0);
        if(err!=GERR_OK)
        {
            return err;
        }
        if(macro_use_param_num==MACRO_VAR_START)
        {
            Macro_Create_Code(macro_use_param_num,macro_use_param_num,0,cmd);
        }else{
            Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,0,cmd);
        }
    }else{
        return err=GERR_UNSUPPORT_OPERATION;
    }
    //err=GERR_STR_END;
    while(*streamPtr!=0)
    {
        streamPtr++;
    }
    return err=GERR_CODE_DONE;
}
S16 Scan_Macro_Cmd(void)
{//判断操作符
    char cmd[20];
    while(*streamPtr==' ')
    {
        streamPtr++;
    }
    memcpy(cmd,streamPtr,20);
    if(strncmp(cmd,"==",2)==0)
    {
        streamPtr+=2;
        return MACRO_EQUAL;
    }else if(strncmp(cmd,"<=",2)==0){
        streamPtr+=2;
        return MACRO_LESSOREQUAL;
    }else if(strncmp(cmd,">=",2)==0){
        streamPtr+=2;
        return MACRO_GREATEROREQUAL;
    }else if(strncmp(cmd,"<>",2)==0){
        streamPtr+=2;
        return MACRO_NOTEQUAL;
    }else if(strncmp(cmd,"!=",2)==0){
        streamPtr+=2;
        return MACRO_NOTEQUAL;
    }else if(cmd[0]=='<'){
        streamPtr++;
        return MACRO_LESSTHAN;
    }else if(cmd[0]=='>'){
        streamPtr++;
        return MACRO_GREATERTHAN;
    }else if(cmd[0]==','){
        streamPtr++;
        return MACRO_COMMA;
    }else if(strncmp(cmd,"**",2)==0){
        streamPtr+=2;
        return MACRO_POW;
    }else if(strncmp(cmd,":=",2)==0){
        streamPtr+=2;
        return MACRO_ASSIGN;
    }else if(cmd[0]=='='){
        streamPtr++;
        return MACRO_ASSIGN;
    }else if(cmd[0]=='+'){
        streamPtr++;
        return MACRO_PLUS;
    }else if(cmd[0]=='-'){
        streamPtr++;
        return MACRO_MINUS;
    }else if(cmd[0]=='*'){
        streamPtr++;
        return MACRO_MULTIPLY;
    }else if(cmd[0]=='/'){
        streamPtr++;
        return MACRO_DIVIDE;
    }else if(cmd[0]=='!'){
        streamPtr++;
        return MACRO_NOT;
    }else if(strncmp(cmd,"&&",2)==0){
        streamPtr+=2;
        return MACRO_AND;
    }else if(strncmp(cmd,"||",2)==0){
        streamPtr+=2;
        return MACRO_OR;
    }else if(strncmp(cmd,"OR",2)==0){
        streamPtr+=2;
        return MACRO_BIT_OR;
    }else if(cmd[0]=='|'){
        streamPtr++;
        return MACRO_BIT_OR;
    }else if(strncmp(cmd,"XOR",3)==0){
        streamPtr+=3;
        return MACRO_BIT_XOR;
    }else if(cmd[0]=='^'){
        streamPtr++;
        return MACRO_BIT_XOR;
    }else if(strncmp(cmd,"AND",3)==0){
        streamPtr+=3;
        return MACRO_BIT_AND;
    }else if(cmd[0]=='&'){
        streamPtr++;
        return MACRO_BIT_AND;
    }else if(strncmp(cmd,"NOT",3)==0){
        streamPtr+=3;
        return MACRO_BIT_NOT;
    }else if(cmd[0]=='~'){
        streamPtr++;
        return MACRO_BIT_NOT;
    }else if(strncmp(cmd,"SQRT",4)==0){
        streamPtr+=4;
        return MACRO_SQRT;
    }else if(strncmp(cmd,"ABS",3)==0){
        streamPtr+=3;
        return MACRO_ABS;
    }else if(strncmp(cmd,"ROUND",5)==0){
        streamPtr+=5;
        return MACRO_ROUND;
    }else if(strncmp(cmd,"FIX",3)==0){
        streamPtr+=3;
        return MACRO_FIX;
    }else if(strncmp(cmd,"FLOOR",5)==0){
        streamPtr+=5;
        return MACRO_FLOOR;
    }else if(strncmp(cmd,"FUP",3)==0){
        streamPtr+=3;
        return MACRO_FUP;
    }else if(strncmp(cmd,"CEIL",4)==0){
        streamPtr+=4;
        return MACRO_CEIL;
    }else if(strncmp(cmd,"LN",2)==0){
        streamPtr+=2;
        return MACRO_LN;
    }else if(strncmp(cmd,"EXP",3)==0){
        streamPtr+=3;
        return MACRO_EXP;
    }else if(strncmp(cmd,"MOD",3)==0){
        streamPtr+=3;
        return MACRO_MOD;
    }else if(cmd[0]=='%'){
        streamPtr++;
        return MACRO_MOD;
    }else if(strncmp(cmd,"SIN",3)==0){
        streamPtr+=3;
        return MACRO_SIN;
    }else if(strncmp(cmd,"COS",3)==0){
        streamPtr+=3;
        return MACRO_COS;
    }else if(strncmp(cmd,"TAN",3)==0){
        streamPtr+=3;
        return MACRO_TAN;
    }else if(strncmp(cmd,"ASIN",4)==0){
        streamPtr+=4;
        return MACRO_ASIN;
    }else if(strncmp(cmd,"ACOS",4)==0){
        streamPtr+=4;
        return MACRO_ACOS;
    }else if(strncmp(cmd,"ATAN",4)==0){
        streamPtr+=4;
        return MACRO_ATAN;
    }else if(strncmp(cmd,"LE",2)==0){
        streamPtr+=2;
        return MACRO_LESSOREQUAL;
    }else if(strncmp(cmd,"GE",2)==0){
        streamPtr+=2;
        return MACRO_GREATEROREQUAL;
    }else if(strncmp(cmd,"EQ",2)==0){
        streamPtr+=2;
        return MACRO_EQUAL;
    }else if(strncmp(cmd,"NE",2)==0){
        streamPtr+=2;
        return MACRO_NOTEQUAL;
    }else if(strncmp(cmd,"LT",2)==0){
        streamPtr+=2;
        return MACRO_LESSTHAN;
    }else if(strncmp(cmd,"GT",2)==0){
        streamPtr+=2;
        return MACRO_GREATERTHAN;
    }else if(strncmp(cmd,"GOTO",4)==0){
        streamPtr+=4;
        return MACRO_GOTO;
    }else if(strncmp(cmd,"ALARM",5)==0){
        streamPtr+=5;
        return MACRO_ALARM;
    }else if(strncmp(cmd,"SIGN",4)==0){
        streamPtr+=4;
        return MACRO_SIGN;
    }else if(strncmp(cmd,"WAIT",4)==0){
        streamPtr+=4;
        return MACRO_WAIT;
    }else if(strncmp(cmd,"IF",2)==0){
        streamPtr+=2;
        return MACRO_IF;
    }else if(strncmp(cmd,"ELSEIF",6)==0){
        streamPtr+=6;
        return MACRO_ELSEIF;
    }else if(strncmp(cmd,"ELSE",4)==0){
        streamPtr+=4;
        return MACRO_ELSE;
    }else if(strncmp(cmd,"ENDIF",5)==0){
        streamPtr+=5;
        return MACRO_ENDIF;
    }else if(strncmp(cmd,"END_IF",6)==0){
        streamPtr+=6;
        return MACRO_ENDIF;
    }else if(strncmp(cmd,"WHILE",5)==0){
        streamPtr+=5;
        return MACRO_WHILE_START;
    }else if(strncmp(cmd,"ENDWHILE",8)==0){
        streamPtr+=8;
        return MACRO_WHILE_END;
    }else if(strncmp(cmd,"END_WHILE",9)==0){
        streamPtr+=9;
        return MACRO_WHILE_END;
    }else if(strncmp(cmd,"ENDW",4)==0){
        streamPtr+=4;
        return MACRO_WHILE_END;
    }else if(strncmp(cmd,"REPEAT",6)==0){
        streamPtr+=6;
        return MACRO_REPEAT;
    }else if(strncmp(cmd,"UNTIL",5)==0){
        streamPtr+=5;
        return MACRO_UNTIL;
    }else if(strncmp(cmd,"FOR",3)==0){
        streamPtr+=3;
        return MACRO_FOR;
    }else if(strncmp(cmd,"TO",2)==0){
        streamPtr+=2;
        return MACRO_TO;
    }else if(strncmp(cmd,"BY",2)==0){
        streamPtr+=2;
        return MACRO_BY;
    }else if(strncmp(cmd,"ENDFOR",6)==0){
        streamPtr+=6;
        return MACRO_WHILE_END;
    }else if(strncmp(cmd,"END_FOR",7)==0){
        streamPtr+=7;
        return MACRO_WHILE_END;
    }else if(strncmp(cmd,"ENDF",4)==0){
        streamPtr+=4;
        return MACRO_WHILE_END;
    }else if(strncmp(cmd,"EXIT",4)==0){
        streamPtr+=4;
        return MACRO_EXIT;
    }else if(strncmp(cmd,"BREAK",5)==0){
        streamPtr+=5;
        return MACRO_EXIT;
    }else if(strncmp(cmd,"MAX",3)==0){
        streamPtr+=3;
        return MACRO_MAX;
    }else if(strncmp(cmd,"MIN",3)==0){
        streamPtr+=3;
        return MACRO_MIN;
    }
    return -1;
}
//运算式转换为代码，入口不为0则搜索到右括号结束
//以macro_use_param_num存放最新临时变量
U8 Macro_Scan_Paren(U8 layer)
{
    U8  err=GERR_OK,bufindex=0,i,j,k;
    S16 cmd=0;
    S16 macro_cmd[100]={0,};//存放二元运算符
    S32 macro_var[100]={0,};//存放操作数，数量必定比运算符少1
    memset(macro_var,0,100*4);
    while(1)
    {
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        err=scanVal();//下一个内容应为操作数，若此操作数为括号，scanVal函数内会以1为入口调用Macro_Scan_Paren
        if(err==GERR_OK)
        {//此处把每个操作数都存到最新macro_use_param_num中，已适用整个运算式只有一个操作数的情况
            if(gparam.type&GP_TYPE_VALUE)
            {//为方便操作，所有立即数转存为变量
                valAddTail();
                Macro_Changeinto_Param(macro_use_param_num,gparam.value);
                macro_var[bufindex]=macro_use_param_num++;
            }else{
                Macro_Create_Code(macro_use_param_num++,gparam.value,0,MACRO_ASSIGN);
                macro_var[bufindex]=gparam.value;
            }
        }
GETCMD:
        while(*streamPtr==' ')
        {
            streamPtr++;
        }
        if(*streamPtr==']')
        {
            streamPtr++;
            if(layer==0)
            {
                return GERR_LACK_LEFT_BRACKET;
            }else{
                break;
            }
        }
        if(*streamPtr==0)
        {
            if(layer!=0)
            {
                return GERR_LACK_RIGHT_BRACKET;
            }else{
                break;
            }
        }
        cmd=Scan_Macro_Cmd();
        if(cmd==-1)
        {
            return GERR_UNSUPPORT_OPERATION; //wrong character
        }else if(cmd==MACRO_BY){ //以下几个都是同一行中的分段符
            streamPtr-=2;
            break;
        }else if(cmd==MACRO_TO){
            streamPtr-=2;
            break;
        }else if(cmd==MACRO_GOTO){
            streamPtr-=4;
            break;
        }else if(cmd==MACRO_COMMA){
            streamPtr-=1;
            break;
        }else if((cmd==MACRO_MAX)||(cmd==MACRO_MIN)){ //此处处理多元运算符
            U8 curcmd=cmd;
            while(*streamPtr==' ')
            {
                streamPtr++;
            }
            if(*streamPtr!='[')
            {//多元运算符后必须跟[
                return GERR_LACK_LEFT_BRACKET;
            }else{
                S32 firstparam;
                U8* prevPtr;
                streamPtr++;
                err=Macro_Scan_Paren(1);
                if(err!=GERR_OK)
                {
                    return err;
                }
                firstparam=macro_use_param_num-1;
                cmd=Scan_Macro_Cmd();
                if(cmd!=MACRO_COMMA)
                {
                    return GERR_LACK_COMMA;
                }
                err=Macro_Scan_Paren(1);
                if(err!=GERR_OK)
                {
                    return err;
                }
                Macro_Create_Code(macro_use_param_num,firstparam,macro_use_param_num-1,curcmd);
                firstparam=macro_use_param_num++;
                while(1)
                {
                    prevPtr = streamPtr;
                    cmd=Scan_Macro_Cmd();
                    if(cmd==MACRO_COMMA)
                    {
                        err=Macro_Scan_Paren(1);
                        if(err!=GERR_OK)
                        {
                            return err;
                        }
                        Macro_Create_Code(macro_use_param_num,firstparam,macro_use_param_num-1,curcmd);
                        firstparam=macro_use_param_num++;
                    }else{
                        streamPtr = prevPtr;
                        break;
                    }
                }
                macro_var[bufindex]=firstparam;
            }
            goto GETCMD;
        }else if(MACRO_IS_UNARY_OPERATOR(cmd)){  //一元运算符
            err=scanVal();
            if(err!=GERR_OK)
            {
                return err;
            }else{
                if(gparam.type&GP_TYPE_VALUE)
                {
                    valAddTail();
                    Macro_Changeinto_Param(macro_use_param_num++,gparam.value);
                }else{
                    Macro_Create_Code(macro_use_param_num++,gparam.value,0,MACRO_ASSIGN);
                }
            }
            Macro_Create_Code(macro_use_param_num,macro_use_param_num-1,0,cmd);
            macro_var[bufindex]=macro_use_param_num++;
            goto GETCMD;//直接把运算符和后面一个操作数结合生成一个操作数
        }else if(cmd>MACRO_SPECIAL){  //运算式中不能含有特殊代码
            return GERR_UNSUPPORT_OPERATION;
        }else{
            macro_cmd[bufindex++]=cmd;//剩下的都是二元运算符
        }
    }
    if(bufindex==0)
    {
        return GERR_OK;
    }
    for(i=0;i<=bufindex;i++)
    {//检查每两个二元运算符间都有一个操作数
        if(macro_var[i]==0)
        {
            return GERR_NEED_OPERAND;
        }
    }
    //以下为按优先级结合
    for(i=0;i<bufindex;i++)
    {
        if(macro_cmd[i]==MACRO_POW)
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if((macro_cmd[i]==MACRO_MULTIPLY)||(macro_cmd[i]==MACRO_DIVIDE)||(macro_cmd[i]==MACRO_MOD))
        {
            j=1;
            while((macro_cmd[i+j]==MACRO_MULTIPLY)||(macro_cmd[i+j]==MACRO_DIVIDE)||(macro_cmd[i+j]==MACRO_MOD))
            {//同一优先级，一起结合
                j++;
            }
            for(k=1;k<=j;k++)
            {
                Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+k],macro_cmd[i+k-1]);
                macro_var[i]=macro_use_param_num++;
            }
            for(k=0;i+k+j<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+j+1];
                macro_var[i+k+j+1]=0;
                macro_cmd[i+k]=macro_cmd[i+k+j];
                macro_cmd[i+k+j]=0;
            }
            bufindex-=j;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if((macro_cmd[i]==MACRO_PLUS)||(macro_cmd[i]==MACRO_MINUS))
        {
            j=1;
            while((macro_cmd[i+j]==MACRO_PLUS)||(macro_cmd[i+j]==MACRO_MINUS))
            {
                j++;
            }
            for(k=1;k<=j;k++)
            {
                Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+k],macro_cmd[i+k-1]);
                macro_var[i]=macro_use_param_num++;
            }
            for(k=0;i+k+j<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+j+1];
                macro_var[i+k+j+1]=0;
                macro_cmd[i+k]=macro_cmd[i+k+j];
                macro_cmd[i+k+j]=0;
            }
            bufindex-=j;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if((macro_cmd[i]==MACRO_LESSTHAN)||(macro_cmd[i]==MACRO_LESSOREQUAL)||(macro_cmd[i]==MACRO_GREATERTHAN)||(macro_cmd[i]==MACRO_GREATEROREQUAL))
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if(macro_cmd[i]==MACRO_EQUAL)
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if(macro_cmd[i]==MACRO_NOTEQUAL)
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if(macro_cmd[i]==MACRO_BIT_AND)
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if(macro_cmd[i]==MACRO_BIT_XOR)
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if(macro_cmd[i]==MACRO_BIT_OR)
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=0;i<bufindex;i++)
    {
        if((macro_cmd[i]==MACRO_OR)||(macro_cmd[i]==MACRO_AND))
        {
            Macro_Create_Code(macro_use_param_num,macro_var[i],macro_var[i+1],macro_cmd[i]);
            macro_var[i]=macro_use_param_num++;
            for(k=0;i+k+1<bufindex;k++)
            {
                macro_var[i+k+1]=macro_var[i+k+2];
                macro_var[i+k+2]=0;
                macro_cmd[i+k]=macro_cmd[i+k+1];
                macro_cmd[i+k+1]=0;
            }
            bufindex-=1;
            i=0;
        }
    }
    for(i=bufindex;i>0;i--)
    {//赋值运算从右到左结合
        if(macro_cmd[i-1]==MACRO_ASSIGN)
        {
            Macro_Create_Code(macro_var[i-1],macro_var[i],0,macro_cmd[i-1]);
        }
    }
    return GERR_OK;
}

U8 Macro_Changeinto_Param(S32 param,S32 val)
{//把直接数转化成临时变量
    TcompiledG23 hmacro;

    memset(&hmacro,0,sizeof(TcompiledG23));
    hmacro.gtype=(MACRO_ASSIGN<<8)|0x71;
    hmacro.paramType=(P_IS_PARAM|Q_IS_VALUE);
    hmacro.xu=param;
    hmacro.zw=val;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;
    gCompiledCt++;
    return GERR_OK;
}
U8 Macro_Create_Code(S32 result,S32 val1,S32 val2,U8 cmd)
{//根据操作符生成代码
    TcompiledG23 hmacro;

    memset(&hmacro,0,sizeof(TcompiledG23));
    hmacro.gtype=(cmd<<8)|0x71;
    if(cmd==MACRO_ASSIGN)
    {
        hmacro.paramType=(P_IS_PARAM|Q_IS_PARAM|R_IS_VALUE);
    }else if((MACRO_IS_DYADIC_OPERATOR(cmd))||(cmd==MACRO_IF_GOTO)){
        hmacro.paramType=(P_IS_PARAM|Q_IS_PARAM|R_IS_PARAM);
    }else{
        hmacro.paramType=(P_IS_PARAM|Q_IS_PARAM|R_IS_VALUE);
    }
    hmacro.xu=result;
    hmacro.zw=val1;
    hmacro.r=val2;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: scanParam
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function scan in gcode for a key word and it's param value
* value make be a #parmeter form,
****************************************************************************
*/
U8 scanParam(void)
{
    U8 err;
    //TkeyWordBuf tempKeyword;
    err=scanParamName();
    if(err!=GERR_OK)
    goto ERR_END;
    //get the param digit value
    err=gkeywordVal[gparam.index].func();
    if(err!=GERR_OK)
        goto ERR_END;
    //get check if the value of
    err=gkeywordCheck[gparam.index].func();
    if(err!=GERR_OK)
        goto ERR_END;
STORE_PREV:
    err=gkeywordStore[gparam.index].func();
    if(err!=GERR_OK)
    {
        goto ERR_END;  //it may return GERR_CODE_DONE; and end this g code scan
    }
    if(*streamPtr==0)
    {
        err=GERR_CODE_DONE;
        goto ERR_END;
    }
//OK_END:
    return GERR_OK;
ERR_END:
    return err;

}

/***************************************************************************
*FUNCTION: scanCMD
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: scan cmd in GCODE KEY WORD list library
****************************************************************************
*/
U8 scanParamName(void)
{
    U32 i;
    U8 err;
    while(*streamPtr!=0)
    {
        err=scanCHR();
        if(err!=GERR_OK)
        {
            if((err==GERR_STR_END)||(err==GERR_CODE_DONE))
            {
                break;
            }
            return err; //error
        }
        for(i=0;i<GKEYWORD_COUNT;i++)
        {
            if(gparam.name==gkeywordVal[i].name)
            {
                gparam.index=i;
                return GERR_OK;
            }
        }
        return GERR_GCMD_UNKNOW;
    }
    return GERR_CODE_DONE;
}

/***************************************************************************
*FUNCTION: scanCHR
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: scan a char in g code sourcde, store in var cmd
****************************************************************************
*/
U8 scanCHR(void)
{

    U8 err;
    char val;
    while(*streamPtr!=0)
    {
        val=*streamPtr;
        if(val==' ')
        {
            streamPtr++;
             continue;
        }
        if(((val>='A')&&(val<='Z'))||((val>='a')&&(val<='z')))
        {
            gparam.name=val;
            if(gparam.name>'Z')
                gparam.name=val-'a'+'A';
            streamPtr++;
            goto OK_END;
        }
        err=GERR_WANT_CMD; //wrong character
        goto ERR_END;
    }
    //err=GERR_STR_END;
    err=GERR_CODE_DONE;
ERR_END:
    return err;
OK_END:
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: scanHEX
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function get a valide digit HEX number, it use in param
****************************************************************************
* /
U8 scanHex(U32 *result)
{
    U32 val=0;
    U8 chr,ct;
    ct=0;
    while(*streamPtr!=0)
    {
        chr=*streamPtr;
        if((chr>='0')&&(chr<='9'))
        {
            chr=chr-'0';
        }else if((chr>='A')&&(chr<='F'))
        {
            chr=10+chr-'A';
        }else{
            return GERR_VALUE_INVALID;
        }
        val=(val<<4)+chr;
        ct++;
        if(ct>=8)
        {
            return GERR_VALUE_INVALID;
        }
        streamPtr++;
    }
    if(ct==0)
    {
        return GERR_VALUE_INVALID;
    }
    *result=val;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: scanGMnum
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function get a valide digit number for g code source
****************************************************************************
*/
U8 scanDigit(void)
{
    char val;
    U8 err=0,type;
    //U8 hasnum=0;
    S32 number=0;
    S8 sign=1;
    S8 allowTail=3;
    gparam.type=GP_TYPE_HIRE;
    gparam.digitlen=0;
    gparam.taillen=-1;
    while(*streamPtr!=0)
    {
        val=*streamPtr;
        if(val==' ')
        {
            if(gparam.digitlen==0)
                goto CONTINUE;
            else
                goto OK_END;
        }
        //it may be a param index
        if(val=='#')
        {
            if((gparam.digitlen==0)&&(gparam.type==GP_TYPE_HIRE))
            {
                gparam.type=GP_TYPE_PARAM;
                goto CONTINUE;
            }else{
                goto OK_END;
            }
        }
        if(val=='-')
        {
            if((gparam.digitlen==0)&&(gparam.type==GP_TYPE_HIRE))
            {
                sign=-1;
                goto CONTINUE;
            }else{
                goto OK_END;
            }
        }
        if(val=='[')
        {
            if(gparam.digitlen==0)
            {
                type=gparam.type;
                streamPtr++;
                Macro_Scan_Paren(1);
                if(type==GP_TYPE_HIRE)
                {
                    number=macro_use_param_num-1;
                    gparam.type=GP_TYPE_PARAM;
                }else if(type==GP_TYPE_PARAM){
                    number=macro_use_param_num-1+9000;
                    gparam.type=GP_TYPE_PARAM;
                }
                goto OK_END;
            }else{
                err=GERR_VALUE_INVALID;
                goto ERR_END;
            }
        }
        if(val=='.')
        {
            if(gparam.taillen<0)
            {
                gparam.taillen++;
                goto CONTINUE;
            }else
            {   //can't have two - in one number
                err=GERR_VALUE_INVALID;
                goto ERR_END;
            }
        }
        if((val>='0')&&(val<='9'))
        {

            gparam.digitlen++;
            if(gparam.digitlen>MAX_DIGIT_LEN)
            {
                err=GERR_NUM_TOOLONG;
                goto ERR_END;
            }
            if(gparam.taillen<compileDigit)
                number=number*10+val-'0'; //if taillen >=4 ,ignore digits
            if(gparam.taillen>=0)
                gparam.taillen++;
            goto CONTINUE;
        }
        if(gparam.digitlen==0)
        {
            err=GERR_WANT_VAL;
            goto ERR_END;
        }else
            goto OK_END;
CONTINUE:
        streamPtr++;
        continue;
    }

    if(gparam.digitlen>0)
        goto OK_END;
    err=GERR_WANT_VAL;
ERR_END:
    return err;
OK_END:
    if(gparam.type==GP_TYPE_HIRE)
    {
        gparam.type=GP_TYPE_VALUE;
    }
    gparam.value=sign*number;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: scanGMnum
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function get a valide digit number as G M H code
*  it accept only 2 bit no decimal positive number
****************************************************************************
*/
U8 scanGMHnum(void)
{
    U8 err=0;
    err=scanDigit();
    if(err!=GERR_OK)
        goto ERR_END;
    if((gparam.digitlen>2)||(gparam.taillen>=0)||(gparam.value<0))
    {
        err=GERR_GCMD_UNKNOW;
        goto ERR_END;
    }
    goto OK_END;
    //err=GERR_STR_END;   //it can't be line end of str end while search g m number
ERR_END:
    return err;
OK_END:
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: scanValS
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function get a valide digit number as any kind
****************************************************************************
*/
U8 scanVal(void)
{
    U8 err;

    err=scanDigit();
    if((err==GERR_OK)||(err==GERR_STR_END))
    {
        if(gparam.digitlen==0)
        {
            return GERR_WANT_VAL;
        }else if(gparam.type==GP_TYPE_PARAM)
        {
            return GERR_OK;
        }else{
            if((gparam.taillen>=0)&&(gparam.taillen<compileDigit)&&(gparam.value!=0))
            {
                for(err=compileDigit-gparam.taillen;err>0;err--)
                    gparam.value=gparam.value*10;
            }
            return GERR_OK;
        }
    }
    return err;
}
/***************************************************************************
*FUNCTION: scanValS
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function get a valide positive digit number
****************************************************************************
*/
U8 scanValP(void)
{

    U8 err;
    err=scanVal();
    if((err==GERR_OK)||(err==GERR_STR_END))
    {
        if((gparam.value<0)||(gparam.taillen>=0))
            return GERR_VALUE_INVALID;
        else
            return GERR_OK;
    }
    return err;
}
/***************************************************************************
*FUNCTION: scanValS
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function get a valide digit number of spindle speed,
* it accept a positive number with only one bit of decimal
****************************************************************************
*/
U8 scanValS(void)
{
    U8 err;
    err=scanDigit();
    if((err==GERR_OK)||(err==GERR_STR_END))
    {
        if((gparam.digitlen==0)||(gparam.value<=0)||(gparam.taillen>0))
        {
            err=GERR_VALUE_INVALID;
            goto ERR_END;
        }else if(gparam.type==GP_TYPE_PARAM)
        {
            return GERR_OK;
        }else{
            gparam.value=gparam.value*10;

            return GERR_OK;
        }
    }
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION:checkGindex
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: find the g code index
****************************************************************************
*/
U8 checkGindex(U8 val)
{
    U32 i;
    for(i=0;i<GCODE_COUNT;i++)
    {
        if(val==gcode[i].name)
        {
            break;
        }
    }
    return i;
}
/***************************************************************************
*FUNCTION: checkGnum
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a G  number is valid
****************************************************************************
*/

U8 checkGnum(void)
{
    U32 i;
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=GERR_CANTBE_VAR;
    }
    i=checkGindex(gparam.value);
    if(i<GCODE_COUNT)
    {
        gparam.valindex=i;
        return GERR_OK;
    }else
        return GERR_GCMD_UNKNOW;
}
/***************************************************************************
*FUNCTION: checkMindex
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check m code number index
****************************************************************************
*/
U8 checkMindex(U8 val)
{
    U32 i;
    for(i=0;i<MCODE_COUNT;i++)
    {
        if(val==mcode[i].name)
        {
            break;
        }
    }
    return i;
}
/***************************************************************************
*FUNCTION: checkMnum
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a M  number is valid
****************************************************************************
*/
U8 checkMnum(void)
{
    U32 i;
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=GERR_CANTBE_VAR;
    }
    i=checkMindex(gparam.value);
    if(i<MCODE_COUNT)
    {
        gparam.valindex=i;
        return GERR_OK;
    }else
        return GERR_MCMD_UNKNOW;
}
/***************************************************************************
*FUNCTION: checkHindex
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check h code index
****************************************************************************
*/
U8 checkHindex(U8 val)
{
    U32 i;
    for(i=0;i<HCODE_COUNT;i++)
    {
        if(val==hcode[i].name)
        {
            break;
        }
    }
    return i;
}
/***************************************************************************
*FUNCTION: checkHnum
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a H  number is valid
****************************************************************************
*/
U8 checkHnum(void)
{
    U32 i;
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=GERR_CANTBE_VAR;
    }
    i=checkHindex(gparam.value);
    if(i<HCODE_COUNT)
    {
        gparam.valindex=i;
        return GERR_OK;
    }else
        return GERR_HCMD_UNKNOW;
}

/***************************************************************************
*FUNCTION: checkVarIndex
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a VAR index is definded in system
****************************************************************************
*/
U8 checkVar(void)
{
    //check if the var index is in system var list
    //sysvar 200-220
    //input var 1000-1047
    //output var 1100-1123;
    U32 value=abs(gparam.value);
    if(((value>0)&&(value<=GLOBAL_VAR_MAX))
    ||((value>9000)&&(value<=(GLOBAL_VAR_MAX+9000)))
    ||((value>=MACRO_VAR_START)&&(value<MACRO_VAR_END))
    ||((value>=MACRO_VAR_START+9000)&&(value<MACRO_VAR_END+9000)))
    {
        return GERR_OK;
    }else
        return GERR_NOSUCH_VAR;
}
/***************************************************************************
*FUNCTION: checkCoordVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number given as coord value is a valid coord value
* or it is a valid  var definded in system;
****************************************************************************
*/
U8 checkCoordVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    //}else if((gparam.digitlen-gparam.taillen)>4)
    }else if((gparam.taillen>compileDigit)
    ||((gparam.taillen>=0)&&((gparam.digitlen-gparam.taillen)>4))
    ||((gparam.taillen<0)&&(gparam.digitlen>4)))
    {
        return GERR_NUM_TOOLONG;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkAVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if R number given is correct;

****************************************************************************
*/
U8 checkAVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }

    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkRVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if R number given is correct;

****************************************************************************
*/
U8 checkRVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }else if((gParamBuf.GHMFST&G_IS_SETED)&&(gParamBuf.gnum==65))
    { //IF IS G65 HCODDE ,R can be much biger and
        if(gparam.digitlen>10)//||(gparam.taillen>compileDigit))
            return GERR_NUM_TOOLONG;
        if((gparam.taillen<0)&&(gparam.digitlen>(10-compileDigit)))
            return GERR_NUM_TOOLONG;
    }else if((gparam.taillen>compileDigit)   //normal r in g code
    ||((gparam.taillen>=0)&&((gparam.digitlen-gparam.taillen)>4))
    ||((gparam.taillen<0)&&(gparam.digitlen>4)))
    {
        return GERR_NUM_TOOLONG;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkFVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide f value
****************************************************************************
*/
U8 checkFVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }
    if(gparam.value<=0) //||(gparam.value>20000))
    {
        return GERR_FEED_VAL;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkFVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide s value
****************************************************************************
*/
U8 checkSVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }
    if((gparam.value<=0)||(gparam.value>150000))
    {
        return GERR_S_VAL;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkFVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide t value
****************************************************************************
*/
U8 checkTVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }
    if(((gparam.value<0)||(gparam.value>10000))  //if it is a valide t number
      ||((gparam.value<100)&&(gparam.digitlen>2))) //not allow T0002 like format
    {
        return GERR_T_VAL;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkFVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide p value
****************************************************************************
*/
U8 checkPVal(void)
{
    U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }else if((gParamBuf.GHMFST&G_IS_SETED)&&(gParamBuf.gnum==65))
    {   // p in h code is h8x index, can has tail
        if(gparam.digitlen>10)
            return GERR_NUM_TOOLONG;
        if((gparam.taillen<0)&&(gparam.digitlen>(10-compileDigit)))
            return GERR_NUM_TOOLONG;
        //if((gparam.taillen>compileDigit)||(gparam.value<0))
        if(gparam.value<0)
            return GERR_VALUE_INVALID;
    }else{ //in normal g code
        if(gparam.taillen>=0)
            return GERR_VALUE_INVALID;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkFVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide q value
****************************************************************************
*/
U8 checkQVal(void)
{
	U8 err;
    if(gparam.type==GP_TYPE_PARAM)
    {
        err=checkVar();
        return err;
    }else if((gParamBuf.GHMFST&G_IS_SETED)&&(gParamBuf.gnum==65))
    {   // p in h code is h8x index
        if(gparam.digitlen>10)
            return GERR_NUM_TOOLONG;
        if((gparam.taillen<0)&&(gparam.digitlen>(10-compileDigit)))
            return GERR_NUM_TOOLONG;
        //if(gparam.taillen>compileDigit)
        //    return GERR_VALUE_INVALID;
    }else{ //in normal g code
        if(gparam.taillen>=0)
            return GERR_VALUE_INVALID;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkFVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide N value
****************************************************************************
*/
U8 checkNVal(void)
{
    if((gparam.value>0)&&(gparam.value<10000))
    {
        return GERR_OK;
    }else{
        return GERR_N_TOOBIG;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkOVal
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a number is a valide N value
****************************************************************************
*/
U8 checkOVal(void)
{
    if((gparam.value>0)&&(gparam.value<10000))
    {
        return GERR_OK;
    }else{
        return GERR_O_TOOBIG;
    }
}
//**************************************************************************
/***************************************************************************
*FUNCTION: valAddTail
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if a param value ,if it has no dot,it
*   need to conver to min unit by multi by unit mm to min unit
****************************************************************************
*/
void valAddTail(void)
{
    if(gparam.type==GP_TYPE_PARAM)
        return;
    if(gparam.taillen<0)
    {
        if(compileDigit==3)
            gparam.value*=1000;
        else if(compileDigit==4)
            gparam.value*=10000;

    }
}
/***************************************************************************
*FUNCTION: storeG
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a g keyword to the gparambuf,if there's no g parambefore
* it retun ok,else ,we had meet a new gcode;
****************************************************************************
*/
U8 storeG(void)
{
    //ONLY N can be place before g code
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {

        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gparam.value;
        gParamBuf.gindex=gparam.valindex;
        switch(gParamBuf.gnum)
        {
        	case(4):
        	case(28):
        	case(30):
        	case(70):
        	case(71):
        	case(72):
        	case(73):
        	case(74):
        	case(75):
        	case(76):
        		gCompileState.GG00=gParamBuf.gnum;
        		break;
            case(0):
            case(1):
            case(2):
            case(3):
            case(32):
            case(33):
            case(90):
            case(92):
            case(94):
                gCompileState.GG01=gParamBuf.gnum;
                break;
            case(96):
            case(97):
                gCompileState.GG02=gParamBuf.gnum;
                break;
            case(98):
            case(99):
                gCompileState.GG03=gParamBuf.gnum;
                break;
            case(20):
            case(21):
                gCompileState.GG06=gParamBuf.gnum;
                break;
            case(40):
            case(41):
            case(42):
                gCompileState.GG04=gParamBuf.gnum;
                break;
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
                gCompileState.GG05=gParamBuf.gnum;
                break;
            case(50):
                //goto GCODE_ENDED;
                break;
            case(65):
                return Scan_G65();
                break; //nothing to do else
            default:
                return GERR_GCMD_UNKNOW;
                break;
        }
        return GERR_OK;
    }else{
        if(gparam.value==65)
        {//G65前不允许任何字母,不然不能进入特殊函数
            return GERR_G_APPEAR;
        }else{
            gparamBak=gparam;
            return GERR_CODE_DONE;
        }
    }
        //more than one g is given in one line;
GCODE_ENDED:
    DEBUGMSG(1,"G compile err something befoe g\n");
    return GERR_G_APPEAR;
}

/***************************************************************************
*FUNCTION: storeH
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a h keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeH(void)
{
    //If is g65, and h is not set yet
    if((gParamBuf.GHMFST&G_IS_SETED)&&(gParamBuf.gnum==65)
        &&(!(gParamBuf.GHMFST&H_IS_SETED)))
    {
        gParamBuf.GHMFST|=H_IS_SETED;
        gParamBuf.hnum=gparam.value;
        gParamBuf.hindex=gparam.valindex;
        return GERR_OK;
    }else
        return GERR_H_APPEAR;
}
/***************************************************************************
*FUNCTION: storeX
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a X keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeX(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_TAIL;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED))
    { //not g code
        err=GERR_X_APPEAR;
        goto ERR_END;
    }else{ //GCODE
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give x after mfst;
            err=GERR_X_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(0):
            case(1):
            case(28):
            case(30):
            case(50):
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
            case(74):
            case(75):
            case(76):
            case(90):
            case(94):
                if(gParamBuf.paramType&(GXU_IS_SETED|GYV_IS_SETED))//now can enter x after z
                {  //X OR Z HAD GIVE OUT
                    err=GERR_X_APPEAR;
                    goto ERR_END;
                }
                break;
            case(2):
            case(3):
                if(gParamBuf.paramType&
                (GXU_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))//now can enter x after z
                {  //X OR Z HAD GIVE OUT
                    err=GERR_X_APPEAR;
                    goto ERR_END;
                }
                break;
            case(4):
                //if(gparam.value<1000)
            	//{
        	    if(gparam.taillen<0)
        		    gparam.value=gparam.value*1000;
                goto OK_END;
                break;
            case(32):
            case(92):
                if((gParamBuf.paramType&(GXU_IS_SETED|GI_IS_SETED))//now can enter x after z
                    ||(gParamBuf.GHMFST&F_IS_SETED))
                {
                    err=GERR_X_APPEAR;
                    goto ERR_END;
                }
                break;

            default:
                err=GERR_X_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.xu=gparam.value;
    gParamBuf.paramType&=~GXU_IS_HIRE;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GXU_IS_PARAM;
    else
        gParamBuf.paramType|=GXU_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeY
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a X keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeY(void)
{
    U8 err;
    if(!Yavailable)
    {
        err=GERR_Y_APPEAR;
        goto ERR_END;
    }
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_TAIL;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_Y_APPEAR;
        goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give Z after mfst;
            err=GERR_Y_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(0):
            case(1):
            case(28):
            case(30):
            case(50):
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
                if(gParamBuf.paramType&(GZW_IS_SETED|GXU_IS_SETED))
                {  //Z HAD GIVE OUT
                    err=GERR_Y_APPEAR;
                    goto ERR_END;
                }
                break;
            default:
                err=GERR_Y_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.yv=gparam.value;
    gParamBuf.paramType&=~GYV_IS_HIRE;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GYV_IS_PARAM;
    else
        gParamBuf.paramType|=GYV_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeZ
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a X keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeZ(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_TAIL;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_Z_APPEAR;
        goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give Z after mfst;
            err=GERR_Z_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(0):
            case(1):
            case(28):
            case(30):
            case(50):
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
            case(74):
            case(75):
            case(76):
            case(90):
            case(94):
                if(gParamBuf.paramType&(GZW_IS_SETED|GYV_IS_SETED))
                {  //Z HAD GIVE OUT
                    err=GERR_Z_APPEAR;
                    goto ERR_END;
                }
                break;
            case(2):
            case(3):
                if(gParamBuf.paramType&
                    (GZW_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))
                {  //X OR Z HAD GIVE OUT
                    err=GERR_Z_APPEAR;
                    goto ERR_END;
                }
                break;
            case(32):
            case(33):
            case(92):
                if((gParamBuf.paramType&(GZW_IS_SETED|GI_IS_SETED))
                ||(gParamBuf.GHMFST&F_IS_SETED))
                {
                    err=GERR_Z_APPEAR;
                    goto ERR_END;
                }
                break;

            default:
                err=GERR_Z_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.zw=gparam.value;
    gParamBuf.paramType&=~GZW_IS_HIRE;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GZW_IS_PARAM;
    else
        gParamBuf.paramType|=GZW_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}

/***************************************************************************
*FUNCTION: storeU
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a U keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeU(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_TAIL;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_U_APPEAR;
        goto ERR_END;
    }else{ //GCODE
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give x after mfst;
            err=GERR_U_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(0):
            case(1):
            case(28):
            case(30):
            case(50):
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
            case(71):
            case(72):
            case(73):
            case(74):
            case(75):
            case(76):
            case(90):
            case(94):
                if(gParamBuf.paramType&GXU_IS_SETED)
                {  //X OR Z HAD GIVE OUT
                    err=GERR_U_APPEAR;
                    goto ERR_END;
                }
                break;
            case(2):
            case(3):
                if(gParamBuf.paramType&
                (GXU_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))
                {  //X OR Z HAD GIVE OUT
                    err=GERR_U_APPEAR;
                    goto ERR_END;
                }
                break;
            case(4):
                if(gparam.value<1000)
            	{
            	    if(gparam.taillen<=0)
            		    gparam.value=gparam.value*1000;
            		else{
            		    gparam.value=gparam.value/10;
            		}
            	}
                goto OK_END;
                break;
            case(32):
            case(92):
                if((gParamBuf.paramType&(GXU_IS_SETED|GI_IS_SETED))
                    ||(gParamBuf.GHMFST&F_IS_SETED))
                {
                    err=GERR_U_APPEAR;
                    goto ERR_END;
                }
                break;

            default:
                err=GERR_U_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.xu=gparam.value;
    gParamBuf.paramType&=~GXU_IS_HIRE;
    gParamBuf.paramType|=GXU_IS_INC;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GXU_IS_PARAM;
    else
        gParamBuf.paramType|=GXU_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeV
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a V keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeV(void)
{
    U8 err;
    if(!Yavailable)
    {
        err=GERR_V_APPEAR;
        goto ERR_END;
    }
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_TAIL;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_V_APPEAR;
        goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give Z after mfst;
            err=GERR_V_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(0):
            case(1):
            case(28):
            case(30):
            case(50):
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
                if(gParamBuf.paramType&(GZW_IS_SETED|GXU_IS_SETED))
                {  //Z HAD GIVE OUT
                    err=GERR_V_APPEAR;
                    goto ERR_END;
                }
                break;
            default:
                err=GERR_V_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.yv=gparam.value;
    gParamBuf.paramType&=~GYV_IS_HIRE;
    gParamBuf.paramType|=GYV_IS_INC;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GYV_IS_PARAM;
    else
        gParamBuf.paramType|=GYV_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeW
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a W keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeW(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_TAIL;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_W_APPEAR;
        goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give x after mfst;
            err=GERR_W_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(0):
            case(1):
            case(28):
            case(30):
            case(50):
            case(54):
            case(55):
            case(56):
            case(57):
            case(58):
            case(59):
            case(71):
            case(72):
            case(73):
            case(74):
            case(75):
            case(76):
            case(90):
            case(94):
                if(gParamBuf.paramType&(GZW_IS_SETED))
                {  //Z HAD GIVE OUT
                    err=GERR_W_APPEAR;
                    goto ERR_END;
                }
                break;
            case(2):
            case(3):
                if(gParamBuf.paramType&
                    (GZW_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))
                {  //X OR Z HAD GIVE OUT
                    err=GERR_Z_APPEAR;
                    goto ERR_END;
                }
                break;
            case(32):
            case(33):
            case(92):
                if((gParamBuf.paramType&(GZW_IS_SETED|GI_IS_SETED))
                ||(gParamBuf.GHMFST&F_IS_SETED))
                {
                    err=GERR_Z_APPEAR;
                    goto ERR_END;
                }
                break;

            default:
                err=GERR_Z_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.zw=gparam.value;
    gParamBuf.paramType&=~GZW_IS_HIRE;
    gParamBuf.paramType|=GZW_IS_INC;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GZW_IS_PARAM;
    else
        gParamBuf.paramType|=GZW_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeA
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a A keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeA(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        if(gParamBuf.gnum==1)
        {
           goto CHECK_TAIL;
        }else
        {
            err=GERR_A_APPEAR;
            goto ERR_END;
        }

    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_A_APPEAR;
        goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give Z after mfst;
            err=GERR_A_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(1):
                /*if(((gParamBuf.paramType&(GXU_IS_SETED))
                    &&(gParamBuf.paramType&(GZW_IS_SETED)))
                ||*/ //xz 出现不出现都有可能
                if(gParamBuf.paramType&GYV_IS_SETED)
                {  //xz should only be one ,y should not appear
                    err=GERR_A_APPEAR;
                    goto ERR_END;
                }
                break;
            default:
                err=GERR_A_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.i=gparam.value;
    gParamBuf.paramType&=~GA_IS_HIRE;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GA_IS_PARAM;
    else
        gParamBuf.paramType|=GA_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeC
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a C keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeC(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        // c can't self define a line
        err=GERR_C_APPEAR;
        goto ERR_END;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_C_APPEAR;
        goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give Z after mfst;
            err=GERR_C_APPEAR;
            goto ERR_END;
        }
        switch (gParamBuf.gnum)
        {
            case(1):
                if((!(gParamBuf.paramType
                        &(GXU_IS_SETED|GZW_IS_SETED|GA_IS_SETED)))
                ||(gParamBuf.paramType&(GYV_IS_SETED))
                ||(gParamBuf.paramType&(GR_IS_SETED)))
                {  //y I should not appear
                   // X Z A must has one
                    err=GERR_C_APPEAR;
                    goto ERR_END;
                }
                if(gparam.value<0)
                {
                    err=GERR_VALUE_INVALID;
                    goto ERR_END;
                }
                break;
            default:
                err=GERR_C_APPEAR;
                goto ERR_END;
        }
    }
CHECK_TAIL:
    valAddTail();
OK_END:
    gParamBuf.k=gparam.value;
    gParamBuf.paramType&=~GC_IS_HIRE;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GC_IS_PARAM;
    else
        gParamBuf.paramType|=GC_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}

/***************************************************************************
*FUNCTION: storeI
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a I keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeI(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_I;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
        err=GERR_I_APPEAR;
        goto ERR_END;
    }else{

        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give x after mfst;
            err=GERR_I_APPEAR;
            goto ERR_END;
        }
CHECK_I:
        if((gParamBuf.gnum==2)||(gParamBuf.gnum==3))
        {
            if(!(gParamBuf.paramType&(GI_IS_SETED|GK_IS_SETED|GR_IS_SETED)))
            {
                valAddTail();
                goto OK_END;
            }else{  //X OR Z HAD GIVE OUT
                return GERR_I_APPEAR;
            }
        }else if((gParamBuf.gnum==32)||(gParamBuf.gnum==33)||
            (gParamBuf.gnum==92)||(gParamBuf.gnum==76))
        {
            if((gParamBuf.paramType&GI_IS_SETED)||
            (gParamBuf.GHMFST&F_IS_SETED))
            {
                 return GERR_I_APPEAR;
            }else{
                 valAddTail();
                 goto OK_END;
                 /*
                 if(gparam.taillen<0)
                  gparam.value*=1000;
                 if((gparam.value>60)&&(gparam.value<25400000))
                 {
                     goto OK_END;
                 }else{
                     return GERR_VALUE_INVALID;
                 }*/
            }
        }else
            return GERR_I_APPEAR;
    }

OK_END:
    gParamBuf.i=gparam.value;
    gParamBuf.paramType&=~GI_IS_HIRE;
    //gParamBuf.paramType|=GZW_IS_INC;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GI_IS_PARAM;
    else
        gParamBuf.paramType|=GI_IS_VALUE;
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeJ
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a J keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeJ(void)
{
    return GERR_J_APPEAR;
}
/***************************************************************************
*FUNCTION: storeK
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a K keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeK(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        gParamBuf.gindex=checkGindex(gParamBuf.gnum);
        goto CHECK_K;
    }else if(!(gParamBuf.GHMFST&G_IS_SETED)){ //not g code
            err=GERR_K_APPEAR;
            goto ERR_END;
    }else{
        if(gParamBuf.GHMFST&MFST_IS_SETED)
        {   //NO allow to give x after mfst;
            err=GERR_I_APPEAR;
            goto ERR_END;
        }
CHECK_K:
        if((gParamBuf.gnum==2)||(gParamBuf.gnum==3))
        {
            if(!(gParamBuf.paramType&(GK_IS_SETED|GR_IS_SETED)))
            {
                valAddTail();
                goto OK_END;
            }else{
                err=GERR_K_APPEAR;
                goto ERR_END;
            }
        }else{
            err=GERR_K_APPEAR;
            goto ERR_END;
        }
    }
OK_END:
    gParamBuf.k=gparam.value;
    gParamBuf.paramType&=~GK_IS_HIRE;
    //gParamBuf.paramType|=GZW_IS_INC;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.paramType|=GK_IS_PARAM;
    else
        gParamBuf.paramType|=GK_IS_VALUE;
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeR
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a R keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeR(void)
{
    U8 err;
    if(!(gParamBuf.GHMFST&GHMFST_SETED))
    {  //a new gcode that g num is not given
        gParamBuf.GHMFST|=G_IS_SETED;
        gParamBuf.gnum=gCompileState.GG01;
        if((gParamBuf.gnum==1)
            ||(gParamBuf.gnum==2)||(gParamBuf.gnum==3))
        {
            gParamBuf.gindex=checkGindex(gParamBuf.gnum);
            valAddTail();
            goto OK_END;
        }else
        {
            err=GERR_R_APPEAR;
            goto ERR_END;
        }

    }else if(gParamBuf.GHMFST&H_IS_SETED)
    { //h code
        if(!(gParamBuf.paramType&GR_IS_SETED))
        {
            //check and save r
            if(gparam.type==GP_TYPE_VALUE)
            {
                valAddTail();
            }
            goto OK_END;
        }
    }else{  //GCODE
        switch( gParamBuf.gnum)
        {
            case(1):
                if(gParamBuf.paramType&(GR_IS_SETED|GC_IS_SETED))
                {
                    err=GERR_R_APPEAR;
                    goto ERR_END;
                }
                valAddTail();
                if(gparam.value<0)
                {
                    err=GERR_VALUE_INVALID;
                    goto ERR_END;
                }
                break;
            case(2):
            case(3):
                if(gParamBuf.paramType&(GR_IS_SETED|GI_IS_SETED|GK_IS_SETED))
                {
                    err=GERR_R_APPEAR;
                    goto ERR_END;
                }
                valAddTail();
                if(gparam.value<0)
                {
                    err=GERR_VALUE_INVALID;
                    goto ERR_END;
                }
                break;
            case(71):
            case(72):
			case(74):
            case(75):
            case(76):
            case(90):
            case(92):
            case(94):
                if(gParamBuf.paramType&(GR_IS_SETED))
                {
                    err=GERR_R_APPEAR;
                    goto ERR_END;
                }
                valAddTail();
                break;
            case(73):
                if(gparam.taillen>=0)  //this p can't has digit tail
                {
                    err=GERR_VALUE_INVALID;
                    goto ERR_END;
                }
                break;
            default:
                err=GERR_R_APPEAR;
                goto ERR_END;
        }
    }

OK_END:
    gParamBuf.r=gparam.value;
    if(gParamBuf.GHMFST&H_IS_SETED)
    {
        if(gparam.type==GP_TYPE_PARAM)
            gParamBuf.GHMFST|=R_IS_PARAM;
        else
            gParamBuf.GHMFST|=R_IS_VALUE;
    }else{
        gParamBuf.paramType&=~GR_IS_HIRE;
        if(gparam.type==GP_TYPE_PARAM)
            gParamBuf.paramType|=GR_IS_PARAM;
        else
            gParamBuf.paramType|=GR_IS_VALUE;
    }
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeM
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a g keyword to the gparambuf,if there's no g parambefore
* it retun ok,else ,we had meet a new gcode;
****************************************************************************
*/
U8 storeM(void)
{
    U8 err;
    //if(!(gParamBuf.GHMFST&GHMFST_SETED))
    if((gParamBuf.GHMFST&(G_IS_SETED|M_IS_SETED))==0)
    {
        goto OK_END;
    }else if(gParamBuf.GHMFST&G_IS_SETED){
        if(gParamBuf.GHMFST&M_IS_SETED)
        {
            err=GERR_M_APPEAR;
            goto ERR_END;
        }else{
            if((gParamBuf.mnum==91)||(gParamBuf.mnum==98)||(gParamBuf.mnum==99)||(gParamBuf.mnum==30))
            {    //can't be this m codes
                err=GERR_M_APPEAR;
                goto ERR_END;
            }
            goto OK_END;
         }
    }else{  //two m code in the same line
        //err=GERR_M_APPEAR;
        //goto ERR_END;
        gparamBak=gparam;
        return GERR_CODE_DONE;
    }
OK_END:
    gParamBuf.GHMFST|=M_IS_SETED;
    gParamBuf.mnum=gparam.value;
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeF
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a F keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeF(void)
{
    U8 err;
    if((gParamBuf.GHMFST&(G_IS_SETED|F_IS_SETED))==0)
    {
        /*if(gparam.taillen>=0)
        {
            err=GERR_VALUE_INVALID;
            goto ERR_END;
        }*/
        goto CHK_END;
    }else if(gParamBuf.GHMFST&G_IS_SETED)
    {
        //we shell check if it is a gcode allow to set fst later
        if(gParamBuf.paramType&
            (GXU_IS_SETED|GZW_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))
        {
            if((gParamBuf.gnum==32)||(gParamBuf.gnum==33)
                ||(gParamBuf.gnum==92)||(gParamBuf.gnum==76))
            {   //not check f taillen since f is screw lead
                valAddTail();
                goto OK_END;
            }
            goto CHK_END;
        }else if((gParamBuf.gnum==98)||(gParamBuf.gnum==99))
        {
            goto CHK_END;
        }
        err=GERR_F_APPEAR;
        goto ERR_END;
    }
CHK_END:
    //we didn't fix the f with dot in g99 problem at this time,for a temp version

    //two f in the same line,use the new one
    if(gparam.taillen<0)
    {
       // err=GERR_VALUE_INVALID;
       // goto ERR_END;
       gparam.value*=1000;  //the f value we store should be um/min or um/r
    }
OK_END:
    gParamBuf.f=gparam.value;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.GHMFST|=F_IS_PARAM;
    else
        gParamBuf.GHMFST|=F_IS_VALUE;
    //return GERR_OK;
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeS
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a S keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeS(void)
{
    U8 err;
    if((gParamBuf.GHMFST&(G_IS_SETED|S_IS_SETED))==0)
    {
        goto OK_END;
    }else if(gParamBuf.GHMFST&G_IS_SETED)
    {//we shell check if it is a gcode allow to set fst later
        if(gParamBuf.paramType&
            (GXU_IS_SETED|GZW_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))
        {
            goto OK_END;
        }else if(gParamBuf.gnum==50)
        {
            goto OK_END;
        }else if((gParamBuf.gnum==96)||(gParamBuf.gnum==97))
        {
            goto OK_END;
        }
        err=GERR_S_APPEAR;
        goto ERR_END;
    } //two s is given ,use the new one
     //here g and f had set
    //err=GERR_S_APPEAR;
    //goto ERR_END;
OK_END:
    gParamBuf.s=gparam.value;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.GHMFST|=S_IS_PARAM;
    else
        gParamBuf.GHMFST|=S_IS_VALUE;
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeP
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a P keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/

U8 storeP(void)
{
    U8 err;
    if (gParamBuf.GHMFST&H_IS_SETED)
    {  //h or m code
        if(!(gParamBuf.GHMFST&P_IS_SETED))
        {
            if(gparam.type==GP_TYPE_VALUE)
            {
                valAddTail();
            }
            goto OK_END;
        }
    }else if(gParamBuf.GHMFST&G_IS_SETED)
    {
        if(gparam.taillen<0)  //this p can't has digit tail
        {   switch(gParamBuf.gnum)
            {
                case(4):
                case(30):
                case(33): //drill screw
                case(54):
                case(70):
                case(71):
                case(72):
                case(73):
                case(74):
                case(75):
                case(76):
                case(92):
                    if(!(gParamBuf.GHMFST&P_IS_SETED))
                    {
                        goto OK_END;
                    }
                    break;
                default:  //error
                    break;
            }
        }
    }else
      if((gParamBuf.GHMFST&M_IS_SETED)&&
         ((gParamBuf.mnum==65)||
          (gParamBuf.mnum==91)||
          (gParamBuf.mnum==98)||
          (gParamBuf.mnum==99)||
          (gParamBuf.mnum==15)))//add by lxw
    {
        if((gparam.taillen<0)&&(!(gParamBuf.GHMFST&P_IS_SETED)))
        {
            goto OK_END;
        }
    }
    err=GERR_P_APPEAR;
    goto ERR_END;
OK_END:
    gParamBuf.p=gparam.value;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.GHMFST|=P_IS_PARAM;
    else
        gParamBuf.GHMFST|=P_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeQ
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a Q keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeQ(void)
{
    U8 err;
    if(gParamBuf.GHMFST&H_IS_SETED)
    { //h code
        if(!(gParamBuf.GHMFST&Q_IS_SETED))
        {
            if(gparam.type==GP_TYPE_VALUE)
            {
                valAddTail();
            }
            goto OK_END;
        }
    }else if(gParamBuf.GHMFST&G_IS_SETED)
    {
        if(gparam.taillen<0)  //this p can't has digit tail
        {
        	if(((gParamBuf.gnum>=70)&&(gParamBuf.gnum<=76) )
        	||(gParamBuf.gnum==32)||(gParamBuf.gnum==92))
            {
                if(!(gParamBuf.GHMFST&Q_IS_SETED))
                {
                    goto OK_END;
                }
            }
        }
    }
    err=GERR_Q_APPEAR;
    goto ERR_END;

OK_END:
    gParamBuf.q=gparam.value;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.GHMFST|=Q_IS_PARAM;
    else
        gParamBuf.GHMFST|=Q_IS_VALUE;
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeT
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a Q keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeT(void)
{
    U8 err;
    if((gParamBuf.GHMFST&(G_IS_SETED|T_IS_SETED))==0)
    {
        goto OK_END;
    }else if(gParamBuf.GHMFST&G_IS_SETED)
    {//we shell check if it is a gcode allow to set fst later
        if(gParamBuf.paramType&
            (GXU_IS_SETED|GZW_IS_SETED|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED))
        {
            goto OK_END;
        }else if((gParamBuf.gnum==96)||(gParamBuf.gnum==97)||
           (gParamBuf.gnum==98)||(gParamBuf.gnum==99))
        {
           //return GERR_CODE_DONE;
           goto OK_END;
        }
        err=GERR_T_APPEAR;
        goto ERR_END;
    } //two t in the same line,use the new one
        //err=GERR_T_APPEAR;
        //goto ERR_END;
OK_END:
    gParamBuf.t=gparam.value;
    //chek t value is ok or not
    {
        U8 num=gParamBuf.t/100;
        U8 tc=gParamBuf.t%100;
        if(num==0)
        {
            //err=GERR_VALUE_INVALID;
            //goto ERR_END;
            num=tc;
        }
        if((tc>=TCOMP_MAX)||
            ((SYSparam[170].val==1)&&(num>=TCOMP_MAX)))
        {
            err=GERR_VALUE_INVALID;
            goto ERR_END;
        }
        if((SYSparam[170].val>1)&&(num>SYSparam[170].val))
        {
            err=GERR_VALUE_INVALID;
            goto ERR_END;
        }
    }
    if(gParamBuf.t<100)
        gParamBuf.t=gParamBuf.t*100+gParamBuf.t;
    if(gparam.type==GP_TYPE_PARAM)
        gParamBuf.GHMFST|=T_IS_PARAM;
    else
        gParamBuf.GHMFST|=T_IS_VALUE;
    err=GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: storeN
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: try to store a T keyword to the gparambuf,if g68 is definded ,return ok else err
****************************************************************************
*/
U8 storeN(void)
{
    if(gParamBuf.GHMFST==0)
    {
        gParamBuf.N=gparam.value;
        gParamBuf.GHMFST|=N_IS_SETED;
        return GERR_OK; //just pass the n
    }else{
        return GERR_N_APPEAR;
    }
}
/***************************************************************************
*FUNCTION: storeO
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: store the O  param
****************************************************************************
*/
U8 storeO(void)
{
    if(gParamBuf.GHMFST==0)
    {
        gParamBuf.O=gparam.value;
        gParamBuf.GHMFST|=O_IS_SETED;
        return GERR_OK;
    }else{
        return GERR_O_APPEAR;
    }
}

/***************************************************************************
*FUNCTION: generalGcodeCheck
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 generalGcodeSaveCheck(void)
{
    //not doing any thing yet
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheckO
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: store the o number and
****************************************************************************
*/
U8 gCodeSaveCheckO(void)
{
    U16 i=gParamBuf.O;
    U8 j;
    for(j=0;j<programCount;j++)
    {
        if(i==programList[j].index)
        {

            return GERR_DUPL_ONUM;
        }
    }
    //main loop is had name as O0000 in default,
    //if user named an O in the main file start again ,change it
    if((j==1)&&(gCompiledCt==0))
    {
       programList[j].index=gParamBuf.O;
       programList[j].address=0;
       programList[j].bufIndex=0;
       //programCount++;
       j=0;
    }else{
        gCompileState.currentProg=gParamBuf.O;
        programList[j].index=gParamBuf.O;
        programList[j].address=gCompiledCt;
        programCount++;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheckN
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: store the Number;
****************************************************************************
*/
U8 gCodeSaveCheckN(void)
{
    U16 i=gParamBuf.N;
    U16 j;
    for(j=0;j<jumpPointCount;j++)
    {
        if((i==jumpPointList[j].tag)
        &&(jumpPointList[j].prog==gCompileState.currentProg))
        {
            return GERR_DUPL_NNUM;
        }
    }
    jumpPointList[j].prog=gCompileState.currentProg;
    jumpPointList[j].tag=gParamBuf.N;
    jumpPointCount++;
    jumpPointList[j].address=gCompiledCt;
    /*
    //can't understand while I write this before, vin 20100310
    if(grunPtr!=0)
    {
        jumpPointList[j].address=gCompiledCt+1;
    }else{
        jumpPointList[j].address=gCompiledCt;
    }*/
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheckMFST
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: save the MFST code to compileGbuf;
****************************************************************************
*/
U8 gCodeSaveCheckMFST(void)
{
    TcompiledM m;
    TcompiledFST fst;
    memset(&m,0,sizeof(TcompiledM));
    memset(&fst,0,sizeof(TcompiledFST));
    //S should be place befoe m since code like m03s300
    if(gParamBuf.GHMFST&F_IS_SETED)
    {
        fst.gtype=GCODE_F;
        fst.srcline=srcline;
        fst.paramType=gParamBuf.GHMFST&F_IS_SETED;
        fst.value=gParamBuf.f;
        fst.srcJump=srcJumpFlag;
        memcpy(compiledGPointer,&fst,sizeof(TcompiledFST));
        compiledGPointer++;
        gCompiledCt++;
    }
    if(gParamBuf.GHMFST&S_IS_SETED)
    {
        fst.gtype=GCODE_S;
        fst.srcline=srcline;
        fst.paramType=gParamBuf.GHMFST&S_IS_SETED;
        fst.value=gParamBuf.s;
        fst.srcJump=srcJumpFlag;
        //*compiledGPointer=*(PcompiledG23)&fst;
        memcpy(compiledGPointer,&fst,sizeof(TcompiledFST));
        compiledGPointer++;//=sizeof(TcompiledFST);
        gCompiledCt++;
    }
    if((gParamBuf.GHMFST&M_IS_SETED)&&(gParamBuf.mnum==65))
    {
        fst.gtype=GCODE_M65;
        fst.srcline=srcline;
        if(gParamBuf.GHMFST&P_IS_SETED)
        {
            fst.value=gParamBuf.p;
            if((fst.value<100)||(fst.value>200))
            {
                return GERR_VALUE_INVALID;
            }
        }else{
            return GERR_M65PERR;
        }
        fst.paramType|=S_IS_SETED;
        fst.srcJump=srcJumpFlag;
        memcpy(compiledGPointer,&fst,sizeof(TcompiledFST));
        compiledGPointer++;//=sizeof(TcompiledFST);
        gCompiledCt++;
    }
    else if(gParamBuf.GHMFST&M_IS_SETED)
    {
        //m.gtype=GTYPE_M;
        m.srcline=srcline;
        m.gtype=(gParamBuf.mnum<<8)|0x65;
        if((gParamBuf.mnum==65)
        ||((gParamBuf.mnum>80)&&(gParamBuf.mnum<90))
        ||(gParamBuf.mnum==98)||(gParamBuf.mnum==91)) //not m98 no param left
        {
        	U16 i;
            U16 prog=gParamBuf.p%10000;
            if((gParamBuf.mnum>80)&&(gParamBuf.mnum<90))
            {
                prog=9020+(gParamBuf.mnum-80); //wich it call
            }
            if((gParamBuf.mnum==98)&&
                (gParamBuf.GHMFST&(G_IS_SETED|F_IS_SETED|S_IS_SETED)))
            {
                return GERR_G_MIX;
            }

            if(gParamBuf.mnum==98)
            {
                if(gParamBuf.GHMFST&P_IS_SETED)
                {
                    m.value=gParamBuf.p;
                }else{
                    DEBUGMSG(1,"m98 must have a p value\n");
                    return GERR_M98_MISS_P;
                }
            }
            if((gParamBuf.mnum>80)&&(gParamBuf.mnum<90))
            {
                prog=9010+(gParamBuf.mnum-80); //wich it call
                gParamBuf.mnum=98;
                m.gtype=(gParamBuf.mnum<<8)|0x65;
                m.value=10000+prog;
            }
            //save m98 called progm index and M99 return address
            //we will check all this index after compile finish
            //we should check m98 value given prog index is ok or not
            for(i=0;i<m98Count;i++)
            {
                if((prog==m98Request[i].program)
                    &&(gCompileState.currentProg==m98Request[i].caller))
                {
                    break;
                }
            }
            if(i==m98Count)
            {
                m98Request[i].caller=gCompileState.currentProg;
                m98Request[i].program=prog;//g98.value;
                m98Request[i].isFile=FALSE;
                m98Count++;
            }
        }else if(gParamBuf.mnum==99)
        {
            U16 i;
            if((gParamBuf.mnum==99)&&
                (gParamBuf.GHMFST&(G_IS_SETED|F_IS_SETED|S_IS_SETED)))
            {
                return GERR_G_MIX;
            }
            if(gParamBuf.GHMFST&P_IS_SETED)
                m.value=gParamBuf.p;
            else
                m.value=0;
            if(m.value!=0)
            {
                //we should check if m99 given tag address is ok or not
                //we should check m98 value given prog index is ok or not
                for(i=0;i<m99Count;i++)
                {
                    if((m.value==m99Request[i].addressTag)
                    &&(gCompileState.currentProg==m99Request[i].subProgram))
                    {
                        break;
                    }
                }
                if(i==m99Count)
                {
                    m99Request[i].addressTag=m.value;
                    m99Request[i].subProgram=gCompileState.currentProg;
                    m99Count++;
                }
            }
        }else if(gParamBuf.mnum>=41&&gParamBuf.mnum<=44)
        {
            if(SYSparam[40].val!=0&&SYSparam[40].val!=5)
            {
                return GERR_REFUSE_M4X;
            }
        }else if(gParamBuf.mnum==15)
        {   // M15 should bi 0xf65 ,bug t is coded 0xf65,use 0x7365 instead
            m.gtype=(115<<8)|0x65;
            if(gParamBuf.GHMFST&P_IS_SETED)
            {
                if(gParamBuf.p>10000)
                {
                    gParamBuf.p=9999;
                }else if(gParamBuf.p<0){
                    gParamBuf.p=0;
                }
                m.value=gParamBuf.p;
            }else
                m.value=0;
        }
        //*compiledGPointer=*(PcompiledG23)&m;
        m.srcJump=srcJumpFlag;
        memcpy(compiledGPointer,&m,sizeof(TcompiledM));
        compiledGPointer++;
        gCompiledCt++;
    }

    if(gParamBuf.GHMFST&T_IS_SETED)
    {
        fst.gtype=GCODE_T;
        fst.srcline=srcline;
        fst.paramType=gParamBuf.GHMFST&T_IS_SETED;
        fst.value=gParamBuf.t;
        fst.srcJump=srcJumpFlag;
        //*compiledGPointer=*(PcompiledG23)&fst;
        memcpy(compiledGPointer,&fst,sizeof(TcompiledFST));
        compiledGPointer++;//=sizeof(TcompiledFST);
        gCompiledCt++;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck01
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck01(void)
{
    U8 err;

    TcompiledG01 g01;
    memset(&g01,0,sizeof(TcompiledG01));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    //real g01
    /*
    if((gParamBuf.paramType&(GXU_IS_SETED|GZW_IS_SETED))==0)
    {
        return GERR_G0001_MISS_XZ;
    }*/
    g01.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g01.srcline=srcline;
    g01.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC
        |GYV_IS_SETED|GYV_IS_INC|GA_IS_SETED|GC_IS_SETED|GR_IS_SETED);
    g01.xu=gParamBuf.xu;
    g01.zw=gParamBuf.zw;
    g01.yv=gParamBuf.yv;
    g01.a=gParamBuf.i;
    g01.c=gParamBuf.k;
    g01.r=gParamBuf.r;
    g01.srcJump=srcJumpFlag;
    //*compiledGPointer=*(PcompiledG23)&g01;
    memcpy(compiledGPointer,&g01,sizeof(TcompiledG01));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck23
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck23(void)
{
    TcompiledG23 g23;
    memset(&g23,0,sizeof(TcompiledG23));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if((gParamBuf.paramType&GR_IS_SETED)==0)
    {
        if(((gParamBuf.paramType&GI_IS_SETED)==0)&&
            ((gParamBuf.paramType&GK_IS_SETED)==0))
            return GERR_G0203_MISS_IJR;
    }
    //real g01
    g23.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g23.srcline=srcline;
    g23.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GI_IS_SETED|GK_IS_SETED|GR_IS_SETED);
    g23.xu=gParamBuf.xu;
    g23.zw=gParamBuf.zw;
    if(g23.paramType&GR_IS_SETED)
    {// r is given
        g23.r=abs(gParamBuf.r);
    }else{
        g23.i=gParamBuf.i;
        g23.k=gParamBuf.k;
    }
    g23.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g23,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck04
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function save the G04
****************************************************************************
*/
U8 gCodeSaveCheck04(void)
{
    TcompiledFST g04;
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    memset(&g04,0,sizeof(TcompiledFST));
    g04.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g04.srcline=srcline;
    g04.paramType=0;
    if(gParamBuf.paramType&GXU_IS_SETED)
    {
        //use param type x to store stop time len
        g04.paramType=gParamBuf.paramType&GXU_IS_SETED;
        g04.value=gParamBuf.xu;
    }else if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
        {
            g04.paramType|=GXU_IS_VALUE;
        }else{
            g04.paramType|=GXU_IS_PARAM;
        }
        g04.paramType|=GZW_IS_SETED; //G04 p与x两种形式使用宏变量时读取方式不同，需要区别
        g04.value=gParamBuf.p;
    }
    g04.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g04,sizeof(TcompiledFST));
    compiledGPointer++;//=sizeof(TcompiledFST);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck2021
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function save SCREW G20 G21 code ,
****************************************************************************
*/
U8 gCodeSaveCheck2021(void)
{
    TcompiledM g2021;
    memset(&g2021,0,sizeof(TcompiledM));
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        //gCodeSaveCheckMFST();
        return GERR_CANT_MFST;
    }
    g2021.gtype=gParamBuf.gnum;
    if(gCompiledCt!=0)
    {
        return GERR_G2021;
    }
    if(g2021.gtype==GCODE_20) //inch
    {
        if(unitMode==0)
        {
            unitMode=1;
            compileDigit=4;
        }
    }else{
        if(unitMode==1)
        {
            unitMode=0;
            compileDigit=3;
        }
    }
    g2021.srcline=srcline;
    g2021.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g2021,sizeof(TcompiledM));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck32
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function save SCREW G32 code ,
****************************************************************************
*/
U8 gCodeSaveCheck28(void)
{
    TcompiledG01 g01;
    memset(&g01,0,sizeof(TcompiledG01));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(DSPparam.sysbyte[92]==1)
        return GERR_REFUSE_G28;
    //real g01
    /*  not check xz in g28
    if((gParamBuf.paramType&(GXU_IS_SETED|GZW_IS_SETED))==0)
    {
        return GERR_G0001_MISS_XZ;
    }*/
    g01.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g01.srcline=srcline;
    g01.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GYV_IS_SETED|GYV_IS_INC);
    g01.xu=gParamBuf.xu;
    g01.zw=gParamBuf.zw;
    g01.yv=gParamBuf.yv;
    g01.srcJump=srcJumpFlag;
    //*compiledGPointer=*(PcompiledG23)&g01;
    memcpy(compiledGPointer,&g01,sizeof(TcompiledG01));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck30
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: chech and save the g30 ,g30 has a p param ,since p use the same
* bit as x, save g30 as arc and store p as r;
****************************************************************************
*/
U8 gCodeSaveCheck30(void)
{
    TcompiledG23 g30;
    memset(&g30,0,sizeof(TcompiledG23));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    if(DSPparam.sysbyte[92]==1)
        return GERR_REFUSE_G28;
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        //p define the number of  ref point index
        if(!(gParamBuf.GHMFST&P_IS_VALUE))
        {
            return GERR_CANTBE_VAR;
        }

        g30.r=gParamBuf.p;

        if((g30.r<1)||(g30.r> REFP_MAX))
        {
            return GERR_G30_ERRPVAL;
        }
    }else  //if not set p is 1;
    {
        g30.r=1;
    }

    //real g01
    /*
    if(((gParamBuf.paramType&GXU_IS_SETED)==0)
    &&((gParamBuf.paramType&GZW_IS_SETED)==0))
    {
        return GERR_G32_MISS_XZ;//need
    }*/
    g30.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g30.srcline=srcline;
    g30.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GYV_IS_SETED|GYV_IS_INC);
    g30.paramType|=GR_IS_VALUE;
    g30.xu=gParamBuf.xu;
    g30.zw=gParamBuf.zw;
    g30.yv=gParamBuf.yv;
    g30.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g30,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck32
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function save SCREW G32 code ,
****************************************************************************
*/
U8 gCodeSaveCheck32(void)
{
    TcompiledG23 g32;
    memset(&g32,0,sizeof(TcompiledG23));
    //if thereis mfst code
    if(SYSparam[94].val==1)
    {
        return GERR_REFUSE_SCREW;
    }
    if(gParamBuf.GHMFST&MST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    if(gParamBuf.GHMFST&F_IS_SETED)
    {
        //F IN g32 is the daocheng,store in k
        g32.f=gParamBuf.f; //
        if(gParamBuf.GHMFST&F_IS_VALUE)
            g32.paramType|=GF_IS_VALUE;
        else
            g32.paramType|=GF_IS_PARAM;
        gCompileState.screwf=1; //JUST A FLAG
    }else if(gParamBuf.paramType&GI_IS_SETED){
        //g32.k=gParamBuf.i*25.4; //conver form inch to meter um
        //gCompileState.screwf=g32.k;
        g32.f=gParamBuf.i;
        if(gParamBuf.paramType&GI_IS_VALUE)
            g32.paramType|=GF_IS_VALUE;
        else
            g32.paramType|=GF_IS_PARAM;
        g32.paramType|=GF_IS_INC;
        gCompileState.screwf=1; //JUST A FLAG
    }else{
        //not f or i given ,is some to hire from
        if(gCompileState.screwf==0)
            return GERR_G32_MISS_FI;
    }
    //check q val;
    if(gParamBuf.GHMFST&Q_IS_VALUE)
    {
        g32.paramType|=GI_IS_VALUE;
    }else if(gParamBuf.GHMFST&Q_IS_PARAM)
    {
        g32.paramType|=GI_IS_PARAM;
    }
    g32.i=gParamBuf.q;
    //real g01
    if(((gParamBuf.paramType&GXU_IS_SETED)==0)
    &&((gParamBuf.paramType&GZW_IS_SETED)==0))
    {
        return GERR_G32_MISS_XZ;//need
    }
    g32.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g32.srcline=srcline;
    g32.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC);
    g32.xu=gParamBuf.xu;
    g32.zw=gParamBuf.zw;
    g32.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g32,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck33
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function save the G33 drill screw function
****************************************************************************
*/
U8 gCodeSaveCheck33(void)
{
    TcompiledG23 g33;
    memset(&g33,0,sizeof(TcompiledG23));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    if(gParamBuf.GHMFST&F_IS_SETED)
    {
        //F IN g33 is the daocheng,store in k
        g33.f=gParamBuf.f; //
        if(gParamBuf.GHMFST&F_IS_VALUE)
            g33.paramType|=GF_IS_VALUE;
        else
            g33.paramType|=GF_IS_PARAM;
        gCompileState.screwf=1; //JUST A FLAG
    }else if(gParamBuf.paramType&GI_IS_SETED){
         //INCH  IS 25400MU AND I IS ENLARGE 1000
        g33.f=25400000/gParamBuf.i;
        //g33.k=gParamBuf.i*25.4; //conver form inch to meter um
        //gCompileState.screwf=g33.k;
        if(gParamBuf.paramType&GI_IS_VALUE)
            g33.paramType|=GF_IS_VALUE;
        else
            g33.paramType|=GF_IS_PARAM;
        g33.paramType|=GF_IS_INC;
        gCompileState.screwf=1; //JUST A FLAG
    }else{
        //not f or i given ,is some to hire from
        if(gCompileState.screwf==0)
            return GERR_G32_MISS_FI;
    }
    /*
    //check p val; head number of screw
    if(gParamBuf.GHMFST&P_IS_VALUE)
    {
        gParamBuf.paramType|=GK_IS_VALUE;

    }else if(gParamBuf.GHMFST&P_IS_PARAM)
    {
        gParamBuf.paramType|=GK_IS_PARAM;
    }
    g33.k=gParamBuf.p;
    */
    //real g01
    if((gParamBuf.paramType&GZW_IS_SETED)==0)
    {
        return GERR_G32_MISS_XZ;//need
    }
    g33.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g33.srcline=srcline;
    g33.paramType|=gParamBuf.paramType&
        (GZW_IS_SETED|GZW_IS_INC);
    g33.zw=gParamBuf.zw;
    g33.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g33,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck404142
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function save the G40-G42
****************************************************************************
*/
U8 gCodeSaveCheck404142(void)
{
    TcompiledM g4x;
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    memset(&g4x,0,sizeof(TcompiledM));
    g4x.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g4x.srcline=srcline;
    g4x.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g4x,sizeof(TcompiledM));
    compiledGPointer++;//=sizeof(TcompiledM);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck50
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck50(void)
{
    TcompiledFST g50s;
    TcompiledG01 g50;
    memset(&g50s,0,sizeof(TcompiledFST));
    memset(&g50,0,sizeof(TcompiledG01));
    if(gParamBuf.GHMFST&(F_IS_SETED|M_IS_SETED|T_IS_SETED))
    {
        return GERR_G_MIX;
    }
    if(gParamBuf.GHMFST&S_IS_SETED)
    {  //max s speed for g50 sxxxx
        g50s.gtype=GCODE_M50;//gParamBuf.gnum;//GTYPE_M|(gParamBuf.gnum);
        g50s.srcline=srcline;
        g50s.srcJump=srcJumpFlag;
        g50s.paramType=S_IS_VALUE;
        g50s.value=gParamBuf.s;
        memcpy(compiledGPointer,&g50s,sizeof(TcompiledFST));
        compiledGPointer++;//=sizeof(TcompiledM);
        gCompiledCt++;
        return GERR_OK;
    }
    if((gParamBuf.paramType&(GXU_IS_VALUE)==0)
    &&(gParamBuf.paramType&(GZW_IS_VALUE)==0))
    {
        if((Yavailable)&&(gParamBuf.paramType&(GYV_IS_VALUE)!=0))
        {
        }else{
            return GERR_G50_MISS_XZ;
        }
    }
    g50.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g50.srcline=srcline;
    g50.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GYV_IS_SETED|GYV_IS_INC);
    g50.xu=gParamBuf.xu;
    g50.zw=gParamBuf.zw;
    g50.yv=gParamBuf.yv;
    g50.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g50,sizeof(TcompiledG01));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck5x
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck5x(void)
{
    TcompiledG23 g5x;
    memset(&g5x,0,sizeof(TcompiledG01));
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    g5x.gtype=GCODE_54;
    g5x.xu=gParamBuf.xu;
    g5x.zw=gParamBuf.zw;
    g5x.yv=gParamBuf.yv;
    g5x.srcline=srcline;
    g5x.srcJump=srcJumpFlag;
    g5x.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GYV_IS_SETED|GYV_IS_INC);
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
        {
            g5x.paramType|=GR_IS_VALUE;
            if(gParamBuf.p<G5X_MAX&&gParamBuf.p>0)
            {
                g5x.r = gParamBuf.p;
            }else{
                return GERR_P_APPEAR;
            }
        }else
            g5x.paramType|=GR_IS_PARAM;
            g5x.r = gParamBuf.p;
    }else{
        g5x.r = gParamBuf.gnum-53;
        g5x.paramType|=GR_IS_VALUE;
    }
    memcpy(compiledGPointer,&g5x,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck65
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck65(void)
{
    //return GERR_OK;
    U8 err;
    return 0;
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    err=hcode[gParamBuf.hindex].func();
    return err;
}
/***************************************************************************
*FUNCTION: GcodeCheck70
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gcodeSaveCheck70(void)
{
    TcompiledG7x g70;
    memset(&g70,0,sizeof(TcompiledG7x));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
       // gCodeSaveCheckMFST();
       return GERR_CANT_MFST;
    }
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
            g70.paramType|=GI_IS_VALUE;
        else
            g70.paramType|=GI_IS_PARAM;
        //g70.paramType|=GI_IS_SETED;
        g70.p=gParamBuf.p;
    }
    if(gParamBuf.GHMFST&Q_IS_SETED)
    {
        if(gParamBuf.GHMFST&Q_IS_VALUE)
            g70.paramType|=GK_IS_VALUE;
        else
            g70.paramType|=GK_IS_PARAM;
        //g70.paramType|=GK_IS_SETED;
        g70.q=gParamBuf.q;
    }
    //if((g70.paramType&(GI_IS_SETED|GK_IS_SETED))!= (GI_IS_SETED|GK_IS_SETED))
    if(((g70.paramType&GI_IS_SETED)==0)||
    ((g70.paramType&GK_IS_SETED)==0))
    { //pq must be provid both
        return GERR_G7X_MISS_PQ ;
    }
    g70.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g70.srcline=srcline;
    g70.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g70,sizeof(TcompiledG7x));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck71
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gcodeSaveCheck71(void)
{
    TcompiledG7x g71;
    memset(&g71,0,sizeof(TcompiledG7x));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
            g71.paramType|=GI_IS_VALUE;
        else
            g71.paramType|=GI_IS_PARAM;
        //g71.paramType|=GI_IS_SETED;
        g71.p=gParamBuf.p;
    }
    if(gParamBuf.GHMFST&Q_IS_SETED)
    {
        if(gParamBuf.GHMFST&Q_IS_VALUE)
            g71.paramType|=GK_IS_VALUE;
        else
            g71.paramType|=GK_IS_PARAM;
        //g71.paramType|=GK_IS_SETED;
        g71.q=gParamBuf.q;
    }
    /*
    if(((g71.paramType&GI_IS_SETED)==0)||
    ((g71.paramType&GK_IS_SETED)==0))
    { //pq must be provid both
        return GERR_G7X_MISS_PQ ;
    }*/
    g71.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g71.srcline=srcline;
    g71.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GR_IS_SETED);
    g71.u=gParamBuf.xu;
    g71.w=gParamBuf.zw;
    g71.r=gParamBuf.r;
    g71.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g71,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck72
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gcodeSaveCheck72(void)
{
    TcompiledG7x g72;
    memset(&g72,0,sizeof(TcompiledG7x));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
            g72.paramType|=GI_IS_VALUE;
        else
            g72.paramType|=GI_IS_PARAM;
        //g72.paramType|=GI_IS_SETED;
        g72.p=gParamBuf.p;
    }
    if(gParamBuf.GHMFST&Q_IS_SETED)
    {
        if(gParamBuf.GHMFST&Q_IS_VALUE)
            g72.paramType|=GK_IS_VALUE;
        else
            g72.paramType|=GK_IS_PARAM;
        //g72.paramType|=GK_IS_SETED;
        g72.q=gParamBuf.q;
    }

    //if((g72.paramType==GI_IS_SETED)||(g72.paramType==GK_IS_SETED) )
    /*
    if(((g72.paramType&GI_IS_SETED)==0)||
    ((g72.paramType&GK_IS_SETED)==0))
    { //pq must be provid both
        return GERR_G7X_MISS_PQ ;
    }*/
    g72.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g72.srcline=srcline;
    g72.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GR_IS_SETED);
    g72.u=gParamBuf.xu;
    g72.w=gParamBuf.zw;
    g72.r=gParamBuf.r;
    g72.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g72,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck73
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gcodeSaveCheck73(void)
{
    TcompiledG7x g73;
    memset(&g73,0,sizeof(TcompiledG7x));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
            g73.paramType|=GI_IS_VALUE;
        else
            g73.paramType|=GI_IS_PARAM;
        //g73.paramType|=GI_IS_SETED;
        g73.p=gParamBuf.p;
    }
    if(gParamBuf.GHMFST&Q_IS_SETED)
    {
        if(gParamBuf.GHMFST&Q_IS_VALUE)
            g73.paramType|=GK_IS_VALUE;
        else
            g73.paramType|=GK_IS_PARAM;
        //g73.paramType|=GK_IS_SETED;
        g73.q=gParamBuf.q;
    }
    //if((g73.paramType==GI_IS_SETED)||(g73.paramType==GK_IS_SETED) )
    /*
    if(((g73.paramType&GI_IS_SETED)==0)||
    ((g73.paramType&GK_IS_SETED)==0))
    { //pq must be provid both
        return GERR_G7X_MISS_PQ ;
    }
    */
    g73.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g73.srcline=srcline;
    g73.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GR_IS_SETED);
    g73.u=gParamBuf.xu;
    g73.w=gParamBuf.zw;
    g73.r=gParamBuf.r;
    if(g73.r<0)
    {
    	return GERR_VALUE_INVALID;
    }
    g73.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g73,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck7475
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gcodeSaveCheck7475(void)
{
    TcompiledG7x g74;
    memset(&g74,0,sizeof(TcompiledG7x));
    //if thereis mfst code
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
            g74.paramType|=GI_IS_VALUE;
        else
            g74.paramType|=GI_IS_PARAM;
        //g74.paramType|=GI_IS_SETED;
        g74.p=gParamBuf.p;
    }
    if(gParamBuf.GHMFST&Q_IS_SETED)
    {
        if(gParamBuf.GHMFST&Q_IS_VALUE)
            g74.paramType|=GK_IS_VALUE;
        else
            g74.paramType|=GK_IS_PARAM;
        //g74.paramType|=GK_IS_SETED;
        g74.q=gParamBuf.q;
    }
    if(gParamBuf.paramType&GR_IS_SETED)
    {
        g74.paramType|=(gParamBuf.paramType&GR_IS_SETED);
        g74.r=gParamBuf.r;
    }
    if((g74.p<0)||(g74.q<0))
    {
        return GERR_VALUE_INVALID;
    }
    {        //CHECK R
        if(g74.r<0)
        {
            if((gParamBuf.gnum==GCODE_74)&&
            (gParamBuf.paramType&GXU_IS_SETED)) //74
            {
                return GERR_VALUE_INVALID;
            }
            if((gParamBuf.gnum==GCODE_75)&&
            (gParamBuf.paramType&GZW_IS_SETED)) //75
            {
                return GERR_VALUE_INVALID;
            }
        }
    }
    if((gParamBuf.paramType&GI_IS_SETED)||
        (gParamBuf.paramType&GK_IS_SETED))
    {
        if((gParamBuf.paramType&(GXU_IS_SETED|GZW_IS_SETED))==0)
        {
            return GERR_G0001_MISS_XZ;
        }
    }
    g74.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g74.srcline=srcline;
    g74.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC);
    g74.u=gParamBuf.xu;
    g74.w=gParamBuf.zw;
    g74.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g74,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}

/***************************************************************************
*FUNCTION: GcodeCheck76
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gcodeSaveCheck76(void)
{
    TcompiledG7x g76;
    memset(&g76,0,sizeof(TcompiledG7x));
    //if thereis mfst code
    if(SYSparam[94].val==1)
    {
        return GERR_REFUSE_SCREW;
    }
    if(gParamBuf.GHMFST&MST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    if(gParamBuf.GHMFST&F_IS_SETED)
    {
        //F IN g76 is the daocheng,store in k
        g76.f=gParamBuf.f;
        if(gParamBuf.GHMFST&F_IS_VALUE)
            g76.paramType|=GF_IS_VALUE;
        else
            g76.paramType|=GF_IS_PARAM;
        gCompileState.screwf=1; //JUST A FLAG
    }else if(gParamBuf.paramType&GI_IS_SETED){
        //INCH  IS 25400MU AND I IS ENLARGE 1000
        g76.f=gParamBuf.i;
        if(gParamBuf.paramType&GI_IS_VALUE)
            g76.paramType|=GF_IS_VALUE;
        else
            g76.paramType|=GF_IS_PARAM;
        g76.paramType|=GF_IS_INC;
        gCompileState.screwf=1; //JUST A FLAG
        //clear i flags since we had q  to set
        gParamBuf.paramType&=~GI_IS_SETED;
    }
    if(gParamBuf.GHMFST&P_IS_SETED)
    {
        if(gParamBuf.GHMFST&P_IS_VALUE)
            g76.paramType|=GI_IS_VALUE;
        else
            g76.paramType|=GI_IS_PARAM;
        //g76.paramType|=GI_IS_SETED;
        g76.p=gParamBuf.p;
    }
    if(gParamBuf.GHMFST&Q_IS_SETED)
    {
        if(gParamBuf.GHMFST&Q_IS_VALUE)
            g76.paramType|=GK_IS_VALUE;
        else
            g76.paramType|=GK_IS_PARAM;
        //g76.paramType|=GK_IS_SETED;
        g76.q=gParamBuf.q;
    }
    if(gParamBuf.paramType&GR_IS_SETED)
    {
        g76.paramType|=(gParamBuf.paramType&GR_IS_SETED);
        g76.r=gParamBuf.r;
    }
    if((g76.p<0)||(g76.q<0))
    {
        return GERR_VALUE_INVALID;
    }
    g76.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g76.srcline=srcline;
    g76.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC);
    g76.u=gParamBuf.xu;
    g76.w=gParamBuf.zw;
    if((g76.paramType&GXU_IS_SETED)||(g76.paramType&GZW_IS_SETED))
    { //a real g76
        //xz must be both given
        if(!((g76.paramType&GXU_IS_SETED)&&(g76.paramType&GZW_IS_SETED)))
        {
            return GERR_G32_MISS_XZ;
        }
        //check if p q is given
        if(!((g76.paramType&GI_IS_SETED)&&(g76.paramType&GK_IS_SETED)))
        {
            return GERR_G7X_MISS_PQ;
        }
    }/*
    else{ //it is just a param set g76
        //p value should less the 6 char
        if(g76.p>=1000000)
            return GERR_VALUE_INVALID;
        if(g76.q>=99999)
            return GERR_VALUE_INVALID;
        { //r is less ther 99.999mm
        S32 R=unit2Meter4Digit(g76.r);
        if(R>999990)
            return GERR_VALUE_INVALID;
        }
    }*/
    g76.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g76,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}


/***************************************************************************
*FUNCTION: gCodeSaveCheck90
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck90(void)
{
    TcompiledG23 g90;
    //if thereis mfst code
    memset(&g90,0,sizeof(TcompiledG23));
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(((gParamBuf.paramType&GXU_IS_SETED)==0)
    &&((gParamBuf.paramType&GZW_IS_SETED)==0))
    {
        return GERR_G90_MISS_XZ;
    }
    g90.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g90.srcline=srcline;
    g90.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GR_IS_SETED);
    g90.xu=gParamBuf.xu;
    g90.zw=gParamBuf.zw;
    g90.r=gParamBuf.r;
    g90.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g90,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck92
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
* g92 is stroe as a g02 g03 ,the r value store in r, f or i stroe in k as meter
****************************************************************************
*/
U8 gCodeSaveCheck92(void)
{
    TcompiledG23 g92;
    //if thereis mfst code
    if(SYSparam[94].val==1)
    {
        return GERR_REFUSE_SCREW;
    }
    if(gParamBuf.GHMFST&MST_IS_SETED)
    {
        return GERR_CANT_MFST;
    }
    memset(&g92,0,sizeof(TcompiledG23));
    if(gParamBuf.GHMFST&F_IS_SETED)
    {
        //F IN g32 is the daocheng,store in k
        g92.f=gParamBuf.f;
        if(gParamBuf.GHMFST&F_IS_VALUE)
            g92.paramType|=GF_IS_VALUE;
        else
            g92.paramType|=GF_IS_PARAM;
        gCompileState.screwf=1; //JUST A FLAG
    }else if(gParamBuf.paramType&GI_IS_SETED){
        //INCH  IS 25400MU AND I IS ENLARGE 1000
        g92.f=gParamBuf.i;

        //g92.k=gParamBuf.i/25.4; //conver to metor
        if(gParamBuf.paramType&GI_IS_VALUE)
            g92.paramType|=GF_IS_VALUE;
        else
            g92.paramType|=GF_IS_PARAM;
        g92.paramType|=GF_IS_INC;
        gCompileState.screwf=1; //JUST A FLAG
    }else{
        if(gCompileState.screwf==0)
            return GERR_G32_MISS_FI;
    }
    //check p val; head number of screw
    if(gParamBuf.GHMFST&P_IS_VALUE)
    {
        g92.paramType|=GK_IS_VALUE;
    }else if(gParamBuf.GHMFST&P_IS_PARAM)
    {
        g92.paramType|=GK_IS_PARAM;
    }
    g92.k=gParamBuf.p;
    //check q val;
    if(gParamBuf.GHMFST&Q_IS_VALUE)
    {
        g92.paramType|=GI_IS_VALUE;

    }else if(gParamBuf.GHMFST&Q_IS_PARAM)
    {
        g92.paramType|=GI_IS_PARAM;
    }
    g92.i=gParamBuf.q;

    if(((gParamBuf.paramType&GXU_IS_SETED)==0)
    &&((gParamBuf.paramType&GZW_IS_SETED)==0))
    {
        return GERR_G32_MISS_XZ;//need
    }

    g92.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g92.srcline=srcline;
    g92.paramType|=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|
        GR_IS_SETED);
    g92.xu=gParamBuf.xu;
    g92.zw=gParamBuf.zw;
    g92.r=gParamBuf.r;
    g92.srcJump=srcJumpFlag;
    /*
    if(gParamBuf.paramType&GR_IS_SETED)
    {
        g92.paramType|=(gParamBuf.paramType&GR_IS_SETED);
        g92.ir=gParamBuf.r;
    } */
    memcpy(compiledGPointer,&g92,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gCodeSaveCheck94
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck94(void)
{
    TcompiledG23 g94;
    //if thereis mfst code
    memset(&g94,0,sizeof(TcompiledG23));
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    if(((gParamBuf.paramType&GXU_IS_SETED)==0)
    &&((gParamBuf.paramType&GZW_IS_SETED)==0))
    {
        return GERR_G94_MISS_XZ;
    }
    g94.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g94.srcline=srcline;
    g94.paramType=gParamBuf.paramType&
        (GXU_IS_SETED|GXU_IS_INC|GZW_IS_SETED|GZW_IS_INC|GR_IS_SETED);
    g94.xu=gParamBuf.xu;
    g94.zw=gParamBuf.zw;
    g94.r=gParamBuf.r;
    g94.srcJump=srcJumpFlag;
    /*
    if(gParamBuf.paramType&GR_IS_SETED)
    {
        g94.paramType|=(gParamBuf.paramType&GR_IS_SETED);
        g94.r=gParamBuf.r;
    }*/
    memcpy(compiledGPointer,&g94,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG23);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck96
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck96(void)
{
    TcompiledFST g96;
    memset(&g96,0,sizeof(TcompiledFST));
    g96.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g96.srcline=srcline;
    if(gParamBuf.GHMFST&S_IS_SETED)
    {
        g96.paramType=gParamBuf.GHMFST&S_IS_SETED;
        if(gParamBuf.GHMFST&S_IS_SETED)
        {
            g96.value=gParamBuf.s;
        }else{
           g96.value=0;
        }
        gParamBuf.GHMFST&=~S_IS_SETED;
    }
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    g96.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g96,sizeof(TcompiledFST));
    compiledGPointer++;//=sizeof(TcompiledFST);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck97
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck97(void)
{
    TcompiledFST g97;
    memset(&g97,0,sizeof(TcompiledFST));
    g97.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g97.srcline=srcline;
    if(gParamBuf.GHMFST&S_IS_SETED)
    {

        g97.paramType=gParamBuf.GHMFST&S_IS_SETED;
        if(gParamBuf.GHMFST&S_IS_SETED)
        {
           g97.value=gParamBuf.s;
        }else{
           g97.value=0;
        }
        gParamBuf.GHMFST&=~S_IS_SETED;
    }
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    g97.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g97,sizeof(TcompiledFST));
    compiledGPointer++;//=sizeof(TcompiledFST);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck98
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck98(void)
{
    TcompiledFST g98;
    //U16 i;
    memset(&g98,0,sizeof(TcompiledFST));
    g98.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g98.srcline=srcline;
    if(gParamBuf.GHMFST&F_IS_SETED)
    {
        g98.paramType=gParamBuf.GHMFST&F_IS_SETED;
        if(gParamBuf.GHMFST&F_IS_SETED)
        {
           g98.value=gParamBuf.f;
        }else{
           g98.value=0;
        }
        gParamBuf.GHMFST&=~F_IS_SETED;
    }
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    g98.srcJump=srcJumpFlag;
    memcpy(compiledGPointer,&g98,sizeof(TcompiledFST));
    compiledGPointer++;//=sizeof(TcompiledFST);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: GcodeCheck99
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a G code parmeter is valide
****************************************************************************
*/
U8 gCodeSaveCheck99(void)
{
    TcompiledFST g99;
   // U16 i;
    memset(&g99,0,sizeof(TcompiledFST));
    g99.gtype=gParamBuf.gnum;//GTYPE_G|(gParamBuf.gnum);
    g99.srcline=srcline;
    g99.srcJump=srcJumpFlag;
    if(gParamBuf.GHMFST&F_IS_SETED)
    {

        g99.paramType=gParamBuf.GHMFST&F_IS_SETED;
        if(gParamBuf.GHMFST&F_IS_SETED)
        {
            g99.value=gParamBuf.f;
        }else{
           g99.value=0;
        }
        gParamBuf.GHMFST&=~F_IS_SETED;
    }
    if(gParamBuf.GHMFST&MFST_IS_SETED)
    {
        U8 err;
        err=gCodeSaveCheckMFST();
        if(err!=GERR_OK)
            return err;
    }
    memcpy(compiledGPointer,&g99,sizeof(TcompiledFST));
    compiledGPointer++;//=sizeof(TcompiledFST);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: generalMcodeCheck
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a M code parmeter is valide
****************************************************************************
*/
U8 generalMcodeSaveCheck()
{
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: generalHcodeCheck
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function check if a H code parmeter is valide
****************************************************************************
*/
U8 generalHcodeSaveCheck()
{
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: checkJumpCall
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if the M98 call the correct sub program
****************************************************************************
*/
U8 checkJumpCall(void)
{
    U16 i,j;
    for(i=0;i<jumpCount;i++)
    {
        for(j=0;j<jumpPointCount;j++)
        {
            if((jumpList[i].program==jumpPointList[j].prog)
            &&(jumpList[i].tag==jumpPointList[j].tag))
            {
                goto OK_END;
            }
            DEBUGMSG(1,"M98 calling not exicting sub program %d\n",m98Request[i].program);
            return GERR_NO_TAG;
        }
OK_END:
        ;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: preCompileO9XXX
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if the O9000-O9031 proram is ok
* this func should be call
****************************************************************************
*/
U8 preCompileO9XXX(void)
{

    U8 err=GERR_OK;
    gCompiledCt=PREDEF_PROG_CODE_START;
    compiledGPointer=&compiledGbuf[gCompiledCt];
    preO9XXXgCt=0;
    subProgramBufPtr=0;
    O9XXXcount=0;
    /*for(i=1;i<PREDEF_PROG_MAX;i++)
    {
        programList[i].index=(i-1)+PREDEF_PROG_START;
        //programList[0] reserved for main program
        //the sub program's compiled gcode addr is after
        //the prev file code buf
        programList[i].address=gCompiledCt;
        gCompileState.currentProg=programList[i].index;
        programList[i].bufIndex=subProgramBufPtr; // 1+subProgramFileCount++;
        subProgramFileCount++;
        err=FileManagerOpenSubProgram(
            &(subProgramBuf[programList[i].bufIndex]),
            programList[i].index,&subProgramBufPtr);
        if(err!=GERR_OK)
        {
            // if T is set as a sub prog it must prvoid o9000
            if(0==i)
            {
                err=GERR_NO_SUB;
                DEBUGMSG(1,"open sub program %d fail\n",m98Request[i].program);
                programList[i].address=COMPILE_BUF_MAX; //that means error
                goto ERR_END;
            }
            programList[i].address=COMPILE_BUF_MAX;//means nothins there
            continue;
        }
        //now compile this sub program file
        err= Gcompiler(&(subProgramBuf[programList[i].bufIndex][0]),
            compiledGPointer);
        if(err!=GERR_OK)
            goto ERR_END;
        O9XXXcount++;
    }*/
OK_END://cal the real code count
    preO9XXXgCt=gCompiledCt-PREDEF_PROG_CODE_START;
    O9XXXchangeFlag=0; //set the flag that it needno recompile
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: checkM98Call
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if the M98 call the correct sub program
****************************************************************************
*/
U8 checkM98Call(void)
{
    U16 i,j;
    U8 err=GERR_OK;
    subProgramBufPtr=0;
    for(i=0;i<m98Count;i++)
    {
        for(j=0;j<programCount;j++)
        {
            if(m98Request[i].program==programList[j].index)
            {
                m98Request[i].address=programList[j].address;
                m98Request[i].isFile=FALSE;
                goto OK_END;
            }
        }
        // if it's not in the main file,is a outer file
        /*m98Request[i].isFile=TRUE;
        programList[j].index=m98Request[i].program;
        //the sub program's compiled gcode addr is after
        //the prev file code buf
        programList[j].address=gCompiledCt;
        if(subProgramFileCount>=SUB_PROG_MAX)
        {  //too much sub program is called
            err=GERR_STACK_OVF;
            goto ERR_END;
        }
        gCompileState.currentProg=programList[j].index;
        programList[j].bufIndex=subProgramBufPtr; // 1+subProgramFileCount++;
        subProgramFileCount++;
        err=FileManagerOpenSubProgram(
            &(subProgramBuf[programList[j].bufIndex]),
            programList[j].index,&subProgramBufPtr);
        if(err!=GERR_OK)
        {
            err=GERR_NO_SUB;
            DEBUGMSG(1,"open sub program %d fail\n",m98Request[i].program);
            goto ERR_END;
        }
        //now compile this sub program file
        err= Gcompiler(&(subProgramBuf[programList[j].bufIndex][0]),
            compiledGPointer);
        if(err!=GERR_OK)
            return err;
        programCount++;*/
OK_END:
    ;
    }
    return GERR_OK;
ERR_END:
    return err;
}
/***************************************************************************
*FUNCTION: generalHcodeCheck
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check if the m99 return to progarm ok
****************************************************************************
*/
U8 checkM99Return(void)
{
    U16 i,j,k;
    for(i=0;i<m99Count;i++)
    {
        if(m99Request[i].subProgram==programList[0].index)// main prog
        {
            for(k=0;k<jumpPointCount;k++)
            {
                if((jumpPointList[k].prog==programList[0].index)
                &&(m99Request[i].addressTag==jumpPointList[k].tag))
                {
                    goto THIS99OK;
                }
            }
            goto ERR_END;
        }else{
            for(j=0;j<m98Count;j++)
            {
                if(m99Request[i].subProgram==m98Request[j].program)
                {
                    //find out the m99 tag in caller program
                    for(k=0;k<jumpPointCount;k++)
                    {
                        if((m98Request[j].caller==jumpPointList[k].prog)
                        &&(m99Request[i].addressTag==jumpPointList[k].tag))
                        {
                            goto THIS99OK;
                        }
                    }
                }
                //break;
            }
        }
        //go here means error
        goto ERR_END;
THIS99OK :
		;
    }
    return GERR_OK;
ERR_END:
    DEBUGMSG(1,"M98 calling not exicting sub program %d\n",m98Request[i].program);
    return GERR_NO_TAG;
}

// all h code is store in TcompiledARC type


U8 hcodeCheckParamIndex(PcompiledG23 phmacro)
{/*
    U32 index;
    if(phmacro->paramType&P_IS_PARAM)
    {
        index=abs(phmacro->xu);
        if(((index>0)&&(index<GLOBAL_VAR_MAX))||
        ((index>9000)&&((index-9000)<GLOBAL_VAR_MAX)))
        {
           ;
        }else{
            return GERR_VALUE_INVALID;
        }
    }
    if(phmacro->paramType&Q_IS_PARAM)
    {
        index=abs(phmacro->zw);
        if(((index>0)&&(index<GLOBAL_VAR_MAX))||
        ((index>9000)&&((index-9000)<GLOBAL_VAR_MAX)))
        {
           ;
        }else{
            return GERR_VALUE_INVALID;
        }
    }
    if(phmacro->paramType&R_IS_PARAM)
    {
        index=abs(phmacro->r);
        if(((index>0)&&(index<GLOBAL_VAR_MAX))|
        ((index>9000)&&((index-9000)<GLOBAL_VAR_MAX)))
        {
           ;
        }else{
            return GERR_VALUE_INVALID;
        }
    }  */
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hCodeSaveCheck1OP
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check h code with 1 op that is h80 and h99
****************************************************************************
*/
U8 hCodeSaveCheck1OP()
{
    TcompiledG23 hmacro;
    U8 i;
    memset(&hmacro,0,sizeof(TcompiledG23));
    if((gParamBuf.GHMFST&MFST_IS_SETED)!=0)
    {
        return GERR_H_MIX;
    }
    if((gParamBuf.GHMFST&P_IS_SETED)==0)
    {
        return GERR_H_NEEDPARAM;
    }
    switch(gParamBuf.hnum)
    {
        case(80):
            hmacro.gtype=GCODE_H80;
            hmacro.paramType=gParamBuf.GHMFST&P_IS_SETED;
            hmacro.xu=gParamBuf.p;
            break;
        case(99):
            hmacro.gtype=GCODE_H99;
            hmacro.paramType=gParamBuf.GHMFST&P_IS_SETED;
            hmacro.xu=gParamBuf.p;
            break;
        default:
            return GERR_H_UNKNOWN;
            break;
    }
    //chek if p value is ok
    i=hcodeCheckParamIndex(&hmacro);
    if(i!=GERR_OK)
        return i;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hCodeSaveCheck1OP
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check h code with 1 op that is h21 22 24 25
****************************************************************************
*/
U8 hCodeSaveCheck2OP()
{
    TcompiledG23 hmacro;
    U8 i;
    memset(&hmacro,0,sizeof(TcompiledG23));
    if((gParamBuf.GHMFST&MFST_IS_SETED)!=0)
    {
        return GERR_H_MIX;
    }
    if(((gParamBuf.GHMFST&P_IS_SETED)==0)
        ||((gParamBuf.GHMFST&Q_IS_SETED)==0))
    {
        return GERR_H_NEEDPARAM;
    }

    hmacro.gtype=(gParamBuf.hnum<<8)|0x70;
    hmacro.paramType=gParamBuf.GHMFST&(P_IS_SETED|Q_IS_SETED);
    hmacro.xu=gParamBuf.p;
    hmacro.zw=gParamBuf.q;
    i=hcodeCheckParamIndex(&hmacro);
    if(i!=GERR_OK)
        return i;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hCodeSaveCheck1OP
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check h code with 1 op that is 1-5 11-13 23 26 27
* 31-24 ,81-86
****************************************************************************
*/
U8 hCodeSaveCheck3OP()
{
    TcompiledG23 hmacro;
    U8 i;
    memset(&hmacro,0,sizeof(TcompiledG23));
    if((gParamBuf.GHMFST&MFST_IS_SETED)!=0)
    {
        return GERR_H_MIX ;
    }
    if(((gParamBuf.GHMFST&P_IS_SETED)==0)
        ||((gParamBuf.GHMFST&Q_IS_SETED)==0)
        ||((gParamBuf.GHMFST&R_IS_SETED)==0))
    {
        return GERR_H_NEEDPARAM;
    }

    hmacro.gtype=(gParamBuf.hnum<<8)|0x70;
    hmacro.paramType=gParamBuf.GHMFST&(P_IS_SETED|Q_IS_SETED|R_IS_SETED);
    hmacro.xu=gParamBuf.p;
    hmacro.zw=gParamBuf.q;
    hmacro.r=gParamBuf.r;

    i=hcodeCheckParamIndex(&hmacro);
    if(i!=GERR_OK)
        return i;
    hmacro.srcJump=srcJumpFlag;
    hmacro.srcline=srcline;
    memcpy(compiledGPointer,&hmacro,sizeof(TcompiledG23));
    compiledGPointer++;//=sizeof(TcompiledG01);
    gCompiledCt++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: SaveAndCheck
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: check and store the g code had found in ;
****************************************************************************
*/
U8 SaveAndCheck(void)
{
    U8 err;
    U32 i;
    //prevCompiledGPtr=compiledGPointer;
    if(gParamBuf.GHMFST&N_IS_SETED)
    {
        err=gCodeSaveCheckN();
        if(err!=GERR_OK)
            goto ERR_END;
        gParamBuf.GHMFST=gParamBuf.GHMFST&(~N_IS_SETED);
    }
    if(gParamBuf.GHMFST&O_IS_SETED)
    {
        err=gCodeSaveCheckO();
        if(err!=GERR_OK)
            goto ERR_END;
        gParamBuf.GHMFST=gParamBuf.GHMFST&(~O_IS_SETED);
    }
    if(gParamBuf.GHMFST&G_IS_SETED)
    {
        i=checkGindex(gParamBuf.gnum);
        if(i<GCODE_COUNT)
        {
            err=gcode[i].func();
        }else{
            err=GERR_GCMD_UNKNOW;
            goto ERR_END;
        }
    }else{
        err=gCodeSaveCheckMFST();
        //err=GERR_OK;
    }
ERR_END:
    return err;
}


/***************************************************************************
*FUNCTION: unit2Meter4Digit
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: conver the val in input unit to meter 4 digit tail
****************************************************************************
*/
S32 unit2Meter4Digit(S32 val)
{
    double tempVal=0;
    S32 result=0;
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            result=val*10;
            break;
        case(1): //input is inch 4 tail digit
            tempVal=25.4l*val;
            result=tempVal;
            break;
         default:
           // shoulde case a hlt here
            break;
    }
    return result;
}
double unit2Meter4DigitFloat(double val)
{
    double tempVal=0;
    double result=0;
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            result=val*10;
            break;
        case(1): //input is inch 4 tail digit
            tempVal=25.4l*val;
            result=tempVal;
            break;
         default:
           // shoulde case a hlt here
            break;
    }
    return result;
}
/***************************************************************************
*FUNCTION: unit2um
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: conver a input val to um unit
****************************************************************************
*/
S32 unit2um(S32 val)
{
    S32 result;
    if(sysUnit==1)
    {
        double tempVal=25.4l*val/10;
        result=tempVal;
        if((tempVal-result)>0.5)
        {
            result=result+1;
        }
    }
    else
    {
        result=val;
    }
    return result;
}
S32 anti_unit2um(S32 val)
{
    S32 result;
    if (sysUnit==1)
    {
        double tempVal=10l*val/25.4;
        result=tempVal;
        if ((tempVal-result)>0.5)
        {
            result=result+1;
        }
    }
    else
    {
        result=val;
    }
    return result;
}
double unit2umFloat(double val)
{
    double result;
    if(sysUnit==1)
    {
        double tempVal=25.4l*val/10;
        result=tempVal;
    }else{
        result=val;
    }
    return result;
}
/***************************************************************************
*FUNCTION: meter4Digit2Unit
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: conver form meter 4 digit to  program unit
****************************************************************************
*/
S32 meter4Digit2Unit(S32 val)
{
    double tempVal=0;
    S32 result=0;
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            result=val/10;
            break;
        case(1): //input is inch 4 tail digit
            tempVal=val/25.4l;
            result=tempVal;
            break;
         default:
           // shoulde case a hlt here
            break;
    }
    return result;
}
/***************************************************************************
*FUNCTION: initCodeBuf
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: init the gcode parameter store buffer before compile a new gcode
*
****************************************************************************
*/
void initCodeBuf(void)
{
    //memset(gParamBuf,0,sizeof(TgParamBuf));
    //gParamBuf.gname='G';
    //multigcode=FALSE;
    srcline=0;
    sourceCT=0;
    MDI_sourceCT=0;
    gCompileState.currentProg=0;
    gCompileState.GG01=0;
    gCompileState.GG02=97;
    {
        U8 temp=IIC_Read1(IICADDR_G98G99);
        if(temp==99)
        {
            gCompileState.GG03=99;
        }else{
            gCompileState.GG03=98;
        }
    }
    gCompiledCt=0;
    //programCount=0;
    m98Count=0;
    m99Count=0;
    jumpCount=0;
    jumpPointCount=0;
    //the main program set as o0000
    programList[0].index=0;
    programList[0].address=0;
    programList[0].bufIndex=0;
    //as o9000-o9xxx is used, programCount
    programCount=O9XXXcount+1;

    subProgramFileCount=0;
    memset(&gparam,0,sizeof(gparam));
    memset(&gparamBak,0,sizeof(gparamBak));
    memset(&gParamBuf,0,sizeof(gParamBuf));
    gParamBuf.GHMFST=0;
    gParamBuf.paramType=0x44444444;
    //reset all compile array
    //programCount=0;
    memset(&programList[PREDEF_PROG_MAX],0,sizeof(TgProgramAddress)*(PROG_MAX-PREDEF_PROG_MAX));
    jumpCount=0;
    memset(jumpPointList,0,sizeof(TgJumpPointAddress)*JUMP_POINT_MAX);
    callDeep=0;
    memset(gcallStack,0,sizeof(TgcallStack)*CALL_DEEP_MAX);
//    prevgParamBuf=gParamBuf;
    unitMode=sysUnit;
    if(sysUnit==1)
        compileDigit=4;
    else
        compileDigit=3;
    autoBreakPoint.flag=0;
    /*
    switch(sysUnit)
    {
        case(0):
            compileDigit=3;
            break;
        case(1):
            compileDigit=4;
            break;
        default:
            sysUnit=0;
            compileDigit=3;
    }
    */
    //if(sysShowUnit)
    //    compileDigit++;

}
/***************************************************************************
*FUNCTION: reinitCodeBuf
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: reinit the gcode parameter store buffer between two compile process
*
****************************************************************************
*/
U8 reinitCodeBuf(void)
{
    //U8 err;
    memset(&gParamBuf,0,sizeof(gParamBuf));
    gParamBuf.GHMFST=0;
    gParamBuf.paramType=0x44444444;
    return GERR_OK;
}

//**************************************************************************

/***************************************************************************
*FUNCTION: process
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: this function compile one gcode or m or h code
*
****************************************************************************
*/
U8 processG(char* str)
{
    U8 err;
    U8* tempstreamPtr;
    streamPtr=str;
    macro_use_param_num = MACRO_VAR_START;
    while(*streamPtr==' ')
    {
        streamPtr++;
    }
    tempstreamPtr=streamPtr;
    if(*streamPtr=='#')
    {
        err = Macro_Scan_Paren(0);
        if(err==GERR_CODE_DONE)
        {
            err=GERR_OK;
        }
        return err;
    }else{
        if(Scan_Macro_Cmd()>MACRO_SPECIAL)
        {
            streamPtr=tempstreamPtr;
            err = Scan_Macro_Special();
            if(err==GERR_CODE_DONE)
            {
                err=GERR_OK;
            }
            return err;
        }else{
            streamPtr=tempstreamPtr;
        }
    }
    while(*streamPtr!=0)
    {
MULTI_G_SCAN:
        err=scanParam();
        if(err!=GERR_OK)
        {
            if(err==GERR_CODE_DONE)
            {
                err=SaveAndCheck();
                if(err!=GERR_OK)
                {
                    return err;
                }else if(gparamBak.name!=0)
                {   //check if the prev g code is allow to be multi in a line
                    gparam=gparamBak;
                    memset(&gparamBak,0,sizeof(gparamBak));
                    reinitCodeBuf();
                    err=gkeywordStore[gparam.index].func();
                    if(err!=GERR_OK)
                    {
                        return err;
                    }else{
                        goto MULTI_G_SCAN;
                    }
                }
            }
            return err;
        }
    }
    if(err!=GERR_OK)
        return err;
    return GERR_OK;
}



/***************************************************************************
*FUNCTION: gcompiler
*PARAMETER :str gcode src buf; isfile ,0 yes 1 comline
*RETURN : err code
*DESCRIPTION: this function compile one gcode or m or h code
****************************************************************************
*/
U8 Gcompiler(U8* str,PcompiledG23 gcodeBuf)
{
    U8 glinebuf[255];
    U8* codePtr;
    U8 linelen;
    U8 err;
    U32 notePairDeep;
    macro_if_layer=0;
    macro_while_layer=0;
    macro_exit_index=0;
    errwhilesrcline=0;
    errifsrcline=0;
    errannotatesrcline=0;
    codePtr=str;
    compiledGPointer=gcodeBuf;
    while((*codePtr)!=0)
    {
        gsrc2compiled[srcline]=(U32)codePtr;
        srcJumpFlag=0;
        //copy one gcode line to streamptr;
        linelen=0;
        while((*codePtr!='\n')
            &&(*codePtr!='\0')&&(linelen<250))
        {
            if(*codePtr==')')
            {  //with out a ( ,is error
                return GERR_ANNOTATE;
            }
            if(*codePtr=='(') //pass annotate
            {
                notePairDeep=1;
                errannotatesrcline=srcline;
                codePtr++;
                while((notePairDeep>0)&&(*codePtr!='\0'))
                {
                    if(*codePtr=='\n')
                    {
                        srcline++;
                        codePtr++;
                        //if(*codePtr!='\0')
                        gsrc2compiled[srcline]=(U32)codePtr;
                    }else if(*codePtr=='(')
                    {
                        notePairDeep++;
                        codePtr++;
                    }else if(*codePtr==')')
                    {
                        notePairDeep--;
                        codePtr++;
                    }else
                        codePtr++;
                }
                /*
                if(*codePtr==')')
                {
                    codePtr++;
                }else
                */
                if(notePairDeep>0)
                {
                    srcline=errannotatesrcline;
                    return GERR_ANNOTATE;
                }
            }else if(*codePtr=='/')  //pass the jump over code
            {
                if(linelen==0)
                {
                    srcJumpFlag=1;
                }else{
                    glinebuf[linelen]=*codePtr;
                    linelen++;
                }
                codePtr++;
            }else if((*codePtr=='\r')||(*codePtr==' ')){
                codePtr++; //just pass the %
            }else{
                glinebuf[linelen]=*codePtr;
                linelen++;
                codePtr++;
            }
        }
       glinebuf[linelen]=0; //add null end of string;
        //---------------------------------------------
        //precess compile one gcode src line
        streamPtr=glinebuf;
        while(*streamPtr!=0)
        {
            err=processG(streamPtr);
            if(err!=GERR_OK)
            {
                goto ERR_END;
            }
            if(gCompiledCt>=(COMPILE_BUF_MAX-1))
            {
                err=GERR_TOOMANY;
                goto ERR_END;
            }
            reinitCodeBuf();
        }
        // pass over the empty line;
        if(*codePtr=='\n')
        {
            srcline++;
            codePtr++;
        }
    }
    if(macro_if_layer!=0)
    {
        srcline=errifsrcline;
        err=GERR_IF_LACK_END;
    }
    if(macro_while_layer!=0)
    {
        srcline=errwhilesrcline;
        err=GERR_LOOP_LACK_END;
    }
ERR_END:
    if(err==GERR_OK)
    {
        sourceCT=srcline;
        MDI_sourceCT=srcline;
    }
    return err;
}
/***************************************************************************
*FUNCTION: gexecErrHandle
*PARAMETER :void
*RETURN :
*DESCRIPTION: handle the err happend in gcode execute
****************************************************************************
*/
void gexecErrHandle()
{
    //handle errors here
    //we can make alarm when prev code had done;
    if((DSPState&BIT_CODE_OVER)&&
    ((gexecErrInsend==FALSE)&&(STDruncount>=(STDsendcount-1)))||
    ((gexecErrInsend==TRUE)&&(STDruncount>=(STDrealsendcount-1)))||
       (trace_virtual_run==1))
    {
        switch(gexecError)
        {
            case(GERR_S_REVERSE):
                ALARM_GRP1|=ALM_GRP1_S_REVERSE;
                break;
            case(GERR_SRUN_IN_TLOSE):
                ALARM_GRP1|=ALM_GRP1_SRUN_IN_TLOSE;
                break;
            case(GERR_TLOSE_IN_SRUN):
                ALARM_GRP1|=ALM_GRP1_TLOSE_IN_SRUN;
                break;
            case(GERR_NOSS_M0304):
                ALARM_GRP1|=ALM_GRP1_NOSS_M0304;
                break;
            case(GERR_NOFEED_G1):
                ALARM_GRP1|=ALM_GRP1_NOFEED_G1;
                break;
            case(GERR_G32_MISS_FI):
                ALARM_GRP1|=ALM_GRP1_SCREW_NOF;
                break;
            case(GERR_ARC_RERR):
                ALARM_GRP1|=ALM_GRP1_ARC_RERR;
                break;
            case(GERR_SCREW_NOS):
                ALARM_GRP1|=ALM_GRP1_SCREW_NOS;
                break;
            case(GERR_PARAM_VALERR):
                ALARM_GRP1|=ALM_GRP1_PARAM_VALERR;
                break;
            case(GERR_G1SPEED):
                ALARM_GRP1|=ALM_GRP1_G1_SPEED;
                break;
            case(GERR_SPINSPEED):
                ALARM_GRP1|=ALM_GRP1_SPIN_SPEED;
                break;
            case(GERR_NO_TAG):
                ALARM_GRP1|=ALM_GRP1_NO_TAG;
                break;
            case(GERR_H_EXEC):
                ALARM_GRP1|=ALM_GRP1_MACRO_RUNERR;
                break;
            case(GERR_G7XSTARTERR):
                ALARM_GRP1|=ALM_GRP1_G7X_START;
                break;
            case(GERR_G_UNKOWN):
                ALARM_GRP1|=ALM_GRP1_GCODE_UNDEF;
                break;
            case(GERR_ALINE_NOCROSS):
                ALARM_GRP1|=ALM_GRP1_ALINE_NOCROSS;
                break;
            case(GERR_CHAMFER_TOOBIG):
                ALARM_GRP1|=ALM_GRP1_CHAMFER_TOOBIG;
                break;
            default:
                ALARM_GRP1|=ALM_GRP1_GCODE_UNDEF;
                break;
        }
        gexecState=GEXEC_EXERR_HANDLED;
//        PLC_NCSTAT_AUTOSTOP;
        pushTCGcounter=0;
    }
}
/***************************************************************************
*FUNCTION: Macro_Before_G
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: execute the g code pass compile
****************************************************************************
*/
U8 Macro_Before_G(void)
{
    U8 err=0;
    S16 adj;
    while((execGptr->gtype&0xff)==0x71)
    {
        err=Macro_Exec(execGptr->gtype, &adj);
        if(err!=GERR_OK)
        {
            gexecError=err;
            gexecState=GEXEC_EXERR;
            return err;
        }
        //since macro error can't be pass by normal,test here
        if(ALARM_GRP1&ALM_GRP1_MACRO_RUNERR)
        {
            gexecError=GERR_H_EXEC;
            gexecState=GEXEC_EXERR;
            return err;
        }
    }
    return err;
}
/***************************************************************************
*FUNCTION: Goto_Next_G
*PARAMETER :void
*RETURN : PcompiledG23 errcode
*DESCRIPTION: execute the g code pass compile
****************************************************************************
*/
PcompiledG23 Goto_Next_G(PcompiledG23 exec, U8* flag)
{
    PcompiledG23 prevexecGptr;
    PcompiledG23 res;
    U32 prevgrunPtr=0;
    U8 err=0;
    *flag=GERR_OK;
    prevexecGptr = execGptr;
    prevgrunPtr = grunPtr;
    execGptr = exec;
    while((execGptr->gtype&0xff00)!=0)
    {
        if((execGptr->gtype&0xff)==0x71)
        {
            err = Macro_Before_G();
            if(err!=GERR_OK)
                break;
        }else{

            execGptr++;

        }
    }
    res = execGptr;
    execGptr = prevexecGptr;
    grunPtr = prevgrunPtr;
    if(err!=0)
    {
        *flag = err;
    }
    return res;
}
/***************************************************************************
*FUNCTION: execGcode
*PARAMETER :void
*RETURN : err code
*DESCRIPTION: execute the g code pass compile
****************************************************************************
*/
U8 execGcode(void)
{
    U8 err;
    if(SYS_MODE_AUTO!=sysMode)
    	return;
    if((gexecState==GEXEC_RESET)||(gexecState==GEXEC_CMPLE)
        ||(gexecState==GEXEC_DONE))
        return GERR_OK;
    ///////////////////////////////////////////////////
    //write two fait gcode to the buffer for dsp
    {
        tsCODE_F tempf;
    	tsCODE_G00 tempg0;
    	static INT32U count=1;
        static INT8U fsended=0;
        if(fsended==0)
        {
            tempf.CMDMain=0x64;
            tempf.CMDSub=0x04;
            tempf.F=100;
            tempf.SendCountD=count;
            tempf.SendCountA=count;
            tempf.Length=16;
            shm_cycBufWrite(CYCBUF_GCODE, &tempf, 4);
            fsended=1;
            count++;
        }
        
    	tempg0.CMDMain=0;
    	tempg0.CMDSub=0;
    	tempg0.SendCountD=count;
    	tempg0.SendCountA=count;
    	tempg0.X=100000;
    	tempg0.Y=100000;
    	tempg0.Z=0;
    	tempg0.IV=0;
    	tempg0.V=0;
    	tempg0.Length =32;
    	shm_cycBufWrite(CYCBUF_GCODE, &tempg0, 8);
    	count++;
    	tempg0.X=0;
    	tempg0.Y=0;
    	tempg0.SendCountD=count;
    	tempg0.SendCountA=count;
    	shm_cycBufWrite(CYCBUF_GCODE, &tempg0, 8);
    	return GERR_OK;
    }
    ///////////////////////////////////////////////////

    if(gexecState>GEXEC_DONE)
    {
        if(gexecState==GEXEC_EXERR)
        {
            gexecErrHandle();
            //return;
        }
    }
    if((gexecState==GEXEC_START)||(gexecState==GEXEC_AUTO_START))
    {
        int fd;
        int flen;
        /*
        memset(openFileName,0,RECORD_FILE_NAME_LEN);
         strcpy(openFileName,"NCfile");
        if ((fd = open (openFileName, O_RDWR)) < 0)
        {
            if ((fd = open ("NCfile", O_RDWR)) < 0)
            {
                   perror ("open nc error");
                   return -1;
            }
            memset(openFileName,0,RECORD_FILE_NAME_LEN);
            strcpy(openFileName,"NCfile");
        }
        memset(editbuf,0,EDIT_BUFFER_SIZE);
        flen = filelength(openFileName);
        read(fd,editbuf,flen);
        if(editbuf[flen-1]!=0X0A)
        {
            editbuf[flen]=0X0D;
            editbuf[flen+1]=0X0A;
            flen=flen+2;
        }
        editbuf[flen]='\0';
        flen=strlen(editbuf);
        editHasFile = 1;
        close(fd);
        */
        initCodeBuf();
        // here we asum that g code all ways compile exec once at all
        /*if(mdimode.inmdi==1)
        {
            if(mdimode.runO9XXX!=0)
            {
                err=Gcompiler(editbuf_O9XXX, compiledGbuf);
            }else{
                err=Gcompiler(editbuf_MDI, compiledGbuf);
            }
        }else*/{
            err=Gcompiler(editbuf, compiledGbuf);
        }
        if(err!=GERR_OK) goto ERR_HAPPEND;
        //if there's sub program called, find and compiled them
        err=checkM98Call();
        if(err!=GERR_OK) goto ERR_HAPPEND;
        err=checkM99Return();
        if(err!=GERR_OK) goto ERR_HAPPEND;
    ERR_HAPPEND:
        if(err!=GERR_OK)
        {
            //point the edit pointer to the err line
            //editJump2Line(srcline);
            EventJump=1;
            EventJumpNum=srcline;
            gexecState=GEXEC_CERR;
            trace_virtual_run=0;
            trace_data_record=0;//出现编译错误，清空画图
            goto ERR_END;
        }
        if(gexecState==GEXEC_START)
        {
            trace_data_record=0;//清空画图
//            showHint(GERR_CMPL_OK,SHOW_TIME_QUICK);
        }
        if(GEXEC_AUTO_START==gexecState)
        {
            gexecState=GEXEC_RUNINIT;
        }else{
            gexecState=GEXEC_CMPLE;
        }
        Trace_Re_Print();
        #ifndef TEST_COMPLIE
        if(refFounded==0)
        {
            if(SYS_MODE_AUTO==sysMode)
                sysModeChange(KEY_MDI);
        }
        #else
            gexecState=GEXEC_RUNINIT;
        #endif

    }
    //------------------------------------------
    //all thing fallow nee to exec in auto mode
    #ifndef TEST_COMPLIE
    if(sysMode!=SYS_MODE_AUTO)
    {
        return 1;
    }
    #endif
    if(gexecState==GEXEC_RUNINIT)
    {
        //check system is lock by password?
        if(passValid==0)
        {
            gexecState=GEXEC_CMPLE;
            ALARM_GRP2|=ALM_GRP2_OUTDATE;
            return GERR_OK;
        }
        //after seting every thing inited ,we start to run
        //chek the chuck is lost or tired
        /*
        if(gWorkState.chuck==12)
        {
            autoRunStart();
            gexecState=GEXEC_RUN;
            PLC_NCSTAT_AUTORUN;
        }else{
            showHint(GERR_SRUN_TLOSE, SHOW_TIME_NORMAL);
            gexecState=GEXEC_CMPLE;
        }*/
        autoRunStart();
        gexecState=GEXEC_RUN;
//        PLC_NCSTAT_AUTORUN;
    }
    #ifndef TEST_COMPLIE
    //add a test on f grade if zero ,do onthing
    if((rapidGrade==0)||(feedGrade==0))
        return 1;
    #else
    dimMode=MODE_DIM;
    #endif

    #ifdef TEST_COMPLIE
    { //fait run to test compile
        if(gexecState<GEXEC_DONE)
        {
            err=gCompiled2TCG(compiledGbuf,FALSE);
            toolCompent();
            return;
        }
    }
    #endif
    //wait local_over
    if((DSPState&BIT_LOCA_OVER))
    {
        if((gexecState>=GEXEC_RUN)&&(gexecState<GEXEC_DONE))
        {
            err=gCompiled2TCG(compiledGbuf,FALSE);
            Tool_Compensation();
            if(trace_virtual_run==0)
            {
                runBatCode();
            }else{
                while(!CYCLE_BUF_EMPTY(DGwptr,DGrptr))
                {//仿真轨迹在刀补函数中记录，虚拟运行不发代码到DSP，直接在这里清空
            		 CYCLE_BUF_RINC(DGrptr,DG_BUF_MAX);
                }
                if(gexecState==GEXEC_TOOLCE)
                {//所有代码完成记录，结束虚拟运行
                    gexecState=GEXEC_CMPLE;
                    trace_virtual_run=0;
                }
            }
            //cal used time
            /*if((sysMode==SYS_MODE_AUTO)&&
            (!((pauseFlag==1)||
            ((singleModeFlag==1)&&(DSPState&BIT_SINGLE_END)))))
            {*/
            //    cutTimeReg++;
            //}
        }else if(gexecState==GEXEC_EXERR)
        {
            if(pushTCGcounter<1)
            {
                pushTCGbyFaitG01();
                pushTCGcounter++;
            }
            Tool_Compensation();
            if(trace_virtual_run==0)
            {
                runBatCode();
            }
        }
    }

    return GERR_OK;
ERR_END:
    showHint(err, SHOW_TIME_FEVER);
    return err;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************

/*
***************************************************************************
*FUNCTION: gCompiled2TCG
*PARAMETER :cpdGcode g code after compile
*RETURN : void
*DESCRIPTION: exec g code step one ,conver the compiled g code to before
*  tool compensation form; prepare for tool compensation.
****************************************************************************
*/

U8 gCompiled2TCG(TcompiledG23* cpdGcode,U8 comp)
{
    U32 gnum;
    U8 err=GERR_OK;
    U8 ct=0;
    S16 adj=0; //for adjusting the cycle time of explain gcode
    if(gexecState>=GEXEC_READE)
    {
        return err;
    }
    for(ct=0;ct<GCODEC_PRE_CYCLE;ct=ct+adj+1)
    {
        adj=0;
        if(trace_virtual_run==1)
        {//虚拟运行，一次性把缓冲区填满
            ct=0;
        }
    	if(gexecState>=GEXEC_READE)
    		return err;
        if((grunPtr>=gCompiledCt)&&(0==callDeep))//we had finish runing
        {
            if(gexecState<GEXEC_READE)
            {
                if(mdimode.mdirunning==1)
                {
                    pushTCGbyFait_MDI();
                }else{
                    //pushTCGbyFaitG01();
                    pushTCGbyFait_MDI();
                }
                gexecState=GEXEC_READE;
            }
            return err;
        }
        //it must at lease have 20 buf space to store one g and it's mfst
        if(CYCLE_BUF_DEEP(TCGwptr, TCGrptr, TCG_BUF_MAX)>(TCG_BUF_MAX/2))
            return err;

   // EXEC_ONEG:
        if(compoundGcode!=0)
        {
            gnum=compoundGcode;
        }else{
            gnum=execGptr->gtype;
            if(execGptr->srcJump==TRUE)
            {
                if(SYSparam[97].val==1)
                {
                    if(waitBufClear()!=GERR_OK)
                        return GERR_OK;
                }
                if(jumpSegFlag==TRUE)
                {
                    //repeat until we found a not jump or code over;
                    while((execGptr->srcJump==1)&&(grunPtr<gCompiledCt))
                    {
                        execGptr++;
                        grunPtr++;
                    }
                    if((grunPtr<gCompiledCt)&&(grunPtr<PREDEF_PROG_CODE_START))
                    {
                        gnum=execGptr->gtype;
                    }else{
                        pushTCGbyFait_MDI();
                        return GERR_OK;
                    }
                }
            }
        }
        Errsrc = execGptr->srcline;
        switch(gnum)//>>24)
        {
            case (GCODE_M00):
            case (GCODE_M03):
            case (GCODE_M04):
            case (GCODE_M05):
            case (GCODE_M08):
            case (GCODE_M09):
            case (GCODE_M10):
            case (GCODE_M11):
            case (GCODE_M12):
            case (GCODE_M13):
            case (GCODE_M19):
            case (GCODE_M32):
            case (GCODE_M33):
            case (GCODE_M41):
            case (GCODE_M42):
            case (GCODE_M43):
            case (GCODE_M44):
                err=gMcode2TCG();
                break;
            case (GCODE_M20):
                err=Mcode20WorkCT();
                break;
            case (GCODE_M30):
                err=M302TCG();
                //stop runing now

                break;
                /*
            case(GCODE_M81):
            case(GCODE_M82):
            case(GCODE_M83):
            case(GCODE_M84):
            case(GCODE_M85):
            case(GCODE_M86):
            case(GCODE_M87):
            case(GCODE_M88):
            case(GCODE_M89):
                err=M8X2TCG();
                break;*/
            case (GCODE_M91):
                err=M91return();
                break;
            case (GCODE_M98):
                err=M98Call();
                break;
            case (GCODE_M99):
                err=M99return();
                break;
            case (GCODE_M15):
                err=M15cycle();
                break;
            case (GCODE_F):
            case (GCODE_S):

            case (GCODE_M50):
            case (GCODE_M65):
                err=gFST2TCG();
				break;
			case (GCODE_T):
			    err=gT2TCG();
                adj=10;
                break;
            case(0):
            case(1):
                err=gLine2TCG();
                break;
            case(2):
            case(3):
                err=gArc2TCG();
                break;
            case(4):
                err=gPause2TCG();
                break;
            case(20):
            case(21):
                err=g2X2TCG();
				break;
            case(28):
                err=gREF2TCG();  //REF 1 MACH
                break;
            case(30):
                err=gSETP2TCG();  //REF 2345
                break;
            case(32):
                err=gScrew2TCG();
                adj=8;
                break;
            case(33):
                err=g33Screw2TCG();
                adj=16;
                break;
            case(40):
            case(41):
            case(42):
                err=gToolOpt2TCG();
                break;
            case(50):
                err=g502TCG();
                break;
            case(GCODE_54):
                err=g5x2TCG();
                break;
            case(GCODE_65):
                err=g65Call();
                break;
            case(70):
                err=g702TCG();
                adj=3;
                break;
            case(71):
                err=g712TCG();
                adj=4;
                break;
            case(72):
                err=g722TCG();
                adj=4;
                break;
            case(73):
                err=g732TCG();
                adj=3;
                break;
            case(74):
            case(75):
                err=g74752TCG();
                adj=4;
                break;
            case(76):
                err=g762TCG();
                adj=12;
                break;
            case(90):
                err=g90942TCG();
                adj=4;
                break;
            case(92):
                err=g922TCG();
                adj=11;
                break;
            case(94):
                err=g90942TCG();
                adj=4;
                break;
            case(96):
            case(97):
                err=g96972TCG();
                break;
            case(98):
            case(99):
                err=g98992TCG();
                adj=2;
                break;

            default:
                err=GERR_G_UNKOWN;
                if((gnum&0xff)==0x70)
                {
                    err=hcodeExec(gnum, &adj);
                    if(err!=GERR_G_UNKOWN)
                        break;
                }else if((gnum&0xff)==0x71){
                    err=Macro_Exec(gnum, &adj);
                    if(err!=GERR_G_UNKOWN)
                        break;
                }
                //gexecError=GERR_G_UNKOWN;
                //gexecState=GEXEC_EXERR;
                //ALARM_GRP1|=ALM_GRP1_GCODE_UNDEF;
                DBMSG_GCODE("GCP unkonw gcode %d\n",gnum);
                break;
        }
        if(err!=GERR_OK)
        {
            gexecError=err;
            gexecState=GEXEC_EXERR;
            //break; // break the for cycle
            return err;
        }
        //since macro error can't be pass by normal,test here
        if(ALARM_GRP1&ALM_GRP1_MACRO_RUNERR)
        {
            gexecError=GERR_H_EXEC;
            gexecState=GEXEC_EXERR;
            //break; // break the for cycle
            return err;
        }
        if(ALARM_GRP3)
        {
            break;
        }
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gMcode2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send cimpiled m code to Tool compensation model
****************************************************************************
*/

U8 gMcode2TCG()
{
   PcompiledM   mptr;
   TTCGmcode  tcgm;
   TTCGfst tcgfst;
   mptr=(PcompiledM)execGptr;
   tcgm.gnum=mptr->gtype;
   switch (tcgm.gnum)
   {
       case(GCODE_M03):
           if(gC2TCState.chuck==13)
           {
               return GERR_SRUN_IN_TLOSE;
           }
           if(gC2TCState.sdir==4)
           {
               return GERR_S_REVERSE;
           }
           if(((gC2TCState.GG02==GCODE_97)&&(gC2TCState.s==0))||
           ((gC2TCState.GG02==GCODE_96)&&(gC2TCState.slinespeed==0)))
           {
               return GERR_NOSS_M0304;
           }
           gC2TCState.sdir=3;
           break;
       case(GCODE_M04):
           if(gC2TCState.chuck==13)
           {
               return GERR_SRUN_IN_TLOSE;
           }
           if(gC2TCState.sdir==3)
           {
               return GERR_S_REVERSE;
           }
           if(((gC2TCState.GG02==GCODE_97)&&(gC2TCState.s==0))||
           ((gC2TCState.GG02==GCODE_96)&&(gC2TCState.slinespeed==0)))
           {
               return GERR_NOSS_M0304;
           }
           gC2TCState.sdir=4;
           break;
       case(GCODE_M05):
           gC2TCState.sdir=5;
           break;
       case(GCODE_M10):
           if(gC2TCState.sdir!=5)
           {
               return GERR_TLOSE_IN_SRUN;
           }
           gC2TCState.tail=10;
           break;
       case(GCODE_M11):
           if(gC2TCState.sdir!=5)
           {
               return GERR_TLOSE_IN_SRUN;
           }
           gC2TCState.tail=11;
           break;
       case(GCODE_M12):
           gC2TCState.chuck=12;
           break;
       case(GCODE_M13):
           if(gC2TCState.sdir!=5)
           {
               return GERR_TLOSE_IN_SRUN;
           }
           gC2TCState.chuck=13;
           break;
       case(GCODE_M19):
           gC2TCState.sdir=5;
           break;
       default:
           break;
   }

   tcgm.sendCount=STDsendcount++;
   tcgm.srcLine=mptr->srcline;
   tcgm.srcCode=grunPtr;
   *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
   CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
   execGptr++;
   grunPtr++;
   DBMSG_M(tcgm.gnum,tcgm.sendCount);
   return GERR_OK;
}
/***************************************************************************
*FUNCTION: M302TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send cimpiled M30 gcode to Tool compensation model
****************************************************************************
*/
U8 M302TCG()
{
    PcompiledM   mptr;
    TTCGmcode  tcgm;
    mptr=(PcompiledM)execGptr;
    tcgm.gnum=mptr->gtype;
    //add a cool stop gcode
    if(gC2TCState.sdir!=5)
    {
       tcgm.gnum=GCODE_M05;
       tcgm.sendCount=STDsendcount;
       tcgm.srcLine=mptr->srcline;
       tcgm.srcCode=grunPtr;
       *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
       CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
       DBMSG_M(tcgm.gnum,tcgm.sendCount);
    }
    //add a cool stop gcode
    if(SYSparam[92].val == 0){
       tcgm.gnum=GCODE_M09;
       tcgm.sendCount=STDsendcount;
       tcgm.srcLine=mptr->srcline;
       tcgm.srcCode=grunPtr;
       *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
       CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
       DBMSG_M(tcgm.gnum,tcgm.sendCount);
    }
    if(gC2TCState.GG04!=GCODE_40)
    {
       gC2TCState.GG04=GCODE_40;
       tcgm.gnum=GCODE_40;
       tcgm.sendCount=STDsendcount;
       tcgm.srcLine=mptr->srcline;
       tcgm.srcCode=grunPtr;
       *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
       CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
       DBMSG_M(tcgm.gnum,tcgm.sendCount);
    }
    tcgm.gnum=GCODE_M30;
    tcgm.sendCount=STDsendcount++;
    tcgm.srcLine=mptr->srcline;
    tcgm.srcCode=grunPtr;
    *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    gexecState=GEXEC_READE;
    execGptr++;
    grunPtr++;
    DBMSG_M(tcgm.gnum,tcgm.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gFST2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send cimpiled fst gcode to Tool compensation model
****************************************************************************
*/
U8 gFST2TCG()
{
    PcompiledFST fstptr;
    TTCGfst tcgfst;
    //U16 type=execGptr->gtype;

    fstptr=(PcompiledFST)execGptr;
    tcgfst.gnum=execGptr->gtype;
    if(fstptr->paramType&(T_IS_VALUE|F_IS_VALUE|S_IS_VALUE))
    {
        tcgfst.value=fstptr->value;
    }else if(tcgfst.gnum==GCODE_F){
        //it is a param
        tcgfst.value=getVarValue(fstptr->value);
    }else{
        //it is a param
        tcgfst.value=getVarValuePQ(fstptr->value);
    }
    if(tcgfst.gnum==GCODE_F)
    {
        gC2TCState.f=tcgfst.value;
        //check speed limit
        if((gC2TCState.f>(SYSparam[169].val*1000))||
        ((gC2TCState.GG03==GCODE_99)&&
          ((gC2TCState.s*gC2TCState.f)>(SYSparam[169].val*1000))))
            return GERR_G1SPEED;
        //if(gC2TCState.f==0)
        //    return GERR_NOFEED_G1;
        if(falseRunFlag==1)
        {
            if(gC2TCState.GG03==GCODE_99)
            {
                if(gC2TCState.s!=0)
                {
                    tcgfst.value=SYSparam[152].val*1000/gC2TCState.s;
                }else{ //assurm s is 1000
                    tcgfst.value=SYSparam[152].val*1000/1000;
                }
            }else{ // g98
                tcgfst.value=SYSparam[152].val*1000;//max mannual run speed
            }
        }
    }else if(tcgfst.gnum==GCODE_S)
    {
        gC2TCState.s=tcgfst.value;
        if(gC2TCState.GG02==GCODE_97)
        {
            if(gC2TCState.s>SYSparam[168].val)
                gC2TCState.s=SYSparam[168].val;
            //return GERR_SPINSPEED;
        }else{ //is g96 mode
            tcgfst.gnum=GCODE_96;
            gC2TCState.slinespeed=tcgfst.value;
            if(sysUnit==1) //inch unit,conver to meter mm
            {
                tcgfst.value=tcgfst.value*25.4;
            }else{
                tcgfst.value=tcgfst.value*1000; // m to mm
            }
            if(0)
            {
                //Conver line speed to rpm
                U32 newrpm;
                U32 linespeed;
                U32 dim;

                if(dimMode)
                {
                    dim=abs(gC2TCState.x);
                }else{
                    dim=abs(gC2TCState.x*2);
                }
                dim=unit2Meter4Digit(dim)/10000; //conver to meter mm
                if(dim==0) dim=1;
                if(sysUnit==1) //inch unit,conver to meter mm
                {
                    tcgfst.value=tcgfst.value*25.4;
                }else{
                    tcgfst.value=tcgfst.value*1000; // m to mm
                }
                newrpm=tcgfst.value/(PI*dim);
                tcgfst.value=newrpm;
                if(tcgfst.value<10)
                    tcgfst.value=10;
                //we don't limit the rpm here,
                //it will make g96 cal error rpm if dim is tool small
                //dsp should do the work
            }
        }
    }/*else if(tcgfst.gnum==GCODE_T)
    {
        U8 index;
        gC2TCState.x=gC2TCState.x+gC2TCState.shiftx;
        gC2TCState.z=gC2TCState.z+gC2TCState.shiftz;
        gC2TCState.t=tcgfst.value;
        index=gC2TCState.t%100;
        gC2TCState.shiftx=meter4Digit2Unit(toolCompensation[index].x);
        if(dimMode)
        {
            gC2TCState.shiftx*=2;
        }
        gC2TCState.x=gC2TCState.x-gC2TCState.shiftx;
        gC2TCState.shiftz=meter4Digit2Unit(toolCompensation[index].z);
        gC2TCState.z=gC2TCState.z-gC2TCState.shiftz;
    }*/else if(tcgfst.gnum==GCODE_M50)
    {   //limit the max speed of the
        if(tcgfst.value>SYSparam[168].val)
        {
            tcgfst.value=SYSparam[168].val;
        }
        gC2TCState.G96SpinspeedLimit=tcgfst.value;
    }
    tcgfst.sendCount=STDsendcount++;
    if(O9XXXruning)
    {
        tcgfst.srcLine=O9XXXsrc;
        tcgfst.srcCode=O9XXXrunptr;

    }else{

        tcgfst.srcLine=fstptr->srcline;
        tcgfst.srcCode=grunPtr;
    }
    tcgfst.coordx=unit2Meter4Digit(gC2TCState.x);
    if(dimMode)
        tcgfst.coordx=tcgfst.coordx/2;
    tcgfst.coordz=unit2Meter4Digit(gC2TCState.z);
    tcgfst.coordy=unit2Meter4Digit(gC2TCState.y);
    execGptr++;
    *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    DBMSG_FST(tcgfst.gnum,tcgfst.value,tcgfst.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLine2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g line code to ToolCompensation gcode buffer,
*   conver the data struct
****************************************************************************
*/
U8 gT2TCG(void)
{
    PcompiledFST tptr=(PcompiledFST)execGptr;
    TTCGfst tcgfst;
    U32 callTime=1;
    U32 callProg=0;
    U32 caller;
    U32 i;
    tptr=(PcompiledFST)execGptr;
    if(tptr->paramType&(T_IS_VALUE))
    {
        tcgfst.value=tptr->value;
    }else{
        //it is a param
        tcgfst.value=getVarValuePQ(tptr->value);
    }
    globalVar[99]=tcgfst.value;
    tcgfst.gnum=execGptr->gtype;
    if(callDeep!=0)
    { //find the
        caller=gcallStack[callDeep-1].beCallProg;
    }
    //normal tcode or in O9000-O9031
    if((!TCodeUseSub)||
        ((callDeep!=0)&&((caller>=9000)&&(caller<=9031))))
    {
        U8 index;
        gC2TCState.x=gC2TCState.x+gC2TCState.shiftx;
        gC2TCState.z=gC2TCState.z+gC2TCState.shiftz;
        gC2TCState.t=tcgfst.value;
        index=gC2TCState.t%100;
        gC2TCState.shiftx=meter4Digit2Unit(toolCompensation[index].x);
        if(dimMode)
        {
            gC2TCState.shiftx*=2;
        }
        gC2TCState.x=gC2TCState.x-gC2TCState.shiftx;
        gC2TCState.shiftz=meter4Digit2Unit(toolCompensation[index].z);
        gC2TCState.z=gC2TCState.z-gC2TCState.shiftz;

        tcgfst.sendCount=STDsendcount++;
        if(O9XXXruning)
        {
            tcgfst.srcLine=O9XXXsrc;
            tcgfst.srcCode=O9XXXrunptr;

        }else{
            tcgfst.srcLine=tptr->srcline;
            tcgfst.srcCode=grunPtr;

        }
        tcgfst.coordx=unit2Meter4Digit(gC2TCState.x);
        if(dimMode)
            tcgfst.coordx=tcgfst.coordx/2;
        tcgfst.coordz=unit2Meter4Digit(gC2TCState.z);
        tcgfst.coordy=unit2Meter4Digit(gC2TCState.y);
        execGptr++;
        *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        grunPtr++;
        DBMSG_FST(tcgfst.gnum,tcgfst.value,tcgfst.sendCount);
        return GERR_OK;
    }
    // use sub is ture and we replace with a m98 call to O9000

    if(waitBufClear()!=GERR_OK)
        return GERR_OK;
    if(callDeep!=0)
    {
        caller=gcallStack[callDeep-1].beCallProg;
    }else{
        caller=programList[0].index;
    }

    callProg=PREDEF_PROG_START;
    callTime=1;

    if(callDeep==CALL_DEEP_MAX)
    {
        DEBUGMSG(1,"Over max sub porgram call Deep\n");
        return GERR_STACK_OVF;
    }
    gcallStack[callDeep].callerProg=caller;
    gcallStack[callDeep].beCallProg=callProg;
    gC2TCState.currentProg=callProg;
    gcallStack[callDeep].callTimes=callTime-1; //we had call once here
    //gcallStack[callDeep].jumpPointIndex=i;
    //Find start address in sub program list
    for(i=0;i<programCount;i++)
    {
        if(callProg==programList[i].index)
        {
            //since o9000-o9031 always had it's slot
            //but may be no program, mustcheck it
            if(programList[i].address==COMPILE_BUF_MAX)
            {
                i=programCount;
                break;
            }
            gcallStack[callDeep].startAddress=programList[i].address;
            break;
        }
    }
    if(i==programCount)
    {
        DEBUGMSG(1,"M98 calling not exict program %d\n",callProg);
        return GERR_NO_TAG;
    }
    O9XXXsrc=tptr->srcline;
    O9XXXrunptr=grunPtr;
    O9XXXruning=1;
    //gcallStack[callDeep].startAddress=m98Request[i].address;
    gcallStack[callDeep].returnPtr=grunPtr+1;
    grunPtr=gcallStack[callDeep].startAddress;
    execGptr=&compiledGbuf[grunPtr];

    callDeep++;
    DEBUGMSG(1,"M98:prog %d call %d, %d cycles,deep %d\n",
        caller,callProg,callTime,callDeep);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLine2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g line code to ToolCompensation gcode buffer,
*   conver the data struct
****************************************************************************
*/
U8 gLine2TCG()
{
    PcompiledG01 glineptr;
    TTCGline tcgline;
    U32 r;
    U32 c;
    glineptr=(PcompiledG01)execGptr;
    if(glineptr->gtype==GCODE_01)
    {
        if((gC2TCState.f==0)||
        ((gC2TCState.GG03==GCODE_99)&&
         ((gC2TCState.s==0)||(gC2TCState.sdir==5))))
            return GERR_NOFEED_G1;
    }
    if(glineptr->paramType&GC_IS_SETED)
    {
        if(glineptr->paramType&GC_IS_VALUE)
            c=glineptr->c;
        else
            c=getVarValue(glineptr->c);
    }
    if(glineptr->paramType&GR_IS_SETED)
    {
        if(glineptr->paramType&GR_IS_VALUE)
            r=glineptr->r;
        else
            r=getVarValue(glineptr->r);
    }
    if(glineptr->paramType&GA_IS_SETED)
    {
        U8 err;
        err=gLineA2TCG();
        return err;
    }
    //普通直线
    tcgline.gnum=glineptr->gtype;//execGptr->gtype&0xff;
    //tcgline.sendCount=glineptr->srcline;

    if(O9XXXruning)
    {
        tcgline.srcLine=O9XXXsrc;
        tcgline.srcCode=O9XXXrunptr;

    }else{
        tcgline.srcLine=glineptr->srcline;
        tcgline.srcCode=grunPtr;
    }
    if(glineptr->paramType&GXU_IS_VALUE)
    {
        if(glineptr->paramType&GXU_IS_INC)
            tcgline.x=glineptr->xu+gC2TCState.x;
        else
            tcgline.x=glineptr->xu;
        //compiledX=tcgline.x;
        //gC2TCState.x=tcgline.x;
    }else if(glineptr->paramType&GXU_IS_PARAM)
    {
        if(glineptr->paramType&GXU_IS_INC)
            tcgline.x=getVarValue(glineptr->xu)+gC2TCState.x;
        else
            tcgline.x=getVarValue(glineptr->xu);
        //gC2TCState.x=tcgline.x;
    }else{
        tcgline.x=gC2TCState.x;
    }
    //if(DSPparam.sysbyte[79]==1)  //
    //if in dim mode x should /2
    //tcgline.x=unit2Meter4Digit(tcgline.x);
    //if(dimMode)
    //{
    //    tcgline.x=tcgline.x/2;
    //}
    if(glineptr->paramType&GZW_IS_VALUE)
    {
        if(glineptr->paramType&GZW_IS_INC)
            tcgline.z=glineptr->zw+gC2TCState.z;
        else
            tcgline.z=glineptr->zw;
        //compiledZ=tcgline.z;
        //gC2TCState.z=tcgline.z;
    }else if(glineptr->paramType&GZW_IS_PARAM)
    {
        if(glineptr->paramType&GZW_IS_INC)
            tcgline.z=getVarValue(glineptr->zw)+gC2TCState.z;
        else
            tcgline.z=getVarValue(glineptr->zw);
        //gC2TCState.z=tcgline.z;
    }else{
        tcgline.z=gC2TCState.z;
    }
    //tcgline.z=unit2Meter4Digit(tcgline.z);
    if(glineptr->paramType&GC_IS_SETED)
    {
        return gLineCChamfer(glineptr, &tcgline,c);
    }else if(glineptr->paramType&GR_IS_SETED)
    {
        return gLineRChamfer(glineptr, &tcgline,r);
    }else{
    //普通直线
        gC2TCState.z=tcgline.z;
        tcgline.z=unit2Meter4Digit(tcgline.z);
        gC2TCState.x=tcgline.x;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        if(dimMode)
        {
            tcgline.x=tcgline.x/2;
        }
        chamferLenReg=0; //清除上次倒角的记录
    }
    if(glineptr->paramType&GYV_IS_VALUE)
    {
        if(glineptr->paramType&GYV_IS_INC)
            tcgline.y=glineptr->yv+gC2TCState.y;
        else
            tcgline.y=glineptr->yv;
        //compiledZ=tcgline.z;
        gC2TCState.y=tcgline.y;
    }else if(glineptr->paramType&GYV_IS_PARAM)
    {
        if(glineptr->paramType&GYV_IS_INC)
            tcgline.y=getVarValue(glineptr->yv)+gC2TCState.y;
        else
            tcgline.y=getVarValue(glineptr->yv);
        gC2TCState.y=tcgline.y;
    }else{
        tcgline.y=gC2TCState.y;
    }
    tcgline.y=unit2Meter4Digit(tcgline.y);
    tcgline.sendCount=STDsendcount++;
    execGptr++;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    g909294infoClear();
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLineA2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 角度直线
****************************************************************************
*/
U8 gLineA2TCG()
{
    U32 r;
    U32 c;
    double angle1;
    Line l1,l2;
    Point p1,p2;
    PcompiledG01 glineptr,glineptr2;
    TTCGline tcgline;
    glineptr=(PcompiledG01)execGptr;
 //普通直线
    tcgline.gnum=glineptr->gtype;//execGptr->gtype&0xff;
    //tcgline.sendCount=glineptr->srcline;

    if(O9XXXruning)
    {  //O9XXX里应该禁止使用这类代码
        tcgline.srcLine=O9XXXsrc;
        tcgline.srcCode=O9XXXrunptr;
    }else{
        tcgline.srcLine=glineptr->srcline;
        tcgline.srcCode=grunPtr;
    }
    if(glineptr->paramType&GC_IS_SETED)
    {
        if(glineptr->paramType&GC_IS_VALUE)
            c=glineptr->c;
        else
            c=getVarValue(glineptr->c);
    }
    if(glineptr->paramType&GR_IS_SETED)
    {
        if(glineptr->paramType&GR_IS_VALUE)
            r=glineptr->r;
        else
            r=getVarValue(glineptr->r);
    }
    p1.x=gC2TCState.x;
    p1.y=gC2TCState.z;
    {
        U8 flag;
        p2=findLineEndPoint(glineptr ,p1,&flag);
        if(flag!=GERR_OK)
            return flag;
        tcgline.x=myround(p2.x);
        tcgline.z=myround(p2.y);
        //gC2TCState.x=tcgline.x;
        if(dimMode)
            tcgline.x*=2;
    }

    //如果还有倒角，求倒角
    if(glineptr->paramType&GC_IS_SETED)
    {
        return gLineCChamfer(glineptr, &tcgline,c);
    }else if(glineptr->paramType&GR_IS_SETED)
    {
        return gLineRChamfer(glineptr, &tcgline,r);
    }else{
        gC2TCState.x=tcgline.x;
        gC2TCState.z=tcgline.z;
        if(dimMode)
            tcgline.x/=2;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        tcgline.z=unit2Meter4Digit(tcgline.z);
        tcgline.y=gC2TCState.y;
        tcgline.y=unit2Meter4Digit(tcgline.y);
        chamferLenReg=0; //清除上次倒角的记录
    }
    tcgline.sendCount=STDsendcount++;
    execGptr++;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    g909294infoClear();
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLineCChamfer
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 把原直线和编译后直线都传递进来，
* 编译后的直线应该要已经计算好了终点xz坐标，但还没有半径化。
* gc2tcstate也没有修改，在此函数中也不做修改。
* 此函数会计算和发出直线，并把gc2tcstate的坐标修改完。
* 即返回后原直线处理函数不再需要进行发送
****************************************************************************
*/
U8 gLineCChamfer(PcompiledG01 pcline, PTCGline ptcgline, U32 c )
{
    U8 err;
    S32 cornerx,cornerz;
    Point p1,p2,p3;
    //先判断下一直线是否直线
    PcompiledG23 nextLine;
    nextLine = Goto_Next_G(execGptr+1,&err);
    if(err!=GERR_OK)
    {
        return err;
    }
    if(nextLine->gtype!=GCODE_01)
        return GERR_CHAMFER_TOOBIG; //不是直线不能倒角
    p1.x=gC2TCState.x;
    p1.y=gC2TCState.z;
    p2.x=ptcgline->x;
    p2.y=ptcgline->z;
    cornerx=ptcgline->x;
    cornerz=ptcgline->z;
    //需要把下一条直线的起点先算出来，因为可能是增量编程。
    p3=findLineEndPoint((PcompiledG01)(execGptr+1), p2, &err);
    if(err!=GERR_OK)
        return err;
    if(dimMode)
    {
        p1.x=p1.x/2;
        p2.x=p2.x/2;
    }
    err=gLineChamferCal(c,p1,p2,p3);
    if(err!=GERR_OK)
        return err;
    ptcgline->x=myround(chamferPoint1.x);
    ptcgline->z=myround(chamferPoint1.y);
    ptcgline->x=unit2Meter4Digit(ptcgline->x);
    ptcgline->z=unit2Meter4Digit(ptcgline->z);
    ptcgline->y=gC2TCState.y;
    ptcgline->y=unit2Meter4Digit(ptcgline->y);
    ptcgline->sendCount=STDsendcount++;
    *((PTCGline)&TCGbuf[TCGwptr])=*ptcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(ptcgline->gnum,ptcgline->x,ptcgline->z,ptcgline->sendCount);
    ptcgline->x=myround(chamferPoint2.x);
    ptcgline->z=myround(chamferPoint2.y);

    ptcgline->x=unit2Meter4Digit(ptcgline->x);
    ptcgline->z=unit2Meter4Digit(ptcgline->z);
    ptcgline->y=gC2TCState.y;
    ptcgline->y=unit2Meter4Digit(ptcgline->y);

    *((PTCGline)&TCGbuf[TCGwptr])=*ptcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    gC2TCState.z=cornerz;
    gC2TCState.x=cornerx;
    execGptr++;
    grunPtr++;
    g909294infoClear();
    DBMSG_GLINE(ptcgline->gnum,ptcgline->x,ptcgline->z,ptcgline->sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLineCChamfer
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 把原直线和编译后直线都传递进来，
* 编译后的直线应该要已经计算好了终点xz坐标，但还没有半径化。
* gc2tcstate也没有修改，在此函数中也不做修改。
* 此函数会计算和发出直线，并把gc2tcstate的坐标修改完。
* 即返回后原直线处理函数不再需要进行发送
****************************************************************************
*/
U8 gLineRChamfer(PcompiledG01 pcline, PTCGline ptcgline,U32 r)
{
    U8 arcdir;
    U8 err;
    S32 cornerx,cornerz;
    Point p1,p2,p3;
    TTCGarc tcgarc;
    p1.x=gC2TCState.x;
    p1.y=gC2TCState.z;
    p2.x=ptcgline->x;
    p2.y=ptcgline->z;
    cornerx=ptcgline->x;
    cornerz=ptcgline->z;
    //如果下一线段是圆弧，转入直线圆弧倒角计算
    {
        PcompiledG23 nextCode;
        nextCode = Goto_Next_G(execGptr+1,&err);
        if(err!=GERR_OK)
        {
            return err;
        }
        if((nextCode->gtype==2)||(nextCode->gtype==3))
        {
            err=LineArcRChamfer(pcline, ptcgline,r);
            return err;
        }else if(nextCode->gtype!=1)
        {  //不是直线，又不是圆弧，不能倒角
           return GERR_GCMD_UNKNOW;
        }
        //下面转入直线倒圆角
    }
    //需要把下一条直线的起点先算出来，因为可能是增量编程。
    p3=findLineEndPoint((PcompiledG01)(execGptr+1), p2, &err);
    if(err!=GERR_OK)
        return err;
    if(dimMode)
    {
        p1.x=p1.x/2;
        p2.x=p2.x/2;
    }
    err=gLineRchamferCal(r,p1,p2,p3);
    if(err!=GERR_OK)
        return err;
    //arcdir=arcDir(chamferPoint1, chamferPoint2, chamferCenter);
    arcdir=arcDir(p1,p2,p3);
    ptcgline->x=myround(chamferPoint1.x);
    ptcgline->z=myround(chamferPoint1.y);
    ptcgline->x=unit2Meter4Digit(ptcgline->x);
    ptcgline->z=unit2Meter4Digit(ptcgline->z);
    ptcgline->y=gC2TCState.y;
    ptcgline->y=unit2Meter4Digit(ptcgline->y);

    ptcgline->sendCount=STDsendcount++;
    *((PTCGline)&TCGbuf[TCGwptr])=*ptcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(ptcgline->gnum,ptcgline->x,ptcgline->z,ptcgline->sendCount);
    tcgarc.gnum=arcdir;
    tcgarc.sendCount=ptcgline->sendCount;
    tcgarc.srcCode=ptcgline->srcCode;
    tcgarc.srcLine=ptcgline->srcLine;
    tcgarc.x=myround(chamferPoint2.x);
    tcgarc.z=myround(chamferPoint2.y);
    tcgarc.x=unit2Meter4Digit(tcgarc.x);
    tcgarc.z=unit2Meter4Digit(tcgarc.z);
    tcgarc.i=myround(chamferCenter.x-chamferPoint1.x);
    tcgarc.k=myround(chamferCenter.y-chamferPoint1.y);
    tcgarc.i=unit2Meter4Digit(tcgarc.i);
    tcgarc.k=unit2Meter4Digit(tcgarc.k);
    tcgarc.r=0;
    *((PTCGarc)&TCGbuf[TCGwptr])=tcgarc;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //gC2TCState.z=tcgarc.z;
    //gC2TCState.x=tcgarc.x;
    //if(dimMode)
    //    gC2TCState.x*=2;
    gC2TCState.z=cornerz;
    gC2TCState.x=cornerx;
    execGptr++;
    grunPtr++;
    g909294infoClear();
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    return GERR_OK;
}

/***************************************************************************
*FUNCTION: LineArcRChamfer
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 直线和圆弧段间倒角，
* 传入的是当前直线段，和用于存放直线段开始解释的数据
****************************************************************************
*/
S32 LineArcRChamfer(PcompiledG01 pcline, PTCGline ptcgline,U32 r)
{
    U8 arcdir,cutDir;
    U8 err=0;
    S32 cornerx,cornerz;
    double radius;
    Point p1,p2,p3,p4;
    TTCGarc tcgarc;
    PcompiledG23 garcptr;
    p1.x=gC2TCState.x;
    p1.y=gC2TCState.z;
    p2.x=ptcgline->x;
    p2.y=ptcgline->z;
    cornerx=p2.x;
    cornerz=p2.y;
    /*
    if(dimMode)
    {
        p1.x=p1.x/2;
        p2.x=p2.x/2;
    } */
    garcptr=Goto_Next_G((execGptr+1),&err);
    if(err!=0)
    {
        return err;
    }
    //计算圆弧的终点把圆弧段也给发出，免去后面再计算的麻烦
    if(garcptr->paramType&GXU_IS_VALUE)
    {
        if(garcptr->paramType&GXU_IS_INC)
            tcgarc.x=garcptr->xu+p2.x;
        else
            tcgarc.x=garcptr->xu;
    }else if(garcptr->paramType&GXU_IS_PARAM)
    {
        if(garcptr->paramType&GXU_IS_INC)
            tcgarc.x=getVarValue(garcptr->xu)+p2.x;
        else
            tcgarc.x=getVarValue(garcptr->xu);
    }else{
        tcgarc.x=p2.x;
    }


    if(garcptr->paramType&GZW_IS_VALUE)
    {
        if(garcptr->paramType&GZW_IS_INC)
            tcgarc.z=garcptr->zw+p2.y;
        else
            tcgarc.z=garcptr->zw;
    }else if(garcptr->paramType&GZW_IS_PARAM)
    {
        if(garcptr->paramType&GZW_IS_INC)
            tcgarc.z=getVarValue(garcptr->zw)+p2.y;
        else
            tcgarc.z=getVarValue(garcptr->zw);
    }else{
        tcgarc.z=p2.y;
    }
    //cornerx=tcgarc.x;
    //cornerz=tcgarc.z;
    if(dimMode)
    {
        p1.x=p1.x/2;
        p2.x=p2.x/2;
        tcgarc.x=tcgarc.x/2;
    }
    p4.x=tcgarc.x;
    p4.y=tcgarc.z;
    if(garcptr->paramType&GR_IS_SETED)
    {
        if(garcptr->paramType&GR_IS_VALUE)
        {
            radius=garcptr->r;
        }else if(garcptr->paramType&GR_IS_PARAM)
        {
            radius=getVarValue(garcptr->r);
        }else{
            radius=0;
        }
        p3=calArcCenter(p2, p4, radius, garcptr->gtype);
    }else{
        //直接获取 ik计算圆心
        if(garcptr->paramType&GI_IS_VALUE)
        {
            tcgarc.i=garcptr->i;
        }else if(garcptr->paramType&GI_IS_PARAM)
        {
            tcgarc.i=getVarValue(garcptr->i);
        }else{
            tcgarc.i=0;
        }
        if(garcptr->paramType&GK_IS_VALUE)
        {
             tcgarc.k=garcptr->k;
        }else if(garcptr->paramType&GK_IS_PARAM)
        {
            tcgarc.k=getVarValue(garcptr->k);
        }else{
            tcgarc.k=0;
        }
        p3.x=p2.x+tcgarc.i;
        p3.y=p2.y+tcgarc.k;
        radius=sqrt(pow((p3.x-p2.x),2)+pow((p3.y-p2.y),2));
    }
    //计算切圆圆心
    cutDir=judgeMoveSide(p1,p2,p3,garcptr->gtype);
    if(cutDir==2)//顺切，不能倒角
        return GERR_PARAM_VALERR;
    chamferCenter=calCenterPoint(p1, p2, p3, radius,r, garcptr->gtype,cutDir);
    //求直线交点
    {
    Line l1=LineMake(p1,p2);
    chamferPoint1=VerticalPoint(chamferCenter,l1);
    //要验算这个点是否在原线段上，否则出错
    // 该点到两点距离之和应该等于两点距离
    if(PointIsOnSegment(chamferPoint1,p1,p2)==0)
        return GERR_CHAMFER_TOOBIG;
    }
    //求圆弧交点
    chamferPoint2=calArcIntersectionPoint(p3, chamferCenter, radius);
    //要演算这个点是否在原弧段上。
    {
        if(pointInArc( p2, p4, p3,  chamferPoint2, garcptr->gtype)==0)
            return GERR_CHAMFER_TOOBIG;

    }
    if(cutDir==0)
        arcdir=3; //顺弧
    else
        arcdir=2; //逆弧
    ptcgline->x=myround(chamferPoint1.x);
    ptcgline->z=myround(chamferPoint1.y);
    ptcgline->x=unit2Meter4Digit(ptcgline->x);
    ptcgline->z=unit2Meter4Digit(ptcgline->z);
    ptcgline->y=gC2TCState.y;
    ptcgline->y=unit2Meter4Digit(ptcgline->y);

    ptcgline->sendCount=STDsendcount++;
    *((PTCGline)&TCGbuf[TCGwptr])=*ptcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(ptcgline->gnum,ptcgline->x,ptcgline->z,ptcgline->sendCount);
    tcgarc.gnum=arcdir;
    tcgarc.sendCount=ptcgline->sendCount;
    tcgarc.srcCode=ptcgline->srcCode;
    tcgarc.srcLine=ptcgline->srcLine;
    tcgarc.x=myround(chamferPoint2.x);
    tcgarc.z=myround(chamferPoint2.y);
    tcgarc.x=unit2Meter4Digit(tcgarc.x);
    tcgarc.z=unit2Meter4Digit(tcgarc.z);
    tcgarc.i=myround(chamferCenter.x-chamferPoint1.x);
    tcgarc.k=myround(chamferCenter.y-chamferPoint1.y);
    tcgarc.i=unit2Meter4Digit(tcgarc.i);
    tcgarc.k=unit2Meter4Digit(tcgarc.k);
    tcgarc.r=0;
    *((PTCGarc)&TCGbuf[TCGwptr])=tcgarc;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    /*
    //把下语句的圆弧也发出去
    execGptr++;
    grunPtr++;
    tcgarc.gnum=garcptr->gtype;
    tcgarc.sendCount=STDsendcount++;
    tcgarc.srcLine=garcptr->srcline;
    tcgarc.srcCode=grunPtr;
    tcgarc.x=p4.x;
    tcgarc.z=p4.y;
    tcgarc.x=unit2Meter4Digit(tcgarc.x);
    tcgarc.z=unit2Meter4Digit(tcgarc.z);
    tcgarc.i=myround(p3.x-chamferPoint2.x); //写成I K后面好计算
    tcgarc.k=myround(p3.y-chamferPoint2.y);
    tcgarc.i=unit2Meter4Digit(tcgarc.i);
    tcgarc.k=unit2Meter4Digit(tcgarc.k);
    tcgarc.r=0;
    *((PTCGarc)&TCGbuf[TCGwptr])=tcgarc;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    //gC2TCState.z=tcgarc.z;
    //gC2TCState.x=tcgarc.x;
    //if(dimMode)
    //    gC2TCState.x*=2;
    */
    gC2TCState.z=cornerz;
    gC2TCState.x=cornerx;
    hasround=1;//标记圆弧前面做过倒角，后面计算圆弧时修正ik
    execGptr++;
    grunPtr++;
    g909294infoClear();
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLineC2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 直线C倒角，倒角功能因为可能供点直线和角直线使用
* 因此，要把原直线算的终点传递进来。
****************************************************************************
*/
U8 gLineChamferCal(double c,Point startPoint,Point endPoint,Point endPoint2)
{
    U8 flag;
    Point midPoint;
    flag=1;
    midPoint= Point3(startPoint, endPoint, c, &flag);
    if(flag!=GERR_OK)
        return flag;
    chamferPoint1=midPoint;
    flag=0;
    midPoint= Point3(endPoint2, endPoint, c, &flag);
    if(flag!=GERR_OK)
        return flag;
    chamferPoint2=midPoint;
    chamferLenReg=c;
    chamferReg=midPoint;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gLineC2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 直线R倒角的倒角点与圆心
****************************************************************************
*/
U8 gLineRchamferCal(double r,Point startPoint,Point endPoint,Point endPoint2)
{
    U8 err;
    double c;
    Point center;
    //S32 i,j;
    Line l1,l2,l3,l4;
    c=crossLen(r,startPoint,endPoint,endPoint2);
    err=gLineChamferCal(c,startPoint,endPoint,endPoint2);
    if(err!=GERR_OK)
        return err;
    //通过垂足作垂线求交点
    l1=LineMake(startPoint, endPoint);
    l2=LineMake(endPoint,endPoint2);
    //LineMakeAngle(chamferPoint1, )
    l3.B=0-l1.A;
    l3.A=l1.B;
    l3.C=0-l3.A*chamferPoint1.x-l3.B*chamferPoint1.y;
    l4.B=0-l2.A;
    l4.A=l2.B;
    l4.C=0-l4.A*chamferPoint2.x-l4.B*chamferPoint2.y;
    center=LinesIntersection(l3, l4, &err);
    chamferCenter=center;
    if(err==0)
        return GERR_ALINE_NOCROSS;
    else
        return GERR_OK;
}

/***************************************************************************
*FUNCTION: findNextLineEndPoint
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 向前搜索下一直线段的终点，以用于本线段的倒角计算
* startPoint是未经过半径化的值,
****************************************************************************
*/
double angleRound(double angle);
Point findLineEndPoint(PcompiledG01 gline ,Point startPoint,U8* flag)
{
    Point endPoint;
    double angle1;
    *flag=GERR_OK;
    gline = (PcompiledG01)Goto_Next_G((PcompiledG23)gline,flag);
    if(*flag!=0)
    {
        return endPoint;
    }
    if(gline->paramType&GXU_IS_VALUE)
    {
        if(gline->paramType&GXU_IS_INC)
            endPoint.x=gline->xu+startPoint.x;
        else
            endPoint.x=gline->xu;
    }else if(gline->paramType&GXU_IS_PARAM)
    {
        if(gline->paramType&GXU_IS_INC)
            endPoint.x=getVarValue(gline->xu)+startPoint.x;
        else
            endPoint.x=getVarValue(gline->xu);
    }else{
        endPoint.x=startPoint.x;
    }
    if(dimMode)
        endPoint.x=endPoint.x/2;
    if(gline->paramType&GZW_IS_VALUE)
    {
        if(gline->paramType&GZW_IS_INC)
            endPoint.y=gline->zw+startPoint.y;
        else
            endPoint.y=gline->zw;
    }else if(gline->paramType&GZW_IS_PARAM)
    {
        if(gline->paramType&GZW_IS_INC)
            endPoint.y=getVarValue(gline->zw)+startPoint.y;
        else
            endPoint.y=getVarValue(gline->zw);
    }else{
        endPoint.y=startPoint.y;
    }
    //如果xz都给出,这条带A的直线是3段中的最后一条
    //或者没有a,则是普通直线省略一个参数
    if(((gline->paramType&GXU_IS_SETED)
        &&(gline->paramType&GZW_IS_SETED))
        ||(!(gline->paramType&GA_IS_SETED)))
    {
        return endPoint;  //返回直线终点
    }
    if(gline->paramType&GA_IS_SETED)
    {
        Line l1;
        if(gline->paramType&GA_IS_VALUE)
        {
            angle1=gline->a;
        }else if(gline->paramType&GA_IS_PARAM)
        {
            angle1=getVarValue(gline->a);
        }else{
        	*flag=GERR_PARAM_VALERR;
            return endPoint;
        }
        angle1=angleRound(angle1/1000);

        if(dimMode)
            startPoint.x=startPoint.x/2;
        l1=LineMakeAngle(startPoint, angle1);
        if(gline->paramType&GXU_IS_SETED)
        {
            //给的是X值，要判断射线是否和这个X相交
            if((((angle1>-1)||(angle1<-179))&&(endPoint.x<startPoint.x))
             ||(((angle1<1)||(angle1>179))&&(endPoint.x>startPoint.x)))
             //||(angle1==0)||
            { //射线和给定坐标不会相交
                *flag=GERR_ALINE_NOCROSS;
                return endPoint;
            }
            endPoint.y=myround(PointOfLine(l1, endPoint.x, 1));
            return endPoint;
        }else if(gline->paramType&GZW_IS_SETED)
        {
            //给的是z值，要判断射线是否和这个z相交
            if((((angle1>89)||(angle1<-89))&&(endPoint.y>startPoint.y))
            ||((!((angle1>=91)||(angle1<=-91)))&&(endPoint.y<startPoint.y)))
            //||(abs(angle1)==90)
            { //射线和给定坐标不会相交
                *flag=GERR_ALINE_NOCROSS;
                return endPoint;
            }
            endPoint.x=myround(PointOfLine(l1, endPoint.y, 0));
            return endPoint;
        }else{ //只给了角度 还需要下一条直线
            Point nextPoint;
            PcompiledG01 gline2;
            double angle2;
            Line l2;
            gline2 = (PcompiledG01)Goto_Next_G(((PcompiledG23)gline)+1,flag);
            if(*flag!=GERR_OK)
            {
                return endPoint;
            }
            //这条直线必须明确的给出xz A的值
            if((gline2->gtype!=GCODE_01) //not a line
            ||(gline2->paramType&(GXU_IS_HIRE|GXU_IS_INC))
                ||(gline2->paramType&(GZW_IS_HIRE|GZW_IS_INC))
                 ||(!(gline2->paramType&GA_IS_SETED)))
            {
                 *flag=GERR_ALINE_NOCROSS;
                 return endPoint;
            }

            nextPoint=findLineEndPoint(gline2,endPoint,flag);
            if(gline2->paramType&GA_IS_VALUE)
            {
                angle2=gline2->a;
            }else if(gline2->paramType&GA_IS_PARAM)
            {
                angle2=getVarValue(gline2->a);
            }else{
                *flag=GERR_OK;
                return endPoint;
            }
            angle2=angleRound(angle2/1000);
            {
                //检查这两直线夹角是否小于1度
                double angle3,angle4;
                angle3=angle1;
                if(angle3<0)//取方向射线
                    angle3=180+angle3;
                angle4=angle2;
                if(angle4<0)//取方向射线
                    angle4=180+angle4;
                if(fabs(angle4-angle3)<1)
                {
                    *flag=GERR_ALINE_NOCROSS;
                    return endPoint;
                }
            }
            l2=LineMakeAngle(nextPoint, angle2);
            endPoint=LinesIntersection(l1, l2, flag);

            if(*flag==0)
            {
                *flag=GERR_ALINE_NOCROSS;
                return endPoint;
            }
            //这里要验证这个交点是否在射线上，还是方向反了
            //方法是分别求角度。
            {
                double angle3,angle4;
                angle3=calLineAngle(startPoint,endPoint);
                angle3=angleRound(angle3);
                angle4=calLineAngle(endPoint,nextPoint);
                angle4=angleRound(angle4);
                if((fabs(angle3-angle1)>0.001)
                  ||(fabs(angle4-angle2)>0.001))
                    *flag=GERR_ALINE_NOCROSS;
                else
                    *flag=GERR_OK;
            }
            return endPoint;
        }
    }
}

/***************************************************************************
*FUNCTION: gLineArcChamfer
*PARAMETER :void
*RETURN : void
*DESCRIPTION: 直线和圆进行倒角
* 1 根据垂直在线段上还是外，觉得是用外切还是内切 在外是外切
*
****************************************************************************
*/

/***************************************************************************
*FUNCTION: gArc2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g line code to ToolCompensation gcode buffer,
*   conver the data struct
****************************************************************************
*/
U8 gArc2TCG()
{
    PcompiledG23 garcptr;
    TTCGarc tcgarc;
    S32 sx,sz;
    garcptr=execGptr;
    sx=gC2TCState.x;
    sz=gC2TCState.z;
    if((gC2TCState.f==0)||
    ((gC2TCState.GG03==GCODE_99)&&
     ((gC2TCState.s==0)||(gC2TCState.sdir==5))))
        return GERR_NOFEED_G1;

    tcgarc.gnum=garcptr->gtype;//execGptr->gtype&0xff;
    //tcgarc.sendCount=garcptr->srcline;

    tcgarc.srcLine=garcptr->srcline;
    tcgarc.srcCode=grunPtr;
    if(garcptr->paramType&GXU_IS_VALUE)
    {
        if(garcptr->paramType&GXU_IS_INC)
            tcgarc.x=garcptr->xu+gC2TCState.x;
        else
            tcgarc.x=garcptr->xu;
        //compiledX=tcgarc.x;
        gC2TCState.x=tcgarc.x;
    }else if(garcptr->paramType&GXU_IS_PARAM)
    {
        if(garcptr->paramType&GXU_IS_INC)
            tcgarc.x=getVarValue(garcptr->xu)+gC2TCState.x;
        else
            tcgarc.x=getVarValue(garcptr->xu);
        gC2TCState.x=tcgarc.x;
    }else{
        tcgarc.x=gC2TCState.x;
    }
    //if in dim mode x should /2
    tcgarc.x=unit2Meter4Digit(tcgarc.x);
    if(dimMode)
    {
        tcgarc.x=tcgarc.x/2;
        sx=sx/2;
    }
    if(garcptr->paramType&GZW_IS_VALUE)
    {
        if(garcptr->paramType&GZW_IS_INC)
            tcgarc.z=garcptr->zw+gC2TCState.z;
        else
            tcgarc.z=garcptr->zw;
        gC2TCState.z=tcgarc.z;
    }else if(garcptr->paramType&GZW_IS_PARAM)
    {
        if(garcptr->paramType&GZW_IS_INC)
            tcgarc.z=getVarValue(garcptr->zw)+gC2TCState.z;
        else
            tcgarc.z=getVarValue(garcptr->zw);
        gC2TCState.z=tcgarc.z;
    }else{
        tcgarc.z=gC2TCState.z;
    }
    tcgarc.z=unit2Meter4Digit(tcgarc.z);
    if(garcptr->paramType&GR_IS_VALUE) //r give out
    {
        tcgarc.r=garcptr->r;
        gC2TCState.r=tcgarc.r;
        tcgarc.i=0;
        tcgarc.k=0;
        tcgarc.r=unit2Meter4Digit(tcgarc.r);
        hasround=0; //清前面的倒角标记
    }else if(garcptr->paramType&GR_IS_PARAM)
    { //this may be bug check later
        tcgarc.r=getVarValue(garcptr->r);
        gC2TCState.r=tcgarc.r;
        tcgarc.i=0;
        tcgarc.k=0;
        tcgarc.r=unit2Meter4Digit(tcgarc.r);
        hasround=0; //清前面的倒角标记
    }else{ // i ,j give out
        tcgarc.r=0;
        if(garcptr->paramType&GI_IS_VALUE)
        {
            tcgarc.i=garcptr->i;
        }else if(garcptr->paramType&GI_IS_PARAM)
        {
            tcgarc.i=getVarValue(garcptr->i);
        }else{
            tcgarc.i=0;
        }
        if(garcptr->paramType&GK_IS_VALUE)
        {
             tcgarc.k=garcptr->k;
        }else if(garcptr->paramType&GK_IS_PARAM)
        {
            tcgarc.k=getVarValue(garcptr->k);
        }else{
            tcgarc.k=0;
        }
        if(hasround==1) //此圆弧之前曾倒角，需修正iK, sx sz
        {
            S32 newx,newz;
            newx=myround(chamferPoint2.x);
            newz=myround(chamferPoint2.y);
            tcgarc.i=tcgarc.i+sx-newx;
            tcgarc.k=tcgarc.k+sz-newz;
            sx=newx;
            sz=newz;
            hasround=0; //清前面的倒角标记
        }
        //gC2TCState.i=tcgarc.i;
        //gC2TCState.k=tcgarc.k;
        tcgarc.i=unit2Meter4Digit(tcgarc.i);
        tcgarc.k=unit2Meter4Digit(tcgarc.k);
    }
    //check arc
    sx=unit2Meter4Digit(sx);
    sz=unit2Meter4Digit(sz);
    if(tcgarc.r==0)
    {
        double i=tcgarc.i;
        double k=tcgarc.k;
        double di=tcgarc.x-(sx+tcgarc.i);
        double dk=tcgarc.z-(sz+tcgarc.k);
        //check if center to s e point is equal
        /*
        S32 dis1=sqrt(tcgarc.i*tcgarc.i+tcgarc.k*tcgarc.k);
        S32 dis2=sqrt(pow((tcgarc.x-(sx+tcgarc.i)),2)+
                       pow((tcgarc.z-(sz+tcgarc.k)),2));
                       */
        S32 dis1=sqrt(pow(i,2)+pow(k,2));
        S32 dis2=sqrt(pow(di,2)+pow(dk,2));
        if(abs(dis2-dis1)>10)
            return GERR_ARC_RERR;
    }else{
        //check if r is big enough
        double di=sx-tcgarc.x;
        double dk=sz-tcgarc.z;
        S32 dis=sqrt(pow(di,2)+pow(dk,2));
        if(dis>2*tcgarc.r) //less then 1u
            return GERR_ARC_RERR;
    }
    tcgarc.sendCount=STDsendcount++; //it must place here to avoid wront sendout count
    *((PTCGarc)&TCGbuf[TCGwptr])=tcgarc;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    execGptr++;
    grunPtr++;
    g909294infoClear();
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gScrew2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled screw code to ToolCompensation gcode buffer,
*   it construct 7 gcode
****************************************************************************
*/
U8 gScrew2TCG()
{
    TTCGarc codebuf;
    TTCGline codeline;
    PTCGmcode pm=(PTCGmcode)&codebuf;
    PTCGfst   pfst=(PTCGfst)&codebuf;
    PTCGline  pline=&codeline;
    PcompiledG23 g32=execGptr;
    double dx,dz,dr,f;
    //we must fill the TCG buffer with 7 gcode ,make sure it have space
    //if(CYCLE_BUF_DEEP(TCGwptr, TCGrptr, TCG_BUF_MAX)>(TCG_BUF_MAX-8))
    //    return;
        //step 2.1 add a prev f resum code here
    if(gC2TCState.f==0) //give a special f
    {
         if(gC2TCState.GG03==GCODE_99)
         {
            gC2TCState.f=20;
         }else{
            gC2TCState.f=30000;
         }
         pfst->gnum=GCODE_F;
         pfst->sendCount=STDsendcount;
         pfst->srcLine=g32->srcline;
         pfst->srcCode=grunPtr;
         pfst->value=gC2TCState.f;
         DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
          *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    //m3
    DBMSG_GCODE("GCP start g32\n");
    memset(pm,0,sizeof(TTCGarc));
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        //alarm
        return GERR_SCREW_NOS;
        //gexecState=GEXEC_EXERR;
        //showHint(OPERR_SSTOP_SCREW,SHOW_TIME_FEVER);
    }
    //pm->sendCount=g32->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //M253
    memset(pm,0,sizeof(TTCGarc));
    pfst->gnum=GCODE_M253;
    if(g32->paramType&GI_IS_VALUE)
    {
        pfst->value=g32->i;
    }else if(g32->paramType&GI_IS_PARAM)
    {
        pfst->value=getVarValue(g32->i);
    }else{
        pfst->value=0;
    }
    if(pfst->value>360000)
        pfst->value=0;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //S
    pfst->gnum=GCODE_S;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.s; //s must be
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //g01 since f need x, z ,we cal g1 first, save it later
    dx=0;dz=0;dr=0;f=0;
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_01;
    //pline->sendCount=g32->srcline;
    pline->sendCount=STDsendcount;
    pline->srcLine=g32->srcline;
    pline->srcCode=grunPtr;
    if(g32->paramType&GXU_IS_VALUE)
    {
        if(g32->paramType&GXU_IS_INC)
        {
            pline->x=g32->xu+gC2TCState.x;
            dx=abs(g32->xu);
        }else{
            pline->x=g32->xu;
            dx=abs(g32->xu-gC2TCState.x);
            }
        gC2TCState.x=pline->x;
    }else if(g32->paramType&GXU_IS_PARAM)
    {
        if(g32->paramType&GXU_IS_INC)
        {
            pline->x=getVarValue(g32->xu)+gC2TCState.x;
            dx=abs(getVarValue(g32->xu));
        }else{
            pline->x=getVarValue(g32->xu);
            dx=abs(getVarValue(g32->xu)-gC2TCState.x);
            }
        gC2TCState.x=pline->x;
    }else{
        pline->x=gC2TCState.x;
    }
    //if in dim mode x should /2

    pline->x=unit2Meter4Digit(pline->x);
    dx=unit2Meter4DigitFloat(dx);
    if(dimMode)
    {
        pline->x=pline->x/2;
        dx=dx/2;
    }
    if(g32->paramType&GZW_IS_VALUE)
    {
        if(g32->paramType&GZW_IS_INC)
        {
            pline->z=g32->zw+gC2TCState.z;
            dz=abs(g32->zw);
        }else{
            pline->z=g32->zw;
            dz=abs(g32->zw-gC2TCState.z);
        }
        //compiledZ=pline->z;
        gC2TCState.z=pline->z;
    }else if(g32->paramType&GZW_IS_PARAM)
    {
        if(g32->paramType&GZW_IS_INC)
        {
            pline->z=getVarValue(g32->zw)+gC2TCState.z;
            dz=abs(getVarValue(g32->zw));
        }else{
            pline->z=getVarValue(g32->zw);
            dz=abs(getVarValue(g32->zw)-gC2TCState.z);
            }
        gC2TCState.z=pline->z;
    }else{
        pline->z=gC2TCState.z;
    }
    pline->z=unit2Meter4Digit(pline->z);
    dz=unit2Meter4DigitFloat(dz);
    dr=sqrt(dx*dx+dz*dz);
    if(g32->paramType&GF_IS_SETED)
    {
        if(g32->paramType&GF_IS_VALUE)
            f=g32->f;
        else{
            f=getVarValue(g32->f);
        }
        if(g32->paramType&GF_IS_INC)
        {
            if(f==0)
                return GERR_PARAM_VALERR;
            if(sysUnit==0)
            {  //IS ENLARGE 1000
                f=25400000.0/f;
            }else{
                //given as # or i in inch, IS ENLARGE 10000
                f=100000000.0/f;
            }
        }
        gC2TCState.screwf=f;
    }else{
        if(gC2TCState.screwf>0)
            f=gC2TCState.screwf;
        else
            return GERR_G32_MISS_FI;
    }
    f=unit2Meter4DigitFloat(f);
    if(dz>dx)
    {
       f=(double)dr/dz*f*gC2TCState.s;
    }else
    {
        f=(double)dr/dx*f*gC2TCState.s;
    }
    //f=f/10000.0; // the f in g32 is u ,conver form u to mm
    f=f/10.0;
    if(((U32)f)==0)
        return GERR_NOFEED_G1;
    //F
    pfst->gnum=GCODE_SCREW;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=f/gC2TCState.s;

    /*
    if(gC2TCState.GG03==GCODE_99)
    {
        //pfst->value=f/60.0;
        f=f/gC2TCState.s;
        pfst->value=f;
    }
    */
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m255
    memset(pm,0,sizeof(TTCGarc));
    pm->gnum=GCODE_M255;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m3
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        return GERR_SCREW_NOS;
    }
    //pm->sendCount=g32->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //line
    pline->y=gC2TCState.y;
    pline->y=unit2Meter4Digit(pline->y);
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GCODE("GCP screw 32 : X %d,Z %d,sendcount %ld \n",
    pline->x,pline->z,pline->sendCount);
    //step 2.1 add a prev f resum code here
    //
    pfst->gnum=GCODE_F;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.f;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //add the g04 to sign the screw phase is over
    pfst->gnum=GCODE_04;
    pfst->sendCount=STDsendcount++;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=0;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    execGptr++;
    grunPtr++;
    g909294infoClear();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g33Screw2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled drill screw code to ToolCompensation gcode buffer,
*   it construct 7 gcode
****************************************************************************
*/
U8 g33Screw2TCG()
{
    TTCGarc codebuf;
    TTCGline codeline;
    PTCGmcode pm=(PTCGmcode)&codebuf;
    PTCGfst   pfst=(PTCGfst)&codebuf;
    PTCGline  pline=&codeline;
    PcompiledG23 g32=execGptr;
    double f;
    S32 endz;
    if(gC2TCState.f==0) //give a special f
    {
         if(gC2TCState.GG03==GCODE_99)
         {
            gC2TCState.f=10;
         }else{
            gC2TCState.f=30000;
         }
         pfst->gnum=GCODE_F;
         pfst->sendCount=STDsendcount;
         pfst->srcLine=g32->srcline;
         pfst->srcCode=grunPtr;
         pfst->value=gC2TCState.f;
         DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
          *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    //m3
    DBMSG_GCODE("GCP start g32\n");
    memset(pm,0,sizeof(TTCGarc));
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        //alarm
        return GERR_SCREW_NOS;
    }
    //pm->sendCount=g32->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //M253
    memset(pm,0,sizeof(TTCGarc));
    pfst->gnum=GCODE_M253;
    pfst->value=0;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //S
    pfst->gnum=GCODE_S;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.s; //s must be
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //g01 since f need x, z ,we cal g1 first, save it later
    f=0;
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_01;
    //pline->sendCount=g32->srcline;
    //pline->sendCount=STDsendcount;
    pline->srcLine=g32->srcline;
    pline->srcCode=grunPtr;
    pline->x=gC2TCState.x;
    //if in dim mode x should /2

    pline->x=unit2Meter4Digit(pline->x);
    if(dimMode)
    {
        pline->x=pline->x/2;
    }
    if(g32->paramType&GZW_IS_VALUE)
    {
        if(g32->paramType&GZW_IS_INC)
        {
            pline->z=g32->zw+gC2TCState.z;
        }else{
            pline->z=g32->zw;
        }
        //compiledZ=pline->z;
        //gC2TCState.z=pline->z;
    }else if(g32->paramType&GZW_IS_PARAM)
    {
        if(g32->paramType&GZW_IS_INC)
        {
            pline->z=getVarValue(g32->zw)+gC2TCState.z;
        }else{
            pline->z=getVarValue(g32->zw);
            }
        //gC2TCState.z=pline->z;
    }else{
        pline->z=gC2TCState.z;
    }
    endz=pline->z;
    pline->z=unit2Meter4Digit(pline->z);

    if(g32->paramType&GF_IS_SETED)
    {
        if(g32->paramType&GF_IS_VALUE)
            f=g32->f;
        else
            f=getVarValue(g32->f);
        if(g32->paramType&GF_IS_INC)
        {
            if(f==0)
                return GERR_PARAM_VALERR;
            if(sysUnit==0)
            {  //IS ENLARGE 1000
                f=25400000.0/f;
            }else{
                //given as # or i in inch, IS ENLARGE 10000
                f=100000000.0/f;
            }
        }
        gC2TCState.screwf=f;
    }else{
        if(gC2TCState.screwf>0)
            f=gC2TCState.screwf;
        else
            return GERR_G32_MISS_FI;
    }
    f=unit2Meter4DigitFloat(f);

    //f=f/10000.0; // the f in g32 is u ,conver form u to mm
    f=f/10.0;
    if(((U32)f)==0)
        return GERR_NOFEED_G1;
    //F
    pfst->gnum=GCODE_SCREW;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=f;


    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m255
    memset(pm,0,sizeof(TTCGarc));
    pm->gnum=GCODE_M254;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m3
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        return GERR_SCREW_NOS;
    }
    //pm->sendCount=g32->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //line
    pline->y=gC2TCState.y;
    pline->y=unit2Meter4Digit(pline->y);
    pline->sendCount=STDsendcount;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GCODE("GCP screw 32 : X %d,Z %d,sendcount %ld \n",
    pline->x,pline->z,pline->sendCount);
    //step 2
    //step 2.1 stop at the bottom

    pm->gnum=GCODE_M05;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 2.2 pause a few time
    pfst->gnum=GCODE_04;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=20; //50 ms pause
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 2.3 revers to the satrt point
    //m3
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M04;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M03;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //M253
    memset(pm,0,sizeof(TTCGarc));
    pfst->gnum=GCODE_M253;
    pfst->value=0;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //F
    pfst->gnum=GCODE_SCREW;
    //pfst->sendCount=g32->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=f;

    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m255
    memset(pm,0,sizeof(TTCGarc));
    pm->gnum=GCODE_M254;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m3
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M04;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M03;

    //pm->sendCount=g32->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //line
    if(endz>gC2TCState.z)
        pline->z=gC2TCState.z+100;
    else
        pline->z=gC2TCState.z-100;
    pline->z=unit2Meter4Digit(pline->z);
    pline->y=gC2TCState.y;
    pline->y=unit2Meter4Digit(pline->y);
    pline->sendCount=STDsendcount;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //-----------------------------------------------
    //step 2.4 stop spindle
    gC2TCState.sdir=5;
    pm->gnum=GCODE_M05;
    pm->sendCount=STDsendcount;
    pm->srcLine=g32->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 2.5 set prev f value
    pfst->gnum=GCODE_F;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.f;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 2.6 add a line position to the
    pline->gnum=GCODE_00;
    pline->sendCount=STDsendcount;
    pline->z=gC2TCState.z;
    pline->z=unit2Meter4Digit(pline->z);
    pline->y=gC2TCState.y;
    pline->y=unit2Meter4Digit(pline->y);
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //add the g04 to sign the screw phase is over
    pfst->gnum=GCODE_04;
    pfst->sendCount=STDsendcount++;
    pfst->srcLine=g32->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=0;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    execGptr++;
    grunPtr++;
    g909294infoClear();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gToolOpt2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled screw code to ToolCompensation gcode buffer,
*   it construct 7 gcode
****************************************************************************
*/
U8 gToolOpt2TCG()
{
    PcompiledM g4042;
    TTCGmcode tcgm;
    g4042=(PcompiledM)execGptr;
    tcgm.gnum=execGptr->gtype;
	gC2TCState.GG04=tcgm.gnum;
    //tcgm.sendCount=g4042->srcline;
    tcgm.sendCount=STDsendcount++;
    tcgm.srcLine=g4042->srcline;
    tcgm.srcCode=grunPtr;
    execGptr++;
    *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
    DBMSG_GCODE("GCP G4042 %x, sendCount %ld\n",tcgm.gnum,tcgm.sendCount);
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gREF2TCG()
*PARAMETER :void
*RETURN : void
*DESCRIPTION:
****************************************************************************
*/
U8 gREF2TCG()
{
    PcompiledG01 pg28;
    TTCGline tcgline;
    U8 flag=7;
    pg28=(PcompiledG01)execGptr;
    tcgline.gnum=GCODE_00;
    tcgline.srcLine=pg28->srcline;
    tcgline.srcCode=grunPtr;
    if(DSPparam.sysbyte[92]==1)
        return GERR_REFUSE_G28;
    if((pg28->paramType&(GXU_IS_SETED|GZW_IS_SETED|GYV_IS_SETED))==0)
    {
        goto GO_MACH_ZERO;
    }
    if(pg28->paramType&GXU_IS_VALUE)
    {
        if(pg28->paramType&GXU_IS_INC)
            tcgline.x=pg28->xu+gC2TCState.x;
        else
            tcgline.x=pg28->xu;
        //compiledX=tcgline.x;
        gC2TCState.x=tcgline.x;
    }else if(pg28->paramType&GXU_IS_PARAM)
    {
        if(pg28->paramType&GXU_IS_INC)
            tcgline.x=getVarValue(pg28->xu)+gC2TCState.x;
        else
            tcgline.x=getVarValue(pg28->xu);
        gC2TCState.x=tcgline.x;
    }else{
        tcgline.x=gC2TCState.x;
        flag&=~0x01;
    }
    tcgline.x=unit2Meter4Digit(tcgline.x);
    //if in dim mode x should /2
    if(dimMode)
    {
        tcgline.x=tcgline.x/2;
    }
    if(pg28->paramType&GZW_IS_VALUE)
    {
        if(pg28->paramType&GZW_IS_INC)
            tcgline.z=pg28->zw+gC2TCState.z;
        else
            tcgline.z=pg28->zw;
        //compiledZ=tcgline.z;
        gC2TCState.z=tcgline.z;
    }else if(pg28->paramType&GZW_IS_PARAM)
    {
        if(pg28->paramType&GZW_IS_INC)
            tcgline.z=getVarValue(pg28->zw)+gC2TCState.z;
        else
            tcgline.z=getVarValue(pg28->zw);
        gC2TCState.z=tcgline.z;
    }else{
        tcgline.z=gC2TCState.z;
        flag&=~0x02;
    }
    tcgline.z=unit2Meter4Digit(tcgline.z);

    if(pg28->paramType&GYV_IS_VALUE)
    {
        if(pg28->paramType&GYV_IS_INC)
            tcgline.y=pg28->yv+gC2TCState.y;
        else
            tcgline.y=pg28->yv;
        //compiledZ=tcgline.z;
        gC2TCState.y=tcgline.y;
    }else if(pg28->paramType&GYV_IS_PARAM)
    {
        if(pg28->paramType&GYV_IS_INC)
            tcgline.y=getVarValue(pg28->yv)+gC2TCState.y;
        else
            tcgline.y=getVarValue(pg28->yv);
        gC2TCState.y=tcgline.y;
    }else{
        tcgline.y=gC2TCState.y;
        flag&=~0x04;
    }
    tcgline.y=unit2Meter4Digit(tcgline.y);
    if(0==flag)
    {
        //nothing to move
        goto OK_END;
    }
    tcgline.sendCount=STDsendcount;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

GO_MACH_ZERO:
    if(flag&0x1)
    {
        tcgline.x=0-gC2TCState.orgx-gC2TCState.shiftx;
        gC2TCState.x=tcgline.x;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        if(dimMode)
        {
            tcgline.x=tcgline.x/2;
        }
    }
    if(flag&0x2)
    {
        tcgline.z=0-gC2TCState.orgz-gC2TCState.shiftz;
        gC2TCState.z=tcgline.z;
        tcgline.z=unit2Meter4Digit(tcgline.z);
    }
    if(flag&0x4)
    {
        tcgline.y=0-gC2TCState.orgy-gC2TCState.shifty;
        gC2TCState.y=tcgline.y;
        tcgline.y=unit2Meter4Digit(tcgline.y);
    }
    tcgline.sendCount=STDsendcount;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    //add a tool compensation cancle tool change
    {
        U8 index;
        TTCGfst tcgfst;
        tcgfst.gnum=GCODE_T;
        tcgfst.sendCount=STDsendcount++;
        tcgfst.srcLine=tcgline.srcLine;
        tcgfst.srcCode=grunPtr;
        gC2TCState.x=gC2TCState.x+gC2TCState.shiftx;
        gC2TCState.z=gC2TCState.z+gC2TCState.shiftz;
        gC2TCState.y=gC2TCState.y+gC2TCState.shifty;
        gC2TCState.t=gC2TCState.t-gC2TCState.t%100;
        tcgfst.value=gC2TCState.t;
        index=0;
        gC2TCState.shiftx=meter4Digit2Unit(toolCompensation[index].x);
        if(dimMode)
        {
            gC2TCState.shiftx*=2;
        }/*
        gC2TCState.x=gC2TCState.x-gC2TCState.orgx-gC2TCState.shiftx;
        gC2TCState.shiftz=meter4Digit2Unit(toolCompensation[index].z);
        gC2TCState.z=gC2TCState.z-gC2TCState.orgz-gC2TCState.shiftz;
        */
        gC2TCState.x=gC2TCState.x-gC2TCState.shiftx;
        gC2TCState.shiftz=meter4Digit2Unit(toolCompensation[index].z);
        gC2TCState.z=gC2TCState.z-gC2TCState.shiftz;
        gC2TCState.shifty=meter4Digit2Unit(toolCompensation[index].y);
        gC2TCState.y=gC2TCState.y-gC2TCState.shifty;
        tcgfst.coordx=unit2Meter4Digit(gC2TCState.x);
        if(dimMode)
            tcgfst.coordx=tcgfst.coordx/2;
        tcgfst.coordz=unit2Meter4Digit(gC2TCState.z);
        tcgfst.coordy=unit2Meter4Digit(gC2TCState.y);
        *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        DBMSG_FST(tcgfst.gnum,tcgfst.value,tcgfst.sendCount);
    }

OK_END:
    DBMSG_GCODE("GCP G28: x%d, z%d, sendcount %ld\n",tcgline.x,tcgline.z,tcgline.sendCount);
    execGptr++;
    grunPtr++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gSETP2TCG()
*PARAMETER :void
*RETURN : void
*DESCRIPTION:
****************************************************************************
*/
U8 gSETP2TCG()
{
    PcompiledG23 pg30;
    TTCGline tcgline;
    U8 flag=7;
    U8 p;
    if(DSPparam.sysbyte[92]==1)
        return GERR_REFUSE_G28;
    pg30=(PcompiledG23)execGptr;
    tcgline.gnum=GCODE_00;
    tcgline.srcLine=pg30->srcline;
    tcgline.srcCode=grunPtr;
    if((pg30->paramType&(GXU_IS_SETED|GZW_IS_SETED|GYV_IS_SETED))==0)
    {
        goto GO_MACH_ZERO;
    }
    if(pg30->paramType&GXU_IS_VALUE)
    {
        if(pg30->paramType&GXU_IS_INC)
            tcgline.x=pg30->xu+gC2TCState.x;
        else
            tcgline.x=pg30->xu;
        //compiledX=tcgline.x;
        gC2TCState.x=tcgline.x;
    }else if(pg30->paramType&GXU_IS_PARAM)
    {
        if(pg30->paramType&GXU_IS_INC)
            tcgline.x=getVarValue(pg30->xu)+gC2TCState.x;
        else
            tcgline.x=getVarValue(pg30->xu);
        gC2TCState.x=tcgline.x;
    }else{
        tcgline.x=gC2TCState.x;
        flag&=~0x01;
    }
    //if in dim mode x should /2
    tcgline.x=unit2Meter4Digit(tcgline.x);
    if(dimMode)
    {
        tcgline.x=tcgline.x/2;
    }
    if(pg30->paramType&GZW_IS_VALUE)
    {
        if(pg30->paramType&GZW_IS_INC)
            tcgline.z=pg30->zw+gC2TCState.z;
        else
            tcgline.z=pg30->zw;
        //compiledZ=tcgline.z;
        gC2TCState.z=tcgline.z;
    }else if(pg30->paramType&GZW_IS_PARAM)
    {
        if(pg30->paramType&GZW_IS_INC)
            tcgline.z=getVarValue(pg30->zw)+gC2TCState.z;
        else
            tcgline.z=getVarValue(pg30->zw);
        gC2TCState.z=tcgline.z;
    }else{
        tcgline.z=gC2TCState.z;
        flag&=~0x02;
    }
    tcgline.z=unit2Meter4Digit(tcgline.z);
    if(pg30->paramType&GYV_IS_VALUE)
    {
        if(pg30->paramType&GYV_IS_INC)
            tcgline.y=pg30->yv+gC2TCState.y;
        else
            tcgline.y=pg30->yv;
        //compiledZ=tcgline.z;
        gC2TCState.y=tcgline.y;
    }else if(pg30->paramType&GYV_IS_PARAM)
    {
        if(pg30->paramType&GYV_IS_INC)
            tcgline.y=getVarValue(pg30->yv)+gC2TCState.y;
        else
            tcgline.y=getVarValue(pg30->yv);
        gC2TCState.y=tcgline.y;
    }else{
        tcgline.y=gC2TCState.y;
        flag&=~0x04;
    }
    tcgline.y=unit2Meter4Digit(tcgline.y);
    if(0==flag)
    {
        //nothing to move
        goto OK_END;
    }
    tcgline.sendCount=STDsendcount++;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

GO_MACH_ZERO:
    if(pg30->paramType&GR_IS_VALUE)
    {
        p=pg30->r;
    }else{
        p=1;
    }
    if(p>8)
        p=1;
    p=p-1;  //set to real index;
    if(flag&0x1)
    {
        S32 mcoord=meter4Digit2Unit(coordRef[p].x);
        if(dimMode)
        {
            mcoord*=2;
        }
        tcgline.x=0-gC2TCState.orgx-gC2TCState.shiftx+mcoord;
        gC2TCState.x=tcgline.x;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        //if in dim mode x should /2
        if(dimMode)
        {
            tcgline.x=tcgline.x/2;
        }
    }
    if(flag&0x2)
    {
        S32 mcoord=meter4Digit2Unit(coordRef[p].z);
        tcgline.z=0-gC2TCState.orgz-gC2TCState.shiftz+mcoord;
        gC2TCState.z=tcgline.z;
        tcgline.z=unit2Meter4Digit(tcgline.z);
    }
    if(flag&0x4)
    {
        S32 mcoord=meter4Digit2Unit(coordRef[p].y);
        tcgline.y=0-gC2TCState.orgy-gC2TCState.shifty+mcoord;
        gC2TCState.y=tcgline.y;
        tcgline.y=unit2Meter4Digit(tcgline.y);
    }
    tcgline.sendCount=STDsendcount++;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //add a tool compensation cancle tool change
    {
        U8 index;
        TTCGfst tcgfst;
        tcgfst.gnum=GCODE_T;
        tcgfst.sendCount=STDsendcount;
        tcgfst.srcLine=tcgline.srcLine;
        tcgfst.srcCode=grunPtr;
        gC2TCState.x=gC2TCState.x+gC2TCState.shiftx;
        gC2TCState.z=gC2TCState.z+gC2TCState.shiftz;
        gC2TCState.y=gC2TCState.y+gC2TCState.shifty;
        gC2TCState.t=gC2TCState.t-gC2TCState.t%100;
        tcgfst.value=gC2TCState.t;
        index=0;
        gC2TCState.shiftx=meter4Digit2Unit(toolCompensation[index].x);
        if(dimMode)
        {
            gC2TCState.shiftx*=2;
        }
        gC2TCState.x=gC2TCState.x-gC2TCState.orgx-gC2TCState.shiftx;
        gC2TCState.shiftz=meter4Digit2Unit(toolCompensation[index].z);
        gC2TCState.z=gC2TCState.z-gC2TCState.orgz-gC2TCState.shiftz;
        gC2TCState.shifty=meter4Digit2Unit(toolCompensation[index].y);
        gC2TCState.y=gC2TCState.y-gC2TCState.orgy-gC2TCState.shifty;
        tcgfst.coordx=unit2Meter4Digit(gC2TCState.x);
        if(dimMode)
            tcgfst.coordx=tcgfst.coordx/2;
        tcgfst.coordz=unit2Meter4Digit(gC2TCState.z);
        tcgfst.coordy=unit2Meter4Digit(gC2TCState.y);
        *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        DBMSG_FST(tcgfst.gnum,tcgfst.value,tcgfst.sendCount);
    }
OK_END:
    DBMSG_GCODE("GCP G30: x%d, z%d, sendcount %ld\n",tcgline.x,tcgline.z,tcgline.sendCount);
    execGptr++;
    grunPtr++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: gScrew2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled screw code to ToolCompensation gcode buffer,
*   it construct 7 gcode
****************************************************************************
*/
U8 gPause2TCG()
{
    PcompiledFST fstptr;
    TTCGfst tcg04;
    tcg04.gnum=GCODE_04;
    fstptr=(PcompiledFST)execGptr;
    if(fstptr->paramType&GXU_IS_VALUE)
    {
        tcg04.value=fstptr->value;
    }else if(fstptr->paramType&GXU_IS_PARAM){
        //it is a param
        if(fstptr->paramType&GZW_IS_PARAM)
        {
            tcg04.value=getVarValuePQ(fstptr->value);
        }else{
            S32 decimal;
            switch(sysUnit)
            {
                case(0): //input is meter 3 tail digit
                    decimal=1000;
                    break;
                case(1): //input is meter 4 tail digit
                    decimal=10000;
                    break;
                default:
                    decimal=1000;
                    break;
            }
            tcg04.value=getVarValue(fstptr->value/1000)*1000/decimal;
        }
    }else{
        tcg04.value=1; //just 1 ms stop if no x or p
    }

    //tcg04.sendCount=fstptr->srcline;
    tcg04.sendCount=STDsendcount++;
    tcg04.srcLine=fstptr->srcline;
    tcg04.srcCode=grunPtr;
    execGptr++;
    //(U32 )execGptr=(U32)execGptr+sizeof(TcompiledFST);
    *((PTCGfst)&TCGbuf[TCGwptr])=tcg04;
    DBMSG_GCODE("GCP G04: val %ld, sendcount %ld\n",tcg04.value,tcg04.sendCount);
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g2X2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: conver unit as g20 g21 betwen meter and inch
****************************************************************************
*/
U8 g2X2TCG(void)
{
    PcompiledM g2021;
    TTCGmcode tcg2021;
    g2021=(PcompiledM)execGptr;
    tcg2021.gnum=g2021->gtype&0xff;
    tcg2021.sendCount=STDsendcount++;
    tcg2021.srcLine=g2021->srcline;
    tcg2021.srcCode=grunPtr;
    gC2TCState.GG06=tcg2021.gnum;
    //gWorkState.GG06=tcg2021.gnum;

    *((PTCGmcode)&TCGbuf[TCGwptr])=tcg2021;
    if(((tcg2021.gnum==GCODE_20)&&(sysUnit==0))  // TO INCH
    ||((tcg2021.gnum==GCODE_21)&&(sysUnit==1)))
    {
        double conver;
        if((tcg2021.gnum==GCODE_20)&&(sysUnit==0))
        {//conver all keep state vars  to inch ,digits  +1
            conver=10/25.4;
            sysUnit=1;
        }else{ //conver vars to meter digit -1
            conver=25.4/10;
            sysUnit=0;
        }
        gC2TCState.x=conver*gC2TCState.x;
        gC2TCState.y=conver*gC2TCState.y;
        gC2TCState.z=conver*gC2TCState.z;
        gC2TCState.i=conver*gC2TCState.i;
        gC2TCState.k=conver*gC2TCState.k;
        gC2TCState.r=conver*gC2TCState.r;
        gC2TCState.g9x=conver*gC2TCState.g9x;
        gC2TCState.g9z=conver*gC2TCState.g9z;
        gC2TCState.g9r=conver*gC2TCState.g9r;
        gC2TCState.orgx=conver*gC2TCState.orgx;
        gC2TCState.orgz=conver*gC2TCState.orgz;
        gC2TCState.shiftx=conver*gC2TCState.shiftx;
        gC2TCState.shiftz=conver*gC2TCState.shiftz;
        gC2TCState.screwf=conver*gC2TCState.screwf;
    }
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    execGptr++;
    grunPtr++;
    DBMSG_M(tcg2021.gnum,tcg2021.sendCount);
    return GERR_OK;
}

/***************************************************************************
*FUNCTION: g502TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g98 g99 to ToolCompensation gcode buffer,
****************************************************************************
*/
U8 g502TCG()
{
    PcompiledG01 glineptr;
    TTCGline tcgline;
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=execGptr->gtype&0xff;
    //tcgline.sendCount=glineptr->srcline;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcLine=glineptr->srcline;
    tcgline.srcCode=grunPtr;
    if(glineptr->paramType&GXU_IS_VALUE)
    {
        if(glineptr->paramType&GXU_IS_INC)
            tcgline.x=glineptr->xu+gC2TCState.x;
        else
            tcgline.x=glineptr->xu;

        //gC2TCState.x=tcgline.x;
    }else if(glineptr->paramType&GXU_IS_PARAM)
    {
        if(glineptr->paramType&GXU_IS_INC)
            tcgline.x=getVarValue(glineptr->xu)+gC2TCState.x;
        else
            tcgline.x=getVarValue(glineptr->xu);
        //gC2TCState.x=tcgline.x;
    }else{
        tcgline.x=gC2TCState.x;
    }
    gC2TCState.orgx=gC2TCState.x+gC2TCState.orgx-tcgline.x;
    gC2TCState.x=tcgline.x;
    //if in dim mode x should /2
    tcgline.x=unit2Meter4Digit(tcgline.x);
    if(dimMode)
    {
        tcgline.x=tcgline.x/2;
    }
    if(glineptr->paramType&GZW_IS_VALUE)
    {
        if(glineptr->paramType&GZW_IS_INC)
            tcgline.z=glineptr->zw+gC2TCState.z;
        else
            tcgline.z=glineptr->zw;
        //gC2TCState.z=tcgline.z;
    }else if(glineptr->paramType&GZW_IS_PARAM)
    {
        if(glineptr->paramType&GZW_IS_INC)
            tcgline.z=getVarValue(glineptr->zw)+gC2TCState.z;
        else
            tcgline.z=getVarValue(glineptr->zw);
        //gC2TCState.z=tcgline.z;
    }else{
        tcgline.z=gC2TCState.z;
    }
    gC2TCState.orgz=gC2TCState.z+gC2TCState.orgz-tcgline.z;
    gC2TCState.z=tcgline.z;
    tcgline.z=unit2Meter4Digit(tcgline.z);
    if(glineptr->paramType&GYV_IS_VALUE)
    {
        if(glineptr->paramType&GYV_IS_INC)
            tcgline.y=glineptr->yv+gC2TCState.y;
        else
            tcgline.y=glineptr->yv;
        //gC2TCState.z=tcgline.z;
    }else if(glineptr->paramType&GYV_IS_PARAM)
    {
        if(glineptr->paramType&GYV_IS_INC)
            tcgline.y=getVarValue(glineptr->yv)+gC2TCState.y;
        else
            tcgline.y=getVarValue(glineptr->yv);
        //gC2TCState.z=tcgline.z;
    }else{
        tcgline.y=gC2TCState.y;
    }
    gC2TCState.orgy=gC2TCState.y+gC2TCState.orgy-tcgline.y;
    gC2TCState.y=tcgline.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    DBMSG_GCODE("GCP 50 :%d X %d,Z %d,sendcount %ld \n",
        tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    execGptr++;
    //(U32 )execGptr=(U32)execGptr+sizeof(TcompiledG01);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //for the tool compensation will get the wrong coord of
    //prev code, we send a fail line code to correct it
    {
        TTCGfst tcgfst;
        tcgfst.gnum=GCODE_LOCATE;
        tcgfst.sendCount=STDsendcount;
        tcgfst.srcLine=glineptr->srcline;
        tcgfst.srcCode=grunPtr;
        tcgfst.coordx=unit2Meter4Digit(gC2TCState.x);
        if(dimMode)
            tcgfst.coordx=tcgfst.coordx/2;
        tcgfst.coordz=unit2Meter4Digit(gC2TCState.z);
        tcgfst.coordy=unit2Meter4Digit(gC2TCState.y);
        *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    tcgline.gnum=GCODE_00;
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g5x2TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g54 g55 g56 g57 g58 g59 to ToolCompensation gcode buffer,
****************************************************************************
*/
U8  g5x2TCG()
{
    PcompiledG23 glineptr;
    TTCGline tcgline;
    TTCGfst tcg5x;
    U32 prevg5x;
    S32 prevorgx=gC2TCState.orgx;
    S32 prevorgz=gC2TCState.orgz;
    S32 prevorgy=gC2TCState.orgy;
    glineptr=(PcompiledG23)execGptr;
    tcg5x.gnum=GCODE_54;
    tcg5x.sendCount=STDsendcount;
    tcg5x.srcLine=glineptr->srcline;
    tcg5x.srcCode=grunPtr;
    tcg5x.value=0;
    if(glineptr->paramType&GR_IS_VALUE)
    {
        tcg5x.value=glineptr->r;
    }else if(glineptr->paramType&GR_IS_PARAM){
        tcg5x.value= getVarValuePQ(glineptr->r);
    }
    if(tcg5x.value==0||tcg5x.value>=G5X_MAX)
    {
        return GERR_P_APPEAR;
    }
    prevg5x=gC2TCState.GG05;
    gC2TCState.GG05=tcg5x.value;
    if(dimMode)
    {
        gC2TCState.orgx=gC2TCState.orgx+2*meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].x-coordOrginWorkG5x[prevg5x].x);
    }else{
        gC2TCState.orgx=gC2TCState.orgx+meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].x-coordOrginWorkG5x[prevg5x].x);
    }
    gC2TCState.orgz=gC2TCState.orgz+meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].z-coordOrginWorkG5x[prevg5x].z);
    gC2TCState.orgy=gC2TCState.orgy+meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].y-coordOrginWorkG5x[prevg5x].y);
    *((PTCGfst)&TCGbuf[TCGwptr])=tcg5x;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GCODE("GCP G5x: %d , sendcount %ld\n",
        tcg5x.gnum,tcg5x.sendCount);
    {
        TTCGfst tcgfst;
        tcgfst.gnum=GCODE_LOCATE;
        tcgfst.sendCount=STDsendcount;
        tcgfst.srcLine=glineptr->srcline;
        tcgfst.srcCode=grunPtr;
        if(dimMode)
        {
            tcgfst.coordx=unit2Meter4Digit(gC2TCState.x+2*meter4Digit2Unit(-coordOrginWorkG5x[gC2TCState.GG05].x+coordOrginWorkG5x[prevg5x].x))/2;
        }else{
            tcgfst.coordx=unit2Meter4Digit(gC2TCState.x+meter4Digit2Unit(-coordOrginWorkG5x[gC2TCState.GG05].x+coordOrginWorkG5x[prevg5x].x));
        }
        tcgfst.coordz=unit2Meter4Digit(gC2TCState.z+meter4Digit2Unit(-coordOrginWorkG5x[gC2TCState.GG05].z+coordOrginWorkG5x[prevg5x].z));
        tcgfst.coordy=unit2Meter4Digit(gC2TCState.y+meter4Digit2Unit(-coordOrginWorkG5x[gC2TCState.GG05].y+coordOrginWorkG5x[prevg5x].y));
        *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    //if(glineptr->paramType&(GXU_IS_SETED|GZW_IS_SETED)) //更改坐标系后必须发G00
    {
        tcgline.gnum=GCODE_00;
        tcgline.sendCount=STDsendcount++;
        tcgline.srcLine=glineptr->srcline;
        tcgline.srcCode=grunPtr;
        if(glineptr->paramType&GXU_IS_VALUE)
        {
            if(glineptr->paramType&GXU_IS_INC)
            {
                tcgline.x=glineptr->xu+gC2TCState.x+prevorgx-gC2TCState.orgx;//增量编程时以当前机械点为准，凯恩帝说明中有系统参数可选
            }
            else{
                tcgline.x=glineptr->xu;
            }
            //compiledX=tcgline.x;
            gC2TCState.x=tcgline.x;
        }else if(glineptr->paramType&GXU_IS_PARAM)
        {
            if(glineptr->paramType&GXU_IS_INC)
            {
                tcgline.x=getVarValue(glineptr->xu)+gC2TCState.x+prevorgx-gC2TCState.orgx;
            }else{
                tcgline.x=getVarValue(glineptr->xu);
            }
            gC2TCState.x=tcgline.x;
        }else{
            tcgline.x=gC2TCState.x+prevorgx-gC2TCState.orgx;
            gC2TCState.x=tcgline.x;
        }
        //if(DSPparam.sysbyte[79]==1)  //
        //if in dim mode x should /2
        tcgline.x=unit2Meter4Digit(tcgline.x);
        if(dimMode)
        {
            tcgline.x=tcgline.x/2;
        }
        if(glineptr->paramType&GZW_IS_VALUE)
        {
            if(glineptr->paramType&GZW_IS_INC)
                tcgline.z=glineptr->zw+gC2TCState.z+prevorgz-gC2TCState.orgz;
            else
                tcgline.z=glineptr->zw;
            //compiledZ=tcgline.z;
            gC2TCState.z=tcgline.z;
        }else if(glineptr->paramType&GZW_IS_PARAM)
        {
            if(glineptr->paramType&GZW_IS_INC)
                tcgline.z=getVarValue(glineptr->zw)+gC2TCState.z+prevorgz-gC2TCState.orgz;
             else
                tcgline.z=getVarValue(glineptr->zw);
            gC2TCState.z=tcgline.z;
        }else{
            tcgline.z=gC2TCState.z+prevorgz-gC2TCState.orgz;
            gC2TCState.z=tcgline.z;
        }
        tcgline.z=unit2Meter4Digit(tcgline.z);
        if(glineptr->paramType&GYV_IS_VALUE)
        {
            if(glineptr->paramType&GYV_IS_INC)
                tcgline.y=glineptr->yv+gC2TCState.y+prevorgy-gC2TCState.orgy;
            else
                tcgline.y=glineptr->yv;
            //compiledZ=tcgline.z;
            gC2TCState.y=tcgline.y;
        }else if(glineptr->paramType&GYV_IS_PARAM)
        {
            if(glineptr->paramType&GYV_IS_INC)
                tcgline.y=getVarValue(glineptr->yv)+gC2TCState.y+prevorgy-gC2TCState.orgy;
             else
                tcgline.y=getVarValue(glineptr->yv);
            gC2TCState.y=tcgline.y;
        }else{
            tcgline.y=gC2TCState.y+prevorgy-gC2TCState.orgy;
            gC2TCState.y=tcgline.y;
        }
        tcgline.y=unit2Meter4Digit(tcgline.y);
        *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }/*else{
        if(dimMode)
        {
            tcgline.x=gC2TCState.x=gC2TCState.x-2*meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].x+coordOrginWorkG5x[prevg5x].x);
        }else{
            tcgline.x=gC2TCState.x=gC2TCState.x-meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].x+coordOrginWorkG5x[prevg5x].x);
        }
        tcgline.z=gC2TCState.z=gC2TCState.z+meter4Digit2Unit(coordOrginWorkG5x[gC2TCState.GG05].z+coordOrginWorkG5x[prevg5x].z);
        tcgline.gnum=GCODE_00;
        *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        STDsendcount++;
    }*/
    execGptr++;
    grunPtr++;
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g909294infoClear
*PARAMETER :void
*RETURN : void
*DESCRIPTION: if a line arc or screw g cmd is run ,g90 g92 g94 xz r
*   should be clear
****************************************************************************
*/
void g909294infoClear()
{
    gC2TCState.g9x=gC2TCState.x;
    gC2TCState.g9z=gC2TCState.z;
    gC2TCState.g9r=0;
}
/***************************************************************************
*FUNCTION: g90942TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g90 g94 to ToolCompensation gcode buffer,
****************************************************************************
*/
U8 g90942TCG()
{
    PcompiledG23 g90ptr;
    TTCGline tcgline;
    S32 x0,x1,x2,z0,z1,z2,r,dx,dz,y;

    g90ptr=execGptr;
    DBMSG_GCODE("GCP start %d\n",g90ptr->gtype);
    if(gC2TCState.f==0)
        return GERR_NOFEED_G1;
    //tcgline.sendCount=g90ptr->srcline;
    tcgline.sendCount=STDsendcount;
    tcgline.srcLine=g90ptr->srcline;
    tcgline.srcCode=grunPtr;
     //make sure buf have the space to heel the code
    //if(CYCLE_BUF_DEEP(TCGwptr, TCGrptr, TCG_BUF_MAX)>(TCG_BUF_MAX-6))
    //    return;
    //get the x and z value
    y=gC2TCState.y;
    y=unit2Meter4Digit(y);
    x0=gC2TCState.x;
    x0=unit2Meter4Digit(x0);
    if(dimMode)
    {
        x0=x0/2;
    }
    z0=gC2TCState.z;
    z0=unit2Meter4Digit(z0);
    r=0;
    if(g90ptr->paramType&GR_IS_VALUE)
    {
        r=g90ptr->r;
    }else if(g90ptr->paramType&GR_IS_PARAM)
    {
        r=getVarValue(g90ptr->r);
    }else{
        r=gC2TCState.g9r;
    }
    gC2TCState.g9r=r;
    r=unit2Meter4Digit(r);
    if(!(g90ptr->paramType&GXU_IS_SETED))
    {
       x1=gC2TCState.g9x;
    }else if(g90ptr->paramType&GXU_IS_INC) //set as u
    {
        if(g90ptr->paramType&GXU_IS_VALUE)
        {
            x1=g90ptr->xu+gC2TCState.x;
            //dx=g90ptr->xu;
        }else if(g90ptr->paramType&GXU_IS_PARAM){
            x1=getVarValue(g90ptr->xu)+gC2TCState.x;
            //dx=getVarValue(g90ptr->xu);
        }
        gC2TCState.g9x=x1;

    }else{  //is set as x
        if(g90ptr->paramType&GXU_IS_VALUE)
        {
            x1=g90ptr->xu;
        }else if(g90ptr->paramType&GXU_IS_PARAM){
            x1=getVarValue(g90ptr->xu);
        }
        gC2TCState.g9x=x1;

    }
    dx=x1-gC2TCState.x;
    dx=unit2Meter4Digit(dx);
    //if in dim mode x should /2
    x1=unit2Meter4Digit(x1);
    if(dimMode)
    {
        x1=x1/2;
        dx=dx/2;
    }
    if(!(g90ptr->paramType&GZW_IS_SETED))
    {
        z1=gC2TCState.g9z;
    }else if(g90ptr->paramType&GZW_IS_INC) //set as u
    {
        if(g90ptr->paramType&GZW_IS_VALUE)
        {
            z1=g90ptr->zw+gC2TCState.z;
            //dz=g90ptr->zw;
        }else if(g90ptr->paramType&GZW_IS_PARAM){
            z1=getVarValue(g90ptr->zw)+gC2TCState.z;
            //dz=g90ptr->zw;
        }
        gC2TCState.g9z=z1;
    }else{  //is set as x
        if(g90ptr->paramType&GZW_IS_VALUE)
        {
            z1=g90ptr->zw;
        }else if(g90ptr->paramType&GZW_IS_PARAM){
            z1=getVarValue(g90ptr->zw);
        }
        gC2TCState.g9z=z1;
        //dz=z1-gC2TCState.z;
    }
    dz=z1-gC2TCState.z;
    dz=unit2Meter4Digit(dz);
    z1=unit2Meter4Digit(z1);
    if((g90ptr->gtype&0xff)==90)
    {
         if(r!=0)//detemide where r should be add
         {
           if(((dx>0)&(r<0))||((dx<0)&&(r>0)))
           {
                if((abs(dx)<abs(r)))
                {
                    //DEBUGMSG(1,"G9X with error r\n");
                    //return GERR_UNKNOWN;
                    r=0-dx;
                }
           }
           x2=x1;
           x1=x1+r;
         }else{
            x2=x1;
         }
         tcgline.gnum=GCODE_00;
         tcgline.x=x1;
         tcgline.z=z0;
         tcgline.y=y;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
         tcgline.gnum=GCODE_01;
         tcgline.x=x2;
         tcgline.z=z1;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
         tcgline.gnum=GCODE_01;
         tcgline.x=x0;
         tcgline.z=z1;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
         tcgline.gnum=GCODE_00;
         tcgline.x=x0;
         tcgline.z=z0;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
     }else
     {// is g94
         if(r!=0) //detemide where r should be add
         {
             if(((dz>0)&&(r<0))||((dz<0)&&(r>0)))
             {
                 if(abs(dz)<abs(r))
                 {
                     //DEBUGMSG(1,"G9X with error r\n");
                     //return GERR_UNKNOWN;
                     r=0-dz;
                 }
             }
             z2=z1;
             z1=z1+r;
         }else{
            z2=z1;
         }
         tcgline.gnum=GCODE_00;
         tcgline.x=x0;
         tcgline.z=z1;
         tcgline.y=y;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
         tcgline.gnum=GCODE_01;
         tcgline.x=x1;
         tcgline.z=z2;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
         tcgline.gnum=GCODE_01;
         tcgline.x=x1;
         tcgline.z=z0;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
         tcgline.gnum=GCODE_00;
         tcgline.x=x0;
         tcgline.z=z0;
         DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
         *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    STDsendcount++;
    execGptr++;
    grunPtr++;
    DBMSG_GCODE("G %d, x %d, z%d, r %d, sendcount %ld\n",
        (g90ptr->gtype&0xff), x1, z1,r,tcgline.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g922TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g92 to ToolCompensation gcode buffer,
****************************************************************************
*/
U8 g922TCG()
{
    TTCGarc codebuf;
    TTCGline codeline;
    PTCGmcode pm=(PTCGmcode)&codebuf;
    PTCGfst   pfst=(PTCGfst)&codebuf;
    PTCGline  pline=&codeline;
    PcompiledG23 g92=execGptr;
    double dx,dz,dr,f;
    S32 x0,z0,x1,z1,x2,r,u,y;
    U32 dj;  //dao jiao in x2 z2
    S32 djx; //倒角前终点x值，
    S8 djsign=1;
    static U8 headIndex;
    //we must fill the TCG buffer with 7 gcode ,make sure it have space
    //if(CYCLE_BUF_DEEP(TCGwptr, TCGrptr, TCG_BUF_MAX)>(TCG_BUF_MAX-12))
    //    return;
    //check if the p q is setted, if p is seted and q not set,
    // it will be a compound code of g92
    if((compoundGcode==0)&&
        (!(g92->paramType&GI_IS_SETED)))
    {
        if(g92->paramType&GK_IS_SETED)
        {
            compoundGcode=92;
            if(g92->paramType&GK_IS_VALUE)
            {
                gC2TCState.screwHead=g92->k;
            }else{
                gC2TCState.screwHead=getVarValuePQ(g92->k);
            }
            headIndex=0;
            if((gC2TCState.screwHead==0)
                ||(gC2TCState.screwHead>100))
            {
                compoundGcode=0;
                gC2TCState.screwHead=1;
            }
            //gC2TCState.screwHead=headNum;
        }else if((gC2TCState.screwHead>1)&&
            (gC2TCState.screwHead<=100))
        {
            headIndex=0;
            compoundGcode=92;
        }else{
            headIndex=0;
        }
    }
    //get the x and z value
    DBMSG_GCODE("GCP start g92\n");
    y=gC2TCState.y;
    y=unit2Meter4Digit(y);
    x0=gC2TCState.x;
    x0=unit2Meter4Digit(x0);
    if(dimMode)
    {
        x0=x0/2;
    }
    z0=gC2TCState.z;
    z0=unit2Meter4Digit(z0);
    if(g92->paramType&GXU_IS_VALUE)
    {
        if(g92->paramType&GXU_IS_INC)
        {
            x1=g92->xu+gC2TCState.x;
        }else{
            x1=g92->xu;
        }
        gC2TCState.g9x=x1;
    }else if(g92->paramType&GXU_IS_PARAM)
    {
        if(g92->paramType&GXU_IS_INC)
        {
            x1=getVarValue(g92->xu)+gC2TCState.x;
        }else{
            x1=getVarValue(g92->xu);
            }
        gC2TCState.g9x=x1;
    }else{
        x1=gC2TCState.g9x;
    }
    u=x1-gC2TCState.x;
    u=unit2Meter4Digit(u);
    x1=unit2Meter4Digit(x1);
    if(dimMode)
    {
        x1=x1/2;
        u=u/2;
    }
    //is it a delta screw
    r=0;
    if(g92->paramType&GR_IS_VALUE)
    {
        r=g92->r;
    }else if(g92->paramType&GR_IS_PARAM)
    {
        r=getVarValue(g92->r);
    }else{
        r=gC2TCState.g9r;
    }
    gC2TCState.g9r=r;
    r=unit2Meter4Digit(r);

    if(g92->paramType&GZW_IS_VALUE)
    {
        if(g92->paramType&GZW_IS_INC)
        {
            z1=g92->zw+gC2TCState.z;
            //dz=abs(g92->zw);
        }else{
            z1=g92->zw;
        }
        gC2TCState.g9z=z1;
    }else if(g92->paramType&GZW_IS_PARAM)
    {
        if(g92->paramType&GZW_IS_INC)
        {
            z1=getVarValue(g92->zw)+gC2TCState.z;
        }else{
            z1=getVarValue(g92->zw);
            }
        gC2TCState.g9z=z1;
    } else{
        z1=gC2TCState.g9z;
    }
    dz=abs(z1-gC2TCState.z);
    dz=unit2Meter4DigitFloat(dz);
    z1=unit2Meter4Digit(z1);
    if(r!=0)//detemide where r should be add
    {
        if(((u>0)&(r<0))||((u<0)&&(r>0)))
        {
             if((abs(u)<abs(r)))
             {
                 return GERR_PARAM_VALERR;
                 //r=0-u;
             }
        }
        x2=x1;
        x1=x1+r;
    }else{
        x2=x1;
    }
    f=0;
    //get screw f
    if(g92->paramType&GF_IS_SETED)
    {
        if(g92->paramType&GF_IS_VALUE)
            f=g92->f;
        else
            f=getVarValue(g92->f);
        if(g92->paramType&GF_IS_INC)
        {
            if(f==0)
                return GERR_PARAM_VALERR;
            if(sysUnit==0)
            {  //IS ENLARGE 1000
                f=25400000.0/f;
            }else{
                //given as # or i in inch, IS ENLARGE 10000
                f=100000000.0/f;
            }
        }
        gC2TCState.screwf=f;
    }else{
        if(gC2TCState.screwf>0)
            f=gC2TCState.screwf;
        else
            return GERR_G32_MISS_FI;
    }
    f=unit2Meter4DigitFloat(f);
    f=f/10000.0;// the f in g92 is u ,conver form u to mm
    //dj=f*DSPparam.sysdword[70]*10000/10;  //for param THDCH
    dj=f*SYSparam[198].val*10000/10;
    //dj=unit2Meter4Digit(dj); //since f had make this conver
    djx=1.0L*dj*abs(r)/abs(dz);
    if(x1<x2)
        djx=0-djx;

    //step 2.1 add a prev f resum code here
    if(gC2TCState.f==0) //give a special f
    {
         if(gC2TCState.GG03==GCODE_99)
         {
            gC2TCState.f=20;
         }else{
            gC2TCState.f=30000;
         }
         pfst->gnum=GCODE_F;
         pfst->sendCount=STDsendcount;
         pfst->srcLine=g92->srcline;
         pfst->srcCode=grunPtr;
         pfst->value=gC2TCState.f;
         DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
          *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }

    //step 1
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_00;
    //pline->sendCount=g92->srcline;
    pline->sendCount=STDsendcount;
    pline->srcLine=g92->srcline;
    pline->srcCode=grunPtr;
    pline->x=x1;
    pline->z=z0;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //as lly need ,we put all asssic code after 1 g01
    //line real screw, step 2
    /*
    pline->gnum=GCODE_01;
    pline->x=x2;
    if(z1>z0)
        djsign=-1;
    pline->z=z1+dj*djsign;
    //pline->sendCount=g92->srcline;
    pline->sendCount=STDsendcount;
    pline->srcLine=g92->srcline;
    pline->srcCode=grunPtr;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    */

    //m3
    memset(pm,0,sizeof(TTCGarc));
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        return GERR_SCREW_NOS;
        //gexecState=GEXEC_EXERR;
        //showHint(OPERR_SSTOP_SCREW,SHOW_TIME_FEVER);
    }
    //pm->sendCount=g92->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g92->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //M253
    memset(pm,0,sizeof(TTCGarc));
    pfst->gnum=GCODE_M253;
    if(g92->paramType&GI_IS_SETED)
    { //q is setted
        if(g92->paramType&GI_IS_VALUE)
        {
            pfst->value=g92->i;
        }else if(g92->paramType&GI_IS_PARAM)
        {
            pfst->value=getVarValue(g92->i);
        }
        if(pfst->value>360000)
            pfst->value=0;
    }else if(compoundGcode==92)
    {//p is setted
        pfst->value=headIndex*360000/gC2TCState.screwHead;
    }else{ //both p and q is not set
        pfst->value=0;
    }
    //pfst->sendCount=g92->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g92->srcline;
    pfst->srcCode=grunPtr;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //S
    pfst->gnum=GCODE_S;
    //pfst->sendCount=g92->srcline;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g92->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.s; //s must be
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //g01 since f need x, z ,we cal g1 first, save it later
    //dx=abs(r);
    //dz=abs(z0-z1);
    dr=0;
    dr=sqrt(r*r+dz*dz);

    if(dz>abs(r))
    {
       f=(double)dr/dz*f*gC2TCState.s;
    }else
    {   //here is a bug by vinge 20091204
        f=(double)dr/abs(r)*f*gC2TCState.s;
    }
    f=f*1000.0; //form mm to um now
    if(((U32)f)==0)
        return GERR_NOFEED_G1;
    //F
    pfst->gnum=GCODE_SCREW;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g92->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=f/gC2TCState.s;//g92->k*gC2TCState.s;
    /*//f is now u/min, conver to u/s
    if(gC2TCState.GG03==GCODE_99)
    {
        //pfst->value=f/60.0;
        f=f/gC2TCState.s;
        pfst->value=f;
    }*/

    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //m255
    memset(pm,0,sizeof(TTCGarc));
    pm->gnum=GCODE_M255;
    //pm->sendCount=g92->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g92->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m3
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        return GERR_SCREW_NOS;
        //gexecState=GEXEC_EXERR;
        //showHint(OPERR_SSTOP_SCREW,SHOW_TIME_FEVER);
    }
    //pm->sendCount=g92->srcline;
    pm->sendCount=STDsendcount;
    pm->srcLine=g92->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //line real screw, step 2
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_01;
    pline->x=x2+djx;
    if(z1>z0)
        djsign=-1;
    pline->z=z1+dj*djsign;
    pline->y=y;
    //pline->sendCount=g92->srcline;
    pline->sendCount=STDsendcount;
    pline->srcLine=g92->srcline;
    pline->srcCode=grunPtr;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    memset(pline,0,sizeof(TTCGline));

    //step 2.1 add a prev f resum code here
    if(gC2TCState.f==0) //give a special f
    {
         if(gC2TCState.GG03==GCODE_99)
         {
            gC2TCState.f=10;
         }else{
            gC2TCState.f=30000;
         }
    }
    pfst->gnum=GCODE_F;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g92->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.f;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //step2.5
    pline->gnum=GCODE_01;
    //pline->sendCount=g92->srcline;
    pline->sendCount=STDsendcount;
    pline->srcLine=g92->srcline;
    pline->srcCode=grunPtr;
    if(x0<x1)
        djsign=-1;
    else if(x0>x1)
        djsign=1;
    else{ //when x0==x1
        if(x0<x2)
            djsign=-1;
        else
            djsign=1;
    }
    pline->x=x2+dj*djsign;
    pline->z=z1;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //add the g04 to sign the screw phase is over
    pfst->gnum=GCODE_04;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g92->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=0;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //step 3
    pline->gnum=GCODE_00;
    pline->x=x0;
    pline->z=z1;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 4
    pline->gnum=GCODE_00;
    pline->x=x0;
    pline->z=z0;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    STDsendcount++;
    if(compoundGcode==92)
    {
        headIndex++;
        if(headIndex>=gC2TCState.screwHead)
        {
            compoundGcode=0;
            execGptr++;
            grunPtr++;
        }
    }else{
        execGptr++;
        grunPtr++;
    }
    //(U32 )execGptr=(U32)execGptr+sizeof(TcompiledG23);

    DBMSG_GCODE("GCP screw 92 : X %d,Z %d\n",g92->xu,g92->zw);
    return GERR_OK;
}

/***************************************************************************
*FUNCTION: g96972TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g96 g97 to ToolCompensation gcode buffer,
****************************************************************************
*/
U8 g96972TCG()
{
    PcompiledFST fstptr;
    TTCGfst tcg9697;
    U8 prevIs96=0;
    U8 hasS=0;
    fstptr=(PcompiledFST)execGptr;
    tcg9697.gnum=fstptr->gtype&0XFF;
    prevIs96=gC2TCState.GG02;
    gC2TCState.GG02=tcg9697.gnum;
    if(fstptr->paramType&S_IS_VALUE)
    {
        tcg9697.value=fstptr->value;
    }else if (fstptr->paramType&S_IS_PARAM)
    {
        //it is a param
        tcg9697.value=getVarValuePQ(fstptr->value);

    }else{
        //tell dsp to hare form g96
        tcg9697.value=-1;//gC2TCState.s;
    }
    if(tcg9697.value==-1)
    {
        if(gC2TCState.GG02==GCODE_96)
        {
            tcg9697.value=gC2TCState.slinespeed;
            //if(gC2TCState.slinespeed==0)
            //    return GERR_NOSS_M0304;
        }else{//97,no speed rpm given ,cal it
            if(prevIs96==GCODE_96)
            {
                prevIs96=1;
                tcg9697.value=gC2TCState.slinespeed;
            }else{//prev 97, and g97 again, nothing change
                prevIs96=0;
            }
        }
    }
    //save the spindle speed or line speed
    if(tcg9697.value!=-1)
    {
        if(gC2TCState.GG02==GCODE_96)
        {
            gC2TCState.slinespeed=tcg9697.value;
        }else{
            hasS=1;
            gC2TCState.s=tcg9697.value;
            if(gC2TCState.s>SYSparam[168].val)
                gC2TCState.s=SYSparam[168].val;
        }
    }

    //if(((gC2TCState.GG02==GCODE_96)&&(tcg9697.value!=-1))
    //||(prevIs96==1))
    if(prevIs96==1)
    {
        //Conver line speed to rpm
        U32 newrpm;
        U32 linespeed;
        U32 dim;

        if(dimMode)
        {
            dim=abs(gC2TCState.x);
        }else{
            dim=abs(gC2TCState.x*2);
        }
        dim=unit2Meter4Digit(dim)/10000; //conver to meter mm
        if(dim==0) dim=1;
        if(sysUnit==1) //inch unit,conver to meter mm
        {
            tcg9697.value=tcg9697.value*25.4;
        }else{
            tcg9697.value=tcg9697.value*1000; // m to mm
        }
        newrpm=tcg9697.value/(PI*dim);
        tcg9697.value=newrpm;
        if(tcg9697.value<10)
            tcg9697.value=10;
        //we don't limit the rpm here,
        //it will make g96 cal error rpm if dim is tool small
        //dsp should do the work

        //else if(tcg9697.value>SYSparam[168].val)
        //    tcg9697.value=SYSparam[168].val;
        if(prevIs96==1)
        {

            if(tcg9697.value>SYSparam[168].val)
                tcg9697.value=SYSparam[168].val;
            if((tcg9697.value>gC2TCState.G96SpinspeedLimit)
              &&(gC2TCState.G96SpinspeedLimit!=0))
                tcg9697.value=gC2TCState.G96SpinspeedLimit;
            gC2TCState.s=tcg9697.value;
        }
    }else if(gC2TCState.GG02==GCODE_96)
    {
        if(sysUnit==1) //inch unit,conver to meter mm
        {
            tcg9697.value=tcg9697.value*25.4;
        }else{
            tcg9697.value=tcg9697.value*1000; // m to mm
        }
    }
    tcg9697.sendCount=STDsendcount++;
    tcg9697.srcLine=fstptr->srcline;
    tcg9697.srcCode=grunPtr;
    *((PTCGfst)&TCGbuf[TCGwptr])=tcg9697;
    execGptr++;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    grunPtr++;
    DBMSG_GCODE("GCP G9697: %d val %ld, sendcount %ld\n",
        tcg9697.gnum,tcg9697.value,tcg9697.sendCount);
    if((prevIs96==1)||(hasS==1))
    { //send a s code to set the s correct
        tcg9697.gnum=GCODE_S;
        *((PTCGfst)&TCGbuf[TCGwptr])=tcg9697;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        DBMSG_GCODE("GCP FST: %d val %ld, sendcount %ld\n",
            tcg9697.gnum,tcg9697.value,tcg9697.sendCount);
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g98992TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: send compiled g98 g99 to ToolCompensation gcode buffer,
****************************************************************************
*/
U8  g98992TCG()
{
    PcompiledFST fstptr;
    TTCGfst tcg9899;
    U8 prevIs98=0;
    fstptr=(PcompiledFST)execGptr;
    tcg9899.gnum=fstptr->gtype&0XFF;
    prevIs98=gC2TCState.GG03;
    gC2TCState.GG03=tcg9899.gnum; //save the state of g9899
    if(fstptr->paramType&F_IS_VALUE)
    {
        tcg9899.value=fstptr->value;
    }else if (fstptr->paramType&F_IS_PARAM)
    {
        //it is a param
        tcg9899.value=getVarValue(fstptr->value);
    }else{
        //not set
        tcg9899.value=0;
    }

    tcg9899.gnum=fstptr->gtype&0XFF;
    //tcg9899.sendCount=fstptr->srcline;
    tcg9899.sendCount=STDsendcount;
    tcg9899.srcLine=fstptr->srcline;
    tcg9899.srcCode=grunPtr;
    *((PTCGfst)&TCGbuf[TCGwptr])=tcg9899;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    if(fstptr->paramType&F_IS_SETED) //if a new f is give out
    {
        tcg9899.gnum=GCODE_F;
        tcg9899.sendCount=STDsendcount++;
        gC2TCState.f=tcg9899.value;

        //check speed limit
        if((gC2TCState.f>(SYSparam[169].val*1000))||
        ((gC2TCState.GG03==GCODE_99)&&
          ((gC2TCState.s*gC2TCState.f)>(SYSparam[169].val*1000))))
            return GERR_G1SPEED;

        *((PTCGfst)&TCGbuf[TCGwptr])=tcg9899;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }else{ //if no f is given with g98 g99 ,cal it out
        if((prevIs98==GCODE_98)&&(gC2TCState.GG03==GCODE_99))
        {
            if(gC2TCState.s==0)
                gC2TCState.f=0;
            else
                gC2TCState.f=gC2TCState.f/gC2TCState.s;
        }else if((prevIs98==GCODE_99)&&(gC2TCState.GG03==GCODE_98))
        {
            gC2TCState.f=gC2TCState.f*gC2TCState.s;
            //check speed limit
            if((gC2TCState.f>(SYSparam[169].val*1000))||
            ((gC2TCState.GG03==GCODE_99)&&
              ((gC2TCState.s*gC2TCState.f)>(SYSparam[169].val*1000))))
                return GERR_G1SPEED;
        }
        if(gC2TCState.f==0) //give a special f
        {
             if(gC2TCState.GG03==GCODE_99)
             {
                gC2TCState.f=10;
             }else{
                gC2TCState.f=30000;
             }
        }
        tcg9899.gnum=GCODE_F;
        tcg9899.sendCount=STDsendcount++;
        tcg9899.value=gC2TCState.f;
        *((PTCGfst)&TCGbuf[TCGwptr])=tcg9899;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    execGptr++;

    //(U32 )execGptr=(U32)execGptr+sizeof(TcompiledFST);
    grunPtr++;
    DBMSG_GCODE("GCP G9899: %d val %ld, sendcount %ld\n",
        tcg9899.gnum,tcg9899.value,tcg9899.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g7XgetStartEnd
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g73 to send code to tcgbuffer
****************************************************************************
*/
U32 g7xGetStartEnd(PcompiledG7x g7x)
{
    U16 i;
    U32 p,q;
    if(((g7x->paramType&GI_IS_SETED)==0)||
    ((g7x->paramType&GK_IS_SETED)==0))
    { //pq must be provid both
        return GERR_PARAM_VALERR;
        //return GERR_G7X_MISS_PQ ;
    }
    if(g7x->paramType&GI_IS_VALUE)
    {
        p=g7x->p;
    }else{ //is param
        p=getVarValuePQ(g7x->p);
    }
    if(g7x->paramType&GK_IS_VALUE)
    {
        q=g7x->q;
    }else{ //is param
        q=getVarValuePQ(g7x->q);
    }
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==p)
        {
            cpdStart=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG; //no where to jump to
    }
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==q)
        {
            cpdEnd=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG;
    }
    //one source code may contain multi gcode
    //find the last one of it
    {
    U32 j,src;
    src=compiledGbuf[cpdEnd].srcline;
    for(j=cpdEnd+1;j<gCompiledCt;j++)
    {
        if(compiledGbuf[j].srcline==src)
        {
            cpdEnd=j;
        }else{
            break;
        }
    }
    }
    if (cpdStart > cpdEnd)
    {
        ALARM_GRP1|=ALM_GRP1_G71G72G73_N;
        return GERR_OK;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g702TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g73 to send code to tcgbuffer
****************************************************************************
*/
U8 g702TCG(void)
{
    U8 err;
    if(compoundGcode==0)
    {
        err=g70GetVar();
    }else{
        U32 i;
        for(i=0;i<3;i++)
        {
            if((execGptr->gtype&0xff)==0x71)
            {
                err = Macro_Before_G();
                if(err!=GERR_OK)
                    return err;
            }
            switch(execGptr->gtype)
            {
                case(0):
                case(1):
                    err=gLine2TCG();
                    break;
                case(2):
                case(3):
                    err=gArc2TCG();
                    break;
                case(4):
                    err=gPause2TCG();
                    break;
            case (GCODE_M00):
            case (GCODE_M03):
            case (GCODE_M04):
            case (GCODE_M05):
            case (GCODE_M08):
            case (GCODE_M09):
            case (GCODE_M10):
            case (GCODE_M11):
            case (GCODE_M12):
            case (GCODE_M13):
                    err=gMcode2TCG();
                    break;
                case (GCODE_F):
                case (GCODE_S):
                case (GCODE_T):
                case (GCODE_M50):
                case (GCODE_M65):
                    err=gFST2TCG();
                    break;
                case(40):
                case(41):
                case(42):
                    err=gToolOpt2TCG();
                    break;
                case(96):
                case(97):
                    err=g96972TCG();
                    break;
                case(98):
                case(99):
                    err=g98992TCG();
                    break;
                default:
                    //omit
                    err=GERR_G_UNKOWN;
                    break;
            }
            g70CheckEnd();
            if(err!=GERR_OK)
                return err;
            if(compoundGcode==0)
            {
                break; //we had encounter end or g73
            }
        }
    }
    return err;
}
/***************************************************************************
*FUNCTION: g70GetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set the g70 begin vars
****************************************************************************
*/
U8 g70GetVar(void)
{
	U32 i;
	U32 err;
	TTCGfst tcgfst;
    PcompiledG7x g70=(PcompiledG7x)execGptr;
    err=g7xGetStartEnd(g70);
    if(err!=GERR_OK)
        return err;
    compoundGcode=GCODE_70;
    cpdGptr=execGptr;
    cpdPtr=grunPtr;
    cpdNextPtr=grunPtr+1;

    grunPtr=cpdStart;
    execGptr=&compiledGbuf[grunPtr];
    g7xorgx=gC2TCState.x;
    g7xorgz=gC2TCState.z;
    //we send a fait code to make it be seen by auto break point
    tcgfst.gnum=GCODE_F;
    tcgfst.sendCount=STDsendcount++;
    tcgfst.srcLine=g70->srcline;
    tcgfst.srcCode=grunPtr;
    tcgfst.value=gC2TCState.f;
    *((PTCGfst)&TCGbuf[TCGwptr])=tcgfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //save the code after g70 ,we shoudl jump there, after g70 done
    DBMSG_GCODE("GCP g70 started\n");
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g7xAddCodeG45
*PARAMETER :45 ,or 46
*RETURN : void
*DESCRIPTION: check if we are in g41 g42 ,if yes add a g45 to
* stop it in g7x code, a gcode 45 is given as param
* whene g7x stop we check if in g41 g42 ,we need recover form
* g45, a 46 is given as param
****************************************************************************
*/
void g7xAddCodeG4546(U16 code)
{
    if(gC2TCState.GG04!=GCODE_40)
    {
        PcompiledM g4042;
        TTCGmcode tcgm;

        if((code!=GCODE_45)&&(code!=GCODE_46))
            return;
        g4042=(PcompiledM)execGptr;
        tcgm.gnum=code;
        tcgm.sendCount=STDsendcount;
        tcgm.srcLine=g4042->srcline;
        tcgm.srcCode=grunPtr;
        *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
        DBMSG_GCODE("GCP G4546 %x, sendCount %ld\n",tcgm.gnum,tcgm.sendCount);
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
}

/***************************************************************************
*FUNCTION: g70CheckEnd
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g73 to send code to tcgbuffer
****************************************************************************
*/
void g70CheckEnd(void)
{
    PcompiledG23 gptr;
    TTCGline tcgline;
    gptr=(PcompiledG23)execGptr;
    if(grunPtr==(cpdEnd+1))
    {
        compoundGcode=0;
        grunPtr=cpdNextPtr;
        execGptr=&compiledGbuf[grunPtr];

        //add a g0 to go to loop start point
        tcgline.gnum=GCODE_00;
        tcgline.sendCount=STDsendcount++;
        tcgline.srcLine=gptr->srcline;
        tcgline.srcCode=grunPtr;
        tcgline.x=g7xorgx;//-du-di+stepx*d;
        tcgline.z=g7xorgz;//-dw-dk+stepz*d;
        gC2TCState.x=g7xorgx;
        gC2TCState.z=g7xorgz;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        if(dimMode)
            tcgline.x/=2;
        tcgline.z=unit2Meter4Digit(tcgline.z);
        tcgline.y=gC2TCState.y;
        tcgline.y=unit2Meter4Digit(tcgline.y);
        *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

        DEBUGMSG(1,"G70 end\n");
    }

}
/***************************************************************************
*FUNCTION: g712TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g71 to send code to tcgbuffer
****************************************************************************
*/
U8 g712TCG(void)
{
    U8 err;
    S32 X,Z;
    static U8 cutonce=0;
    static U8 cutlast=0;
    PcompiledG7x g71=(PcompiledG7x)execGptr;
    if(compoundGcode==0)
    {
        if(!(g71->paramType&GI_IS_SETED))
        {
            err=g71SetVar();
        }else{
            err=g71GetVar();
            cutonce = 0;
            cutlast = 0;
	    }
        return err;
    }else{ //we are reentering
    	if(cutlast)
    	{
    		U8 i;
    		for(i=0;i<3;i++)
    		{
	            switch(execGptr->gtype)
	            {
	                case(0):
	                case(1):
	                    err=g7172Line();
	                    break;
	                case(2):
	                case(3):
	                    err=g7172Arc();
	                    break;
	                case(4):
	                    err=g7172Pause();
	                    break;
	                default:
	                    g7172CheckEnd();
	                    err=GERR_OK;
	                    break;
	            }
	            if(err!=GERR_OK)
	                return err;
	            if(compoundGcode==0)
	            {
	                break; //we had encounter end or g73
	            }
    		}
    	}
    	else
    	{
	        if(g7xstartx>g7xendx)
			{
	        	if(cutonce==0)
	        	{
	        		cutonce = 1;
		        	X = gC2TCState.x+di;
	        	}
	        	else
		        	X = gC2TCState.x+di+dk;
	        	if(X<=g7xendx)	//A->C
	        	{
	        		Z = g7xendz;
	        		g71linecross(X,Z);
	        	}
	        	else if((X>=g7xstartx)&&(g7xstartx1==g7xstartx))	//B
	        	{
	        		cutlast = 1;
	        		X = g7xstartx;
	        		Z = g7xstartz1;
	        		g71linecross(X,Z);

	        		g7xgrunPtr = 0;
					execGptr=G7xcompiledbuf;
	        	}
	        	else	//C->B
	        	{
	        		if( (X<g7xstartx1)&&(X>=g7xendx1) )
	        		{
	        			if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				Z = g711inecrossX(X);
			        		g71linecross(X,Z);
	        			}
	        			else
	        			{
	        				Z = g71arccrossX(X);
			        		g71linecross(X,Z);
	        			}
	        		}
	        		else if(X>=g7xstartx1)
	        		{
	        		    while((X>=g7xstartx1)&&(G7Xbufline1>1))
	        		    {
    	        			G7Xbufline1--;
    	        			//if(G7xcompiledbuf[G7Xbufline1].gtype>3)
    		        		//	G7Xbufline1--;
    	        			g7xendx1 = g7xstartx1;
    	        			g7xendz1 = g7xstartz1;
    	        			/*
    					    if(G7xcompiledbuf[G7Xbufline1-1].gtype>3)
    					    {
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-2].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-2].zw;
    					    }
    					    else
    					    {  */
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-1].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-1].zw;
    					    //}
					    }
					    if(X>=g7xstartx)	//B
        	        	{
        	        		cutlast = 1;
        	        		X = g7xstartx;
        	        		//Z = g7xstartz1;
        	        		Z = g711inecrossX(X);
        	        		if(Z>g7xstartz)
        	        		    g71linecross(X,Z);

        	        		g7xgrunPtr = 0;
        					execGptr=G7xcompiledbuf;
        	        	}
	        			else if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				Z = g711inecrossX(X);
			        		g71linecross(X,Z);
	        			}
	        			else
	        			{
	        				Z = g71arccrossX(X);
			        		g71linecross(X,Z);
	        			}
	        		}
	        	}
        	}
	        else if(g7xstartx<g7xendx)
	        {
	        	if(cutonce==0)
	        	{
	        		cutonce = 1;
		        	X = gC2TCState.x-di;
	        	}
	        	else
		        	X = gC2TCState.x-di-dk;
	        	if(X>=g7xendx)	//A->C
	        	{
	        		Z = g7xendz;
	        		g71linecross(X,Z);
	        	}
	        	else if((X<=g7xstartx)&&(g7xstartx1==g7xstartx))	//B
	        	{
	        		cutlast = 1;
	        		X = g7xstartx;
	        		Z = g7xstartz1;
	        		g71linecross(X,Z);

	        		g7xgrunPtr = 0;
					execGptr=G7xcompiledbuf;
	        	}
	        	else	//C->B
	        	{
	        		if( (X>g7xstartx1)&&(X<=g7xendx1) )
	        		{
	        			if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				Z = g711inecrossX(X);
			        		g71linecross(X,Z);
	        			}
	        			else
	        			{
	        				Z = g71arccrossX(X);
			        		g71linecross(X,Z);
	        			}
	        		}
	        		else if(X<=g7xstartx1)
	        		{
	        		    while((X<=g7xstartx1)&&(G7Xbufline1>1))
	        		    {
    	        			G7Xbufline1--;
    	        			//if(G7xcompiledbuf[G7Xbufline1].gtype>3)
    		        		//	G7Xbufline1--;
    	        			g7xendx1 = g7xstartx1;
    	        			g7xendz1 = g7xstartz1;
    	        			/*
    					    if(G7xcompiledbuf[G7Xbufline1-1].gtype>3)
    					    {
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-2].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-2].zw;
    					    }
    					    else
    					    {   */
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-1].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-1].zw;

    					    //}
					    }
					    if(X<=g7xstartx)	//B
        	        	{
        	        		cutlast = 1;
        	        		X = g7xstartx;
        	        		//Z = g7xstartz1;
        	        		Z = g711inecrossX(X);
        	        		if(Z<g7xstartz)
        	        		    g71linecross(X,Z);

        	        		g7xgrunPtr = 0;
        					execGptr=G7xcompiledbuf;
        	        	}else if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				Z = g711inecrossX(X);
			        		g71linecross(X,Z);
	        			}
	        			else
	        			{
	        				Z = g71arccrossX(X);
			        		g71linecross(X,Z);
	        			}
	        		}
	        	}
        	}
        }
    return GERR_OK;
   }
}
/***************************************************************************
*FUNCTION: g71SetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g71 vars to sys param
****************************************************************************
*/
U8 g71SetVar(void)
{
    PcompiledG7x g71=(PcompiledG7x)execGptr;
    //set params  of g71
    S32 val;
    if(g71->paramType&GXU_IS_SETED)
    {
        if(g71->paramType&GXU_IS_VALUE)
        {
            val=g71->u;//paramSetVal(191, g71->u);
        }else if(g71->paramType&GXU_IS_PARAM)
        {
            val=getVarValue(g71->u);//paramSetVal(191, globalVar[g71->u]);
        }
        val=unit2um(val);
        if((val<1)||(val>99999))
            val=1;
        if(val!=SYSparam[191].val)
            paramAutoSetVal(191, val);
    }
    if(g71->paramType&GR_IS_SETED)
    {
        if(g71->paramType&GR_IS_VALUE)
        {
            val=g71->r;//paramSetVal(192, g71->r);
        }else if(g71->paramType&GR_IS_PARAM)
        {
            val=getVarValue(g71->r);//paramSetVal(192, globalVar[g71->r]);
        }
        val=unit2um(val);
        if((val<1)||(val>99999))
            val=1;
        if(val!=SYSparam[192].val)
            paramAutoSetVal(192, val);
    }
    execGptr++;
    grunPtr++;
    DBMSG_GCODE("GCP g71 set vars\n");

    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g71GetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g71 vars to sys param
****************************************************************************
*/
U8 g71GetVar(void)
{
    U16 i;
    U32 err;
    PcompiledG7x g71=(PcompiledG7x)execGptr;
    if(gC2TCState.f==0)
        return GERR_NOFEED_G1;
    //a real g71, init all vars and start loop
    g7xRunPtr=grunPtr;
    g7xsrcLine=execGptr->srcline;
    di=anti_unit2um(DSPparam.sysdword[71]);
    dk=anti_unit2um(DSPparam.sysdword[72]);
    g7xorgx=gC2TCState.x;
    /*
    if(dimMode)
    {
        g7xorgx=g7xorgx/2;
    }*/
    g7xorgz=gC2TCState.z;
    if(g71->paramType&GXU_IS_VALUE)
    {
        du=g71->u;
    }else if(g71->paramType&GXU_IS_PARAM)
    {
        du=getVarValue(g71->u);
    }else{
        du=0;
    }
    if(dimMode)
        du=du/2;
    if(g71->paramType&GZW_IS_VALUE)
    {
        dw=g71->w;
    }else if(g71->paramType&GZW_IS_PARAM)
    {
        dw=getVarValue(g71->w);
    }else{
        dw=0;
    }
    /*
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==g71->p)
        {
            cpdStart=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG; //no where to jump to
    }
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==g71->q)
        {
            cpdEnd=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG;
    }
    //one source code may contain multi gcode
    //find the last one of it
    {
    U32 j,src;
    src=compiledGbuf[cpdEnd].srcline;
    for(j=cpdEnd+1;j<gCompiledCt;j++)
    {
        if(compiledGbuf[j].srcline==src)
        {
            cpdEnd=j;
        }else{
            break;
        }
    }
    }
    */
    err=g7xGetStartEnd(g71);
    if(err!=GERR_OK)
        return err;
    //here we add a g45 stop radium compensation if needed
    g7xAddCodeG4546(GCODE_45);
    err=g7xparambuffill();
    if(err!=GERR_OK)
        return err;
    //check if the fisrt line if g0 g1 and with only x
    if((G7xcompiledbuf[0].gtype>1)||
    //(G7xcompiledbuf[0].paramType&GZW_IS_SETED))
    (!(G7xcompiledbuf[0].paramType&GXU_IS_SETED)))
    {
       return GERR_G7XSTARTERR;
    }
    compoundGcode=GCODE_71;
    DBMSG_GCODE("GCP real g71 started\n");
    return GERR_OK;
}
/*****************************************************************
* FUNCTION: g7xparambuffill
* PARAMETER :void
* RETURN :void
* DESCRIPTION: fille the compount code to g7x buf used for next calculation
******************************************************************
*/
U8 g7xparambuffill()
{
    PcompiledG23 prevexecGptr;
    U32 prevgrunPtr=0;
    PcompiledG01 glineptr;
    TTCGline tcgline;
    U8 err=0;
	U16 i;
    S32 X,Z;
    G7Xbufline = 0;
    X = gC2TCState.x;
    if(dimMode)
    {
        X = X/2;
    }
    Z = gC2TCState.z;
    execG7Xptr = G7xcompiledbuf;
    prevexecGptr = execGptr;
    prevgrunPtr = grunPtr;
	for(grunPtr=cpdStart;grunPtr<=cpdEnd;grunPtr++)
	{
        execGptr = &(compiledGbuf[grunPtr]);
        if((execGptr->gtype&0xff)==0x71)
        {
            err = Macro_Before_G();
            if(err!=GERR_OK)
                return err;
        }
        if(G7Xbufline>=G7XBUF_MAX)
        {   // 这里应该给出缓冲溢出错误，日后修改
            return GERR_PARAM_VALERR;
        }
		G7xcompiledbuf[G7Xbufline] = compiledGbuf[grunPtr];
		execG7Xptr->srcline = G7Xbufline;
		//G7X里直线不能有倒角和角度
		if((execG7Xptr->gtype<=1)
		    &&((execG7Xptr->paramType&GA_IS_SETED)
		    ||(execG7Xptr->paramType&GC_IS_SETED)
		    ||(execG7Xptr->paramType&GR_IS_SETED)))
		{
		    return GERR_PARAM_VALERR;
		}
        if(execG7Xptr->gtype<=3)
        {
		    if(execG7Xptr->paramType&GXU_IS_VALUE)
		    {
			    if(dimMode)
			    {
			        execG7Xptr->xu = execG7Xptr->xu/2;
			    }
		        if(execG7Xptr->paramType&GXU_IS_INC)
		            execG7Xptr->xu+=X;
		    }else if(execG7Xptr->paramType&GXU_IS_PARAM)
		    {
			    if(dimMode)
			    {
			        X = X*2;
			    }
		        if(execG7Xptr->paramType&GXU_IS_INC)
		            execG7Xptr->xu=getVarValue(execG7Xptr->xu)+X;
		        else
		            execG7Xptr->xu=getVarValue(execG7Xptr->xu);
			    if(dimMode)
			    {
			        execG7Xptr->xu = execG7Xptr->xu/2;
			    }
		    }else{
		       execG7Xptr->xu = X;
		    }
	        X = execG7Xptr->xu;
		    execG7Xptr->xu+= du;

		    if(execG7Xptr->paramType&GZW_IS_VALUE)
		    {
		        if(execG7Xptr->paramType&GZW_IS_INC)
		            execG7Xptr->zw=execG7Xptr->zw+Z;
		    }else if(execG7Xptr->paramType&GZW_IS_PARAM)
		    {
		        if(execG7Xptr->paramType&GZW_IS_INC)
		            execG7Xptr->zw=getVarValue(execG7Xptr->zw)+Z;
		        else
		            execG7Xptr->zw=getVarValue(execG7Xptr->zw);
		    }else{
		        execG7Xptr->zw = Z;
		    }
	        Z = execG7Xptr->zw;
	        execG7Xptr->zw = Z+dw;

	        if(execG7Xptr->gtype==2||execG7Xptr->gtype==3)
	        {
			    if(execG7Xptr->paramType&GR_IS_VALUE) //r give out
			    {
			        execG7Xptr->i=0;
			        execG7Xptr->k=0;
			    }else if(execG7Xptr->paramType&GR_IS_PARAM)
			    { // this may be bugs check later
			        execG7Xptr->r=getVarValue(execG7Xptr->r);
			        execG7Xptr->i=0;
			        execG7Xptr->k=0;
			    }else{ // i ,j give out
			        execG7Xptr->r=0;
					if(execG7Xptr->paramType&GI_IS_PARAM)
			        {
			            execG7Xptr->i=getVarValue(execG7Xptr->i);
			        }
			        if(execG7Xptr->paramType&GK_IS_VALUE)
			        {}
			        else if(execG7Xptr->paramType&GK_IS_PARAM)
			        {
			            execG7Xptr->k=getVarValue(execG7Xptr->k);
			        }else{
			            execG7Xptr->k=0;
			        }
			    }
	        }

	        G7Xbufline++;
	        execG7Xptr++;
        }
        else if(execG7Xptr->gtype==4)
        { // 在粗加工中跳过暂停
	        G7Xbufline++;
	        execG7Xptr++;
        }
	}
    execGptr = prevexecGptr;
    grunPtr = prevgrunPtr;
	G7Xbufline--;
    execG7Xptr--;
    G7Xbufline1 = G7Xbufline;

    g7xstartx = G7xcompiledbuf[0].xu;		//point B
    g7xstartz = G7xcompiledbuf[0].zw;
    if(G7xcompiledbuf[G7Xbufline1].gtype>3)
    	G7Xbufline1--;
    g7xendx = G7xcompiledbuf[G7Xbufline1].xu;//point C
    g7xendz = G7xcompiledbuf[G7Xbufline1].zw;

    if(G7xcompiledbuf[G7Xbufline1-1].gtype>3)
    {
	    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-2].xu;
	    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-2].zw;
    }
    else
    {
	    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-1].xu;
	    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-1].zw;
    }
    g7xendx1 = g7xendx;
    g7xendz1 = g7xendz;

    g7xg00 = G7xcompiledbuf[0].gtype;
    grunPtr++;

    //point A->A'
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=0;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=g7xorgx;
    if(dimMode)
        tcgline.x/=2;
    tcgline.x+=du;
    //tcgline.x=g7xorgx+du;
    tcgline.z=g7xorgz+dw;
    gC2TCState.x = tcgline.x;
    gC2TCState.z = tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    tcgline.y=gC2TCState.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g71linecross
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cut cyc
****************************************************************************
*/
void g71linecross(S32 X,S32 Z)
{
	PcompiledG01 glineptr;
    TTCGline tcgline;

	//move forward 1
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=g7xg00;
    tcgline.sendCount=STDsendcount;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=X;
    tcgline.z=gC2TCState.z;
    gC2TCState.x = tcgline.x;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    tcgline.y=gC2TCState.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

	//move forward 2
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=1;
    tcgline.sendCount=STDsendcount;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=gC2TCState.x;
    tcgline.z=Z;
    gC2TCState.z= tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

	//move back 1
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=1;
    tcgline.sendCount=STDsendcount;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    /*
    if(g7xstartx>g7xendx)
    {
	    tcgline.x=gC2TCState.x-dk;
	    tcgline.z=gC2TCState.z-dk;
    }
    else
    {
	    tcgline.x=gC2TCState.x+dk;
	    tcgline.z=gC2TCState.z+dk;
    }
    */
    if(g7xstartx>g7xendx)
    {
	    tcgline.x=gC2TCState.x-dk;
    }else{
	    tcgline.x=gC2TCState.x+dk;
    }
    if(g7xstartz>g7xendz)
    {
	    tcgline.z=gC2TCState.z+dk;
	    if(tcgline.z>g7xstartz)
	        tcgline.z=g7xstartz;
    }else{
	    tcgline.z=gC2TCState.z-dk;
	    if(tcgline.z<g7xstartz)
	        tcgline.z=g7xstartz;
    }
    gC2TCState.x = tcgline.x;
    gC2TCState.z= tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

	//move back 2
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=0;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=gC2TCState.x;
    tcgline.z=g7xstartz;
    gC2TCState.z= tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
}
/***************************************************************************
*FUNCTION: g711inecrossX
*PARAMETER :void
*RETURN : void
*DESCRIPTION: count point of intersection -line
****************************************************************************
*/
S32 g711inecrossX(S32 X)
{
	//S32 x1,z1,x2,z2;
	//S32 Z;
	//F32 k;

    FLOAT64 x1,z1,x2,z2;
    FLOAT64 Z;
    FLOAT64 k;

	x1 = g7xstartx1;
	z1 = g7xstartz1;
	x2 = g7xendx1;
	z2 = g7xendz1;

	if(x1==x2)
		Z = z2;
	else
	{
		k = 1.0*(z1-z2)/(x1-x2);
		Z = z1-k*(x1-X);
	}
	return Z;
}
/***************************************************************************
*FUNCTION: g71arccrossX
*PARAMETER :void
*RETURN : void
*DESCRIPTION: count point of intersection -arc
****************************************************************************
*/
S32 g71arccrossX(S32 X)
{
	//S32 R,R2;
	//S32 Z1,Z2;
    FLOAT64 R,R2;
    FLOAT64 Z1,Z2;
	S32 Z;
    PRE_G_CODE calCode;
	R = G7xcompiledbuf[G7Xbufline1].r;
	calCode.StartPoint.Z=g7xstartz1;
	calCode.StartPoint.X=g7xstartx1;
	calCode.EndPoint.Z=g7xendz1;
	calCode.EndPoint.X=g7xendx1;
    calCode.CMD1=G7xcompiledbuf[G7Xbufline1].gtype;
	if(R!=0)
	{
		calCode.Radius=R;
		Cal_Cir_Center(&calCode);
		R2 = R*R;
	}
	else
	{
		calCode.CenterPoint.X=calCode.StartPoint.X+G7xcompiledbuf[G7Xbufline1].i;
	    calCode.CenterPoint.Z=calCode.StartPoint.Z+G7xcompiledbuf[G7Xbufline1].k;
	    R2 = (calCode.StartPoint.X-calCode.CenterPoint.X)*(calCode.StartPoint.X-calCode.CenterPoint.X)
	    		+(calCode.StartPoint.Z-calCode.CenterPoint.Z)*(calCode.StartPoint.Z-calCode.CenterPoint.Z);
	}
    //判断圆弧单调性
    if ((g7xstartx<g7xendx)&&(g7xstartz<g7xendz))//前刀，左上到右下
    {
        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.X<calCode.CenterPoint.X)||
                (calCode.EndPoint.Z>calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.Z<calCode.CenterPoint.Z)||
                (calCode.EndPoint.X>calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
    else if ((g7xstartx<g7xendx)&&(g7xstartz>g7xendz))//前刀，右上到左下
    {

        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.Z>calCode.CenterPoint.Z)||
                (calCode.EndPoint.X>calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.X<calCode.CenterPoint.X)||
                (calCode.EndPoint.Z<calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
    else if ((g7xstartx>g7xendx)&&(g7xstartz>g7xendz))//前刀，右下到左上
    {

        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.X>calCode.CenterPoint.X)||
                (calCode.EndPoint.Z<calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.Z>calCode.CenterPoint.Z)||
                (calCode.EndPoint.X<calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
    else if ((g7xstartx>g7xendx)&&(g7xstartz<g7xendz))//前刀，左下到右上
    {

        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.Z<calCode.CenterPoint.Z)||
                (calCode.EndPoint.X<calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.X>calCode.CenterPoint.X)||
                (calCode.EndPoint.Z>calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
	R=X-calCode.CenterPoint.X;
	R=sqrt( R2-R*R );
	Z1 = calCode.CenterPoint.Z+R;
	Z2 = calCode.CenterPoint.Z-R;
	if(g7xstartz1>=g7xendz1)
	{
		if(Z1>=g7xendz1&&Z1<=g7xstartz1)
			Z = Z1;
		else if(Z2>=g7xendz1&&Z2<=g7xstartz1)
			Z = Z2;
	    else{
	        //当出现 z1 z2都不在 弧线范围内的时候，表明浮点运算出了误差
	        //这个x 应该很接近起点或者终点。以X与端点的关系决定用那个点作Z值
	        if(abs(X-calCode.StartPoint.X)<=abs(X-calCode.EndPoint.X))
	        {
	            Z=calCode.StartPoint.Z;
	        }else{
	            Z=calCode.EndPoint.Z;
	        }
	        if(abs(Z-Z1)<abs(Z-Z2))
	            Z=Z1;
	        else
	            Z=Z2;
	    }
	}
	else
	{
		if(Z1>=g7xstartz1&&Z1<=g7xendz1)
			Z = Z1;
		else if(Z2>=g7xstartz1&&Z2<=g7xendz1)
			Z = Z2;
	    else{
	        //当出现 z1 z2都不在 弧线范围内的时候，表明浮点运算出了误差
	        //这个x 应该很接近起点或者终点。以X与端点的关系决定用那个点作Z值
	        if(abs(X-calCode.StartPoint.X)<=abs(X-calCode.EndPoint.X))
	        {
	            Z=calCode.StartPoint.Z;
	        }else{
	            Z=calCode.EndPoint.Z;
	        }
	        if(abs(Z-Z1)<abs(Z-Z2))
	            Z=Z1;
	        else
	            Z=Z2;
	    }
	}

	return Z;
}
/***************************************************************************
*FUNCTION: g722TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g71 to send code to tcgbuffer
****************************************************************************
*/
U8 g722TCG(void)
{
    U8 err;
    S32 X,Z;
    static U8 cutonce=0;
    static U8 cutlast=0;
    PcompiledG7x g72=(PcompiledG7x)execGptr;
    if(compoundGcode==0)
    {
        if(!(g72->paramType&GI_IS_SETED))
        {
            err=g72SetVar();
        }else{
            err=g72GetVar();
            cutonce = 0;
            cutlast = 0;
	    }
        return err;
    }else{ //we are reentering
    	if(cutlast)
    	{
    		U8 i;
    		for(i=0;i<3;i++)
    		{
	            switch(execGptr->gtype)
	            {
	                case(0):
	                case(1):
	                    err=g7172Line();
	                    break;
	                case(2):
	                case(3):
	                    err=g7172Arc();
	                    break;
	                case(4):
	                    err=g7172Pause();
	                    break;
	                default:
	                    g7172CheckEnd();
	                    err=GERR_OK;
	                    break;
	            }
	            if(err!=GERR_OK)
	                return err;
	            if(compoundGcode==0)
	            {
	                break; //we had encounter end or g73
	            }
    		}
    	}
    	else
    	{
	        if(g7xstartz>g7xendz)
			{
	        	if(cutonce==0)
	        	{
	        		cutonce = 1;
		        	Z = gC2TCState.z+di;
	        	}
	        	else
		        	Z = gC2TCState.z+di+dk;
	        	if(Z<=g7xendz)	//A->C
	        	{
	        		X = g7xendx;
	        		g72linecross(X,Z);
	        	}
	        	else if((Z>=g7xstartz)&&(g7xstartz1==g7xstartz))	//B
	        	{
	        		cutlast = 1;
	        		X = g7xstartx1;
	        		Z = g7xstartz;
	        		g72linecross(X,Z);

	        		g7xgrunPtr = 0;
					execGptr=G7xcompiledbuf;
	        	}
	        	else	//C->B
	        	{
	        		if( (Z<=g7xstartz1)&&(Z>g7xendz1) )
	        		{
	        			if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				X = g721inecrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        			else
	        			{
	        				X = g72arccrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        		}
	        		else if(Z>g7xstartz1)
	        		{
	        		    while((Z>g7xstartz1)&&(G7Xbufline1>1))
	        		    {
    	        			G7Xbufline1--;
    	        			//if(G7xcompiledbuf[G7Xbufline1].gtype>3)
    		        		//	G7Xbufline1--;
    	        			g7xendx1 = g7xstartx1;
    	        			g7xendz1 = g7xstartz1;
    	        			/*
    					    if(G7xcompiledbuf[G7Xbufline1-1].gtype>3)
    					    {
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-2].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-2].zw;
    					    }
    					    else
    					    {     */
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-1].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-1].zw;
    					    //}
					    }
					    if(Z>=g7xstartz)	//B
        	        	{
        	        		cutlast = 1;
        	        		//X = g7xstartx1;
        	        		Z = g7xstartz;
        	        		X = g721inecrossZ(Z);
        	                if(X>g7xstartx)
        	        		    g72linecross(X,Z);

        	        		g7xgrunPtr = 0;
        					execGptr=G7xcompiledbuf;
        	        	}else if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				X = g721inecrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        			else
	        			{
	        				X = g72arccrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        		}
	        	}
        	}
	        else if(g7xstartz<g7xendz)
	        {
	        	if(cutonce==0)
	        	{
	        		cutonce = 1;
		        	Z = gC2TCState.z-di;
	        	}
	        	else
		        	Z = gC2TCState.z-di-dk;
	        	if(Z>=g7xendz)	//A->C
	        	{
	        		X = g7xendx;
	        		g72linecross(X,Z);
	        	}
	        	else if((Z<=g7xstartz)&&(g7xstartz1==g7xstartz))	//B
	        	{
	        		cutlast = 1;
	        		X = g7xstartx1;
	        		Z = g7xstartz;
	        		g72linecross(X,Z);

	        		g7xgrunPtr = 0;
					execGptr=G7xcompiledbuf;
	        	}
	        	else	//C->B
	        	{
	        		if( (Z>g7xstartz1)&&(Z<=g7xendz1) )
	        		{
	        			if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				X = g721inecrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        			else
	        			{
	        				X = g72arccrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        		}
	        		else if(Z<=g7xstartz1)
	        		{
	        		    while((Z<=g7xstartz1)&&(G7Xbufline1>1))
	        		    {
    	        			G7Xbufline1--;
    	        			//if(G7xcompiledbuf[G7Xbufline1].gtype>3)
    		        		//	G7Xbufline1--;
    	        			g7xendx1 = g7xstartx1;
    	        			g7xendz1 = g7xstartz1;
    	        			/*
    					    if(G7xcompiledbuf[G7Xbufline1-1].gtype>3)
    					    {
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-2].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-2].zw;
    					    }
    					    else
    					    {   */
    						    g7xstartx1 = G7xcompiledbuf[G7Xbufline1-1].xu;
    						    g7xstartz1 = G7xcompiledbuf[G7Xbufline1-1].zw;
    					    //}
					    }
					    if(Z<=g7xstartz)	//B
        	        	{
        	        		cutlast = 1;
        	        		//X = g7xstartx1;
        	        		Z = g7xstartz;
        	        		X = g721inecrossZ(Z);
        	                if(X<g7xstartx)
        	        		    g72linecross(X,Z);

        	        		g7xgrunPtr = 0;
        					execGptr=G7xcompiledbuf;
        	        	}
	        			else if(G7xcompiledbuf[G7Xbufline1].gtype<=1)
	        			{
	        				X = g721inecrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        			else
	        			{
	        				X = g72arccrossZ(Z);
			        		g72linecross(X,Z);
	        			}
	        		}
	        	}
        	}
        }
    return GERR_OK;
   }
}
/***************************************************************************
*FUNCTION: g72SetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g72 vars to sys param
****************************************************************************
*/
U8 g72SetVar(void)
{
    PcompiledG7x g72=(PcompiledG7x)execGptr;
    //set params  of g72
    S32 val;
    if(g72->paramType&GZW_IS_SETED)
    {
        if(g72->paramType&GZW_IS_VALUE)
        {
            val=g72->w;//paramSetVal(191, g72->w);
        }else if(g72->paramType&GZW_IS_PARAM)
        {
            val=getVarValue(g72->w);//paramSetVal(191, globalVar[g72->w]);
        }
        val=unit2um(val);
        if((val<1)||(val>99999))
            val=1;
        if(val!=SYSparam[191].val)
            paramAutoSetVal(191, val);
    }
    if(g72->paramType&GR_IS_SETED)
    {
        if(g72->paramType&GR_IS_VALUE)
        {
            val=g72->r;//paramSetVal(192, g72->r);
        }else if(g72->paramType&GR_IS_PARAM)
        {
            val=getVarValue(g72->r);//paramSetVal(192, globalVar[g72->r]);
        }
        val=unit2um(val);
        if((val<1)||(val>99999))
            val=1;
        if(val!=SYSparam[192].val)
            paramAutoSetVal(192, val);
    }
    execGptr++;
    grunPtr++;
    DBMSG_GCODE("GCP g72 set vars\n");

    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g72GetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g72 vars to sys param
****************************************************************************
*/
U8 g72GetVar(void)
{
    U16 i;
    U32 err;
    PcompiledG7x g72=(PcompiledG7x)execGptr;
    if(gC2TCState.f==0)
        return GERR_NOFEED_G1;
    //a real g72, init all vars and start loop
    g7xRunPtr=grunPtr;
    g7xsrcLine=execGptr->srcline;
    di=anti_unit2um(DSPparam.sysdword[71]);
    dk=anti_unit2um(DSPparam.sysdword[72]);
    g7xorgx=gC2TCState.x;
    /*
    if(dimMode)
    {
        g7xorgx=g7xorgx/2;
    }*/
    g7xorgz=gC2TCState.z;
    if(g72->paramType&GXU_IS_VALUE)
    {
        du=g72->u;
    }else if(g72->paramType&GXU_IS_PARAM)
    {
        du=getVarValue(g72->u);
    }else{
        du=0;
    }
    if(dimMode)
        du=du/2;
    if(g72->paramType&GZW_IS_VALUE)
    {
        dw=g72->w;
    }else if(g72->paramType&GZW_IS_PARAM)
    {
        dw=getVarValue(g72->w);
    }else{
        dw=0;
    }
    /*
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==g72->p)
        {
            cpdStart=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG; //no where to jump to
    }
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==g72->q)
        {
            cpdEnd=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG;
    }
    //one source code may contain multi gcode
    //find the last one of it
    {
    U32 j,src;
    src=compiledGbuf[cpdEnd].srcline;
    for(j=cpdEnd+1;j<gCompiledCt;j++)
    {
        if(compiledGbuf[j].srcline==src)
        {
            cpdEnd=j;
        }else{
            break;
        }
    }
    }
    */
    err=g7xGetStartEnd(g72);
    if(err!=GERR_OK)
        return err;
    //here we add a g45 stop radium compensation if needed
    g7xAddCodeG4546(GCODE_45);
    err=g7xparambuffill();
    if(err!=GERR_OK)
        return err;
    //check if the fisrt line if g0 g1 and with only x
    if((G7xcompiledbuf[0].gtype>1)||
    (!(G7xcompiledbuf[0].paramType&GZW_IS_SETED)))
    {
       return GERR_G7XSTARTERR;
    }
    compoundGcode=GCODE_72;
    DBMSG_GCODE("GCP real g72 started\n");
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g712inecross
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cut cyc
****************************************************************************
*/
void g72linecross(S32 X,S32 Z)
{
	PcompiledG01 glineptr;
    TTCGline tcgline;

	//move forward 1
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=g7xg00;
    tcgline.sendCount=STDsendcount;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=gC2TCState.x;
    tcgline.z=Z;
    gC2TCState.z = tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    tcgline.y=gC2TCState.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

	//move forward 2
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=1;
    tcgline.sendCount=STDsendcount;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=X;
    tcgline.z=gC2TCState.z;
    gC2TCState.x= tcgline.x;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

	//move back 1
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=1;
    tcgline.sendCount=STDsendcount;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    /*
    if(g7xstartz>g7xendz)
    {
	    tcgline.x=gC2TCState.x-dk;
	    tcgline.z=gC2TCState.z-dk;
    }
    else
    {
	    tcgline.x=gC2TCState.x+dk;
	    tcgline.z=gC2TCState.z+dk;
    }
*/
    if(g7xstartx>g7xendx)
    {
	    tcgline.x=gC2TCState.x+dk;
	    if(tcgline.x>g7xstartx)
	        tcgline.x=g7xstartx;
    }else{
	    tcgline.x=gC2TCState.x-dk;
	    if(tcgline.x<g7xstartx)
	        tcgline.x=g7xstartx;
    }
    if(g7xstartz>g7xendz)
    {
	    tcgline.z=gC2TCState.z-dk;
    }else{
	    tcgline.z=gC2TCState.z+dk;
    }

    gC2TCState.x = tcgline.x;
    gC2TCState.z= tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

	//move back 2
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=0;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=g7xstartx;
    tcgline.z=gC2TCState.z;
    gC2TCState.x= tcgline.x;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
}
/***************************************************************************
*FUNCTION: g721inecrossZ
*PARAMETER :void
*RETURN : void
*DESCRIPTION: count point of intersection -line
****************************************************************************
*/
S32 g721inecrossZ(S32 Z)
{
	//S32 x1,z1,x2,z2;
	//S32 X;
	//F32 k;
    FLOAT64 x1,z1,x2,z2;
    FLOAT64 X;
    FLOAT64 k;
	x1 = g7xstartx1;
	z1 = g7xstartz1;
	x2 = g7xendx1;
	z2 = g7xendz1;

	if(z1==z2)
		X = x2;
	else
	{
		k = 1.0*(x1-x2)/(z1-z2);
		X = x1-k*(z1-Z);
	}
	return X;
}
/***************************************************************************
*FUNCTION: g72arccrossZ
*PARAMETER :void
*RETURN : void
*DESCRIPTION: count point of intersection -arc
****************************************************************************
*/
S32 g72arccrossZ(S32 Z)
{
	//S32 R,R2;
	//S32 X1,X2,
    FLOAT64 R,R2;
    FLOAT64 X1,X2;
	S32 X;
    PRE_G_CODE calCode;
	R = G7xcompiledbuf[G7Xbufline1].r;
	calCode.StartPoint.Z=g7xstartz1;
	calCode.StartPoint.X=g7xstartx1;
	calCode.EndPoint.Z=g7xendz1;
	calCode.EndPoint.X=g7xendx1;
    calCode.CMD1=G7xcompiledbuf[G7Xbufline1].gtype;
	if(R!=0)
	{
		calCode.Radius=R;
		Cal_Cir_Center(&calCode);
		R2 = R*R;
	}
	else
	{
		calCode.CenterPoint.X=calCode.StartPoint.X+G7xcompiledbuf[G7Xbufline1].i;
	    calCode.CenterPoint.Z=calCode.StartPoint.Z+G7xcompiledbuf[G7Xbufline1].k;
	    R2 = (calCode.StartPoint.X-calCode.CenterPoint.X)*(calCode.StartPoint.X-calCode.CenterPoint.X)
	    		+(calCode.StartPoint.Z-calCode.CenterPoint.Z)*(calCode.StartPoint.Z-calCode.CenterPoint.Z);
	}
    if ((g7xstartx<g7xendx)&&(g7xstartz<g7xendz))//前刀，左上到右下
    {
        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.X<calCode.CenterPoint.X)||
                (calCode.EndPoint.Z>calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.Z<calCode.CenterPoint.Z)||
                (calCode.EndPoint.X>calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
    else if ((g7xstartx<g7xendx)&&(g7xstartz>g7xendz))//前刀，右上到左下
    {

        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.Z>calCode.CenterPoint.Z)||
                (calCode.EndPoint.X>calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.X<calCode.CenterPoint.X)||
                (calCode.EndPoint.Z<calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
    else if ((g7xstartx>g7xendx)&&(g7xstartz>g7xendz))//前刀，右下到左上
    {

        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.X>calCode.CenterPoint.X)||
                (calCode.EndPoint.Z<calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.Z>calCode.CenterPoint.Z)||
                (calCode.EndPoint.X<calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
    else if ((g7xstartx>g7xendx)&&(g7xstartz<g7xendz))//前刀，左下到右上
    {

        if (calCode.CMD1 == 2)//前刀，逆弧
        {
            if ((calCode.StartPoint.Z<calCode.CenterPoint.Z)||
                (calCode.EndPoint.X<calCode.CenterPoint.X))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }

        }
        else if (calCode.CMD1 == 3)//前刀，顺弧
        {

            if ((calCode.StartPoint.X>calCode.CenterPoint.X)||
                (calCode.EndPoint.Z>calCode.CenterPoint.Z))
            {
                ALARM_GRP1|=ALM_GRP1_G71G72_ARC;
            }
        }
    }
	R=Z-calCode.CenterPoint.Z;
	R=sqrt(R2-R*R);
	X1 = calCode.CenterPoint.X+R;//sqrt( R2-(Z-calCode.CenterPoint.Z)*(Z-calCode.CenterPoint.Z) );
	X2 = calCode.CenterPoint.X-R;//sqrt( R2-(Z-calCode.CenterPoint.Z)*(Z-calCode.CenterPoint.Z) );
	if(g7xstartx1>=g7xendx1)
	{
		if(X1>=g7xendx1&&X1<=g7xstartx1)
			X = X1;
		else if(X2>=g7xendx1&&X2<=g7xstartx1)
			X = X2;
	    else{
	        //当出现 X1 X2都不在 弧线范围内的时候，表明浮点运算出了误差
	        //这个Z 应该很接近起点或者终点。以Z与端点的关系决定用那个点作X值
	        if(abs(Z-calCode.StartPoint.Z)<=abs(Z-calCode.EndPoint.Z))
	        {
	            X=calCode.StartPoint.X;
	        }else{
	            X=calCode.EndPoint.X;
	        }
	        if(abs(X-X1)<abs(X-X2))
	            X=X1;
	        else
	            X=X2;
	    }
	}
	else
	{
		if(X1>=g7xstartx1&&X1<=g7xendx1)
			X = X1;
		else if(X2>=g7xstartx1&&X2<=g7xendx1)
			X = X2;
	    else{
	        //当出现 X1 X2都不在 弧线范围内的时候，表明浮点运算出了误差
	        //这个Z 应该很接近起点或者终点。以Z与端点的关系决定用那个点作X值
	        if(abs(Z-calCode.StartPoint.Z)<=abs(Z-calCode.EndPoint.Z))
	        {
	            X=calCode.StartPoint.X;
	        }else{
	            X=calCode.EndPoint.X;
	        }
	        if(abs(X-X1)<abs(X-X2))
	            X=X1;
	        else
	            X=X2;
	    }
	}

	return X;
}
/***************************************************************************
*FUNCTION: g7172Line
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec gline command in g71
****************************************************************************
*/

U8 g7172Line(void)
{
    TTCGline tcgline;
    tcgline.gnum=execGptr->gtype;//execGptr->gtype&0xff;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcLine=execGptr->srcline;
    tcgline.srcCode=g7xRunPtr;//grunPtr;
    tcgline.srcLine=g7xsrcLine;
    tcgline.x=execGptr->xu;
    gC2TCState.x=tcgline.x;
    tcgline.z=execGptr->zw;
    gC2TCState.z=tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    tcgline.z=unit2Meter4Digit(tcgline.z);
    tcgline.y=gC2TCState.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    g7172CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g7172Arc
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec garc comand in g71
****************************************************************************
*/

U8 g7172Arc(void)
{
    TTCGarc tcgarc;

    tcgarc.gnum=execGptr->gtype;//execGptr->gtype&0xff;
    tcgarc.sendCount=STDsendcount++;
    tcgarc.srcLine=execGptr->srcline;
    tcgarc.srcCode=g7xRunPtr;//grunPtr;
    tcgarc.srcLine=g7xsrcLine;
    tcgarc.x=execGptr->xu;
    gC2TCState.x=tcgarc.x;
    tcgarc.z=execGptr->zw;
    gC2TCState.z=tcgarc.z;
    tcgarc.x=unit2Meter4Digit(tcgarc.x);
    tcgarc.z=unit2Meter4Digit(tcgarc.z);

    tcgarc.r=execGptr->r;
    tcgarc.i=execGptr->i;
    tcgarc.k=execGptr->k;
    tcgarc.r=unit2Meter4Digit(tcgarc.r);
    tcgarc.i=unit2Meter4Digit(tcgarc.i);
    tcgarc.k=unit2Meter4Digit(tcgarc.k);
    *((PTCGarc)&TCGbuf[TCGwptr])=tcgarc;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    g7172CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g71PAUSE
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g04 in g71
****************************************************************************
*/

U8 g7172Pause(void)
{
    PcompiledFST fstptr;
    TTCGfst tcg04;
    tcg04.gnum=GCODE_04;
    fstptr=(PcompiledFST)execGptr;

    tcg04.value=fstptr->value;
    tcg04.sendCount=STDsendcount++;
    tcg04.srcLine=fstptr->srcline;
    tcg04.srcCode=g7xRunPtr;//grunPtr;
    tcg04.srcLine=g7xsrcLine;
    *((PTCGfst)&TCGbuf[TCGwptr])=tcg04;
    DBMSG_GCODE("GCP G04: val %ld, sendcount %ld\n",tcg04.value,tcg04.sendCount);
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    g7172CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g7172CheckEnd
*PARAMETER :void
*RETURN : void
*DESCRIPTION: check if a g71 isend, set corr
****************************************************************************
*/
void g7172CheckEnd(void)
{
    TTCGline tcgline;

    if(g7xgrunPtr==G7Xbufline)
    {
        compoundGcode=0;
        grunPtr = cpdEnd+1;
	    execGptr=&compiledGbuf[cpdEnd+1];
        //add a g0 to go to loop start point
        tcgline.gnum=GCODE_00;
        tcgline.sendCount=STDsendcount++;
        tcgline.srcLine=execGptr->srcline;
        tcgline.srcCode=g7xRunPtr;//grunPtr;
        gC2TCState.x=g7xorgx;
        gC2TCState.z=g7xorgz;
		tcgline.x=g7xorgx;
        tcgline.z=g7xorgz;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        if(dimMode)
            tcgline.x/=2;
        tcgline.z=unit2Meter4Digit(tcgline.z);
        tcgline.y=gC2TCState.y;
        tcgline.y=unit2Meter4Digit(tcgline.y);
        *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
        DEBUGMSG(1,"G712 end\n");
        //here we add a g46 to recover if we are in g41 g42 mode,
        g7xAddCodeG4546(GCODE_46);
    }else{
        g7xgrunPtr++;
        execGptr++;
    }
}
/***************************************************************************
*FUNCTION: g732TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g73 to send code to tcgbuffer
****************************************************************************
*/
U8 g732TCG(void)
{
    U8 err;
    PcompiledG7x g73=(PcompiledG7x)execGptr;
    if(compoundGcode==0)
    {
        if(!(g73->paramType&GI_IS_SETED))
        {
            err=g73SetVar();
        }else{
            err=g73GetVar();
        }
    }else{ //we are reentering
        U32 i;
        for(i=0;i<3;i++)
        {
            //if((execGptr->srcJump==FALSE)||(DSPparam.sysbyte[81]==FALSE))
            if((execGptr->srcJump==FALSE)||(jumpSegFlag==FALSE))
            {
                if((execGptr->gtype&0xff)==0x71)
                {
                    err = Macro_Before_G();
                    if(err!=GERR_OK)
                        return err;
                }
                switch(execGptr->gtype)
                {
                    case(0):
                    case(1):
                        err=g73Line();
                        break;
                    case(2):
                    case(3):
                        err=g73Arc();
                        break;
                    case(4):
                        err=g73Pause();
                        break;
                    case (GCODE_M03):
                    case (GCODE_M04):
                    case (GCODE_M05):
                    case (GCODE_M08):
                    case (GCODE_M09):
                        //err=g73M();
                        //break;
                    default:
                        //omit
                        g73CheckEnd();
                        err=GERR_OK;
                        break;
                }
            }else
            {
                g73CheckEnd();
                err=GERR_OK;
            }
            if(err!=GERR_OK)
                return err;
            if(compoundGcode==0)
            {
                break; //we had encounter end or g73
            }
        }
    }
    return err;
}
/***************************************************************************
*FUNCTION: g73SetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g73 vars to sys param
****************************************************************************
*/
U8 g73SetVar(void)
{
    PcompiledG7x g73=(PcompiledG7x)execGptr;
    //set params  of g73
    S32 val;
    if(g73->paramType&GXU_IS_SETED)
    {
        if(g73->paramType&GXU_IS_VALUE)
        {
            val=g73->u;//paramSetVal(193, g73->u);
        }else if(g73->paramType&GXU_IS_PARAM)
        {
            val=getVarValue(g73->u);//paramSetVal(193, globalVar[g73->u]);
        }
        val=unit2um(val);
        if(val!=SYSparam[193].val)
            paramAutoSetVal(193, val);
    }
    if(g73->paramType&GZW_IS_SETED)
    {
        if(g73->paramType&GZW_IS_VALUE)
        {
            val=g73->w;//paramSetVal(194, g73->w);
        }else if(g73->paramType&GZW_IS_PARAM)
        {
            val=getVarValue(g73->w);//paramSetVal(194, globalVar[g73->w]);
        }
        val=unit2um(val);
        if(val!=SYSparam[194].val)
            paramAutoSetVal(194, val);
    }
    if(g73->paramType&GR_IS_SETED)
    {
        if(g73->paramType&GR_IS_VALUE)
        {
            val=g73->r;//paramSetVal(195, g73->r);
        }else if(g73->paramType&GR_IS_PARAM)
        {
            val=getVarValuePQ(g73->r);//paramSetVal(195, globalVar[g73->r]);
        }
        if(val!=SYSparam[195].val)
            paramAutoSetVal(195, val);
    }
    execGptr++;
    grunPtr++;
    DBMSG_GCODE("GCP g73 set vars\n");

    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g73GetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g73 vars to sys param
****************************************************************************
*/

U8 g73GetVar(void)
{
    U16 i;
    U32 err;
    PcompiledG23 gptr;
    TTCGline tcgline;
    PcompiledG7x g73=(PcompiledG7x)execGptr;
    gptr=execGptr;
    if(gC2TCState.f==0)
        return GERR_NOFEED_G1;
    //a real g73, init all vars and start loop
    di=anti_unit2um(DSPparam.sysdword[73]);
    //di=unit2Meter4Digit(di);
    dk=anti_unit2um(DSPparam.sysdword[74]);
    //dk=unit2Meter4Digit(dk);
    d =DSPparam.sysdword[75];
    g7xorgx=gC2TCState.x;
    /*
    g7xorgx=unit2Meter4Digit(g7xorgx);
    if(dimMode)
    {
        g7xorgx=g7xorgx/2;
    }*/
    if(dimMode)
    {
        di*=2;
    }
    g7xorgz=gC2TCState.z;
    //g7xorgz=unit2Meter4Digit(g7xorgz);
    if(d<=1)
    {
        stepx=di;
        stepz=dk;
        d=0;
    }else{
        d=d-1;
        stepx=di/d;//(d-1);
        stepz=dk/d;//(d-1);//(d-1);
    }
    if(g73->paramType&GXU_IS_VALUE)
    {
        du=g73->u;
    }else if(g73->paramType&GXU_IS_PARAM)
    {
        du=getVarValue(g73->u);
    }else{
        du=0;
    }
    /*
    du=unit2Meter4Digit(du);
    if(dimMode)
    {
        du=du/2;
    }*/
    if(g73->paramType&GZW_IS_VALUE)
    {
        dw=g73->w;
    }else if(g73->paramType&GZW_IS_PARAM)
    {
        dw=getVarValue(g73->w);
    }else{
        dw=0;
    }
    //dw=unit2Meter4Digit(dw);
    /*
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==g73->p)
        {
            cpdStart=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG; //no where to jump to
    }
    for(i=0;i<jumpPointCount;i++)
    {
        if(jumpPointList[i].tag==g73->q)
        {
            cpdEnd=jumpPointList[i].address;
            break;
        }
    }
    if(i==jumpPointCount)
    {
        return GERR_NO_TAG;
    }
    //one source code may contain multi gcode
    //find the last one of it
    {
    U32 j,src;
    src=compiledGbuf[cpdEnd].srcline;
    for(j=cpdEnd+1;j<gCompiledCt;j++)
    {
        if(compiledGbuf[j].srcline==src)
        {
            cpdEnd=j;
        }else{
            break;
        }
    }
    }
    */
    err=g7xGetStartEnd(g73);
    if(err!=GERR_OK)
        return err;
    compoundGcode=GCODE_73;
    cpdGptr=execGptr;
    cpdNextPtr=cpdEnd+1;
    grunPtr=cpdStart;
    execGptr=&compiledGbuf[grunPtr];
    //cpdGptr=&compiledGbuf[cpdStart];
    //cpdPtr=cpdStart;
    //add a start setp

    DBMSG_GCODE("GCP real g73 started\n");
    //here we add a g45 stop radium compensation if needed
    g7xAddCodeG4546(GCODE_45);

    //add a g0 to go to loop start point
    tcgline.gnum=GCODE_00;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcLine=gptr->srcline;
    tcgline.srcCode=grunPtr;
    tcgline.x=g7xorgx+du+di;//+stepx*d;
    tcgline.z=g7xorgz+dw+dk;//+stepz*d;
    //gC2TCState.x=tcgline.x;
    //gC2TCState.z=tcgline.z;
    tcgline.x=unit2Meter4Digit(tcgline.x);
    if(dimMode)
        tcgline.x/=2;
    tcgline.z=unit2Meter4Digit(tcgline.z);
    tcgline.y=gC2TCState.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);


    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g73Line
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec gline command in g73
****************************************************************************
*/

U8 g73Line(void)
{
    PcompiledG01 glineptr;
    TTCGline tcgline;
    glineptr=(PcompiledG01)execGptr;
    tcgline.gnum=glineptr->gtype;//execGptr->gtype&0xff;
    //tcgline.sendCount=glineptr->srcline;
    tcgline.sendCount=STDsendcount++;
    tcgline.srcLine=glineptr->srcline;
    tcgline.srcCode=grunPtr;
    if(glineptr->paramType&GXU_IS_VALUE)
    {
        if(glineptr->paramType&GXU_IS_INC)
            tcgline.x=glineptr->xu+gC2TCState.x;
        else
            tcgline.x=glineptr->xu;
        //compiledX=tcgline.x;
        gC2TCState.x=tcgline.x;
    }else if(glineptr->paramType&GXU_IS_PARAM)
    {
        if(glineptr->paramType&GXU_IS_INC)
            tcgline.x=getVarValue(glineptr->xu)+gC2TCState.x;
        else
            tcgline.x=getVarValue(glineptr->xu);
        gC2TCState.x=tcgline.x;
    }else{
        tcgline.x=gC2TCState.x;
    }
    tcgline.x=tcgline.x+du+stepx*d;
    //if(DSPparam.sysbyte[79]==1)  //
    //if in dim mode x should /2
    tcgline.x=unit2Meter4Digit(tcgline.x);
    if(dimMode)
    {
        tcgline.x=tcgline.x/2;
    }
    if(glineptr->paramType&GZW_IS_VALUE)
    {
        if(glineptr->paramType&GZW_IS_INC)
            tcgline.z=glineptr->zw+gC2TCState.z;
        else
            tcgline.z=glineptr->zw;
        //compiledZ=tcgline.z;
        gC2TCState.z=tcgline.z;
    }else if(glineptr->paramType&GZW_IS_PARAM)
    {
        if(glineptr->paramType&GZW_IS_INC)
            tcgline.z=getVarValue(glineptr->zw)+gC2TCState.z;
        else
            tcgline.z=getVarValue(glineptr->zw);
        gC2TCState.z=tcgline.z;
    }else{
        tcgline.z=gC2TCState.z;
    }
    tcgline.z=tcgline.z+dw+stepz*d;
    tcgline.z=unit2Meter4Digit(tcgline.z);
    tcgline.y=gC2TCState.y;
    tcgline.y=unit2Meter4Digit(tcgline.y);
    *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
    g73CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g73Arc
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec garc comand in g73
****************************************************************************
*/

U8 g73Arc(void)
{
    PcompiledG23 garcptr;
    TTCGarc tcgarc;
    S32 sx,sz;
    sx=gC2TCState.x;
    sz=gC2TCState.z;
    garcptr=execGptr;
    tcgarc.gnum=garcptr->gtype;//execGptr->gtype&0xff;
    //tcgarc.sendCount=garcptr->srcline;

    tcgarc.srcLine=garcptr->srcline;
    tcgarc.srcCode=grunPtr;
    if(garcptr->paramType&GXU_IS_VALUE)
    {
        if(garcptr->paramType&GXU_IS_INC)
            tcgarc.x=garcptr->xu+gC2TCState.x;
        else
            tcgarc.x=garcptr->xu;
        //compiledX=tcgarc.x;
        gC2TCState.x=tcgarc.x;
    }else if(garcptr->paramType&GXU_IS_PARAM)
    {
        if(garcptr->paramType&GXU_IS_INC)
            tcgarc.x=getVarValue(garcptr->xu)+gC2TCState.x;
        else
            tcgarc.x=getVarValue(garcptr->xu);
        gC2TCState.x=tcgarc.x;
    }else{
        tcgarc.x=gC2TCState.x;
    }
    tcgarc.x=tcgarc.x+du+stepx*d;
    //if in dim mode x should /2
    tcgarc.x=unit2Meter4Digit(tcgarc.x);
    if(dimMode)
    {
        tcgarc.x=tcgarc.x/2;

    }
    if(garcptr->paramType&GZW_IS_VALUE)
    {
        if(garcptr->paramType&GZW_IS_INC)
            tcgarc.z=garcptr->zw+gC2TCState.z;
        else
            tcgarc.z=garcptr->zw;
        gC2TCState.z=tcgarc.z;
    }else if(garcptr->paramType&GZW_IS_PARAM)
    {
        if(garcptr->paramType&GZW_IS_INC)
            tcgarc.z=getVarValue(garcptr->zw)+gC2TCState.z;
        else
            tcgarc.z=getVarValue(garcptr->zw);
        gC2TCState.z=tcgarc.z;
    }else{
        tcgarc.z=gC2TCState.z;
    }
    tcgarc.z=tcgarc.z+dw+stepz*d;
    tcgarc.z=unit2Meter4Digit(tcgarc.z);
    if(garcptr->paramType&GR_IS_VALUE) //r give out
    {
        tcgarc.r=garcptr->r;
        tcgarc.i=0;
        tcgarc.k=0;
        tcgarc.r=unit2Meter4Digit(tcgarc.r);
    }else if(garcptr->paramType&GR_IS_PARAM)
    {
        tcgarc.r=getVarValue(garcptr->r);
        tcgarc.i=0;
        tcgarc.k=0;
        tcgarc.r=unit2Meter4Digit(tcgarc.r);
    }else{ // i ,j give out
        tcgarc.r=0;
        if(garcptr->paramType&GI_IS_VALUE)
        {
            tcgarc.i=garcptr->i;
        }else if(garcptr->paramType&GI_IS_PARAM)
        {
            tcgarc.i=getVarValue(garcptr->i);
        }else{
            tcgarc.i=0;
        }
        if(garcptr->paramType&GK_IS_VALUE)
        {
             tcgarc.k=garcptr->k;
        }else if(garcptr->paramType&GK_IS_PARAM)
        {
            tcgarc.k=getVarValue(garcptr->k);
        }else{
            tcgarc.k=0;
        }
        tcgarc.i=unit2Meter4Digit(tcgarc.i);
        tcgarc.k=unit2Meter4Digit(tcgarc.k);
    }



    //check arc
    sx=unit2Meter4Digit(sx+du+stepx*d);
    if(dimMode)
    {
        sx=sx/2;
    }
    sz=unit2Meter4Digit(sz+dw+stepz*d);
    if(tcgarc.r==0)
    {
        double i=tcgarc.i;
        double k=tcgarc.k;
        double di=tcgarc.x-(sx+tcgarc.i);
        double dk=tcgarc.z-(sz+tcgarc.k);
        //check if center to s e point is equal
        /*
        S32 dis1=sqrt(tcgarc.i*tcgarc.i+tcgarc.k*tcgarc.k);
        S32 dis2=sqrt(pow((tcgarc.x-(sx+tcgarc.i)),2)+
                       pow((tcgarc.z-(sz+tcgarc.k)),2));
                       */
        S32 dis1=sqrt(pow(i,2)+pow(k,2));
        S32 dis2=sqrt(pow(di,2)+pow(dk,2));
        if(abs(dis2-dis1)>10)
            return GERR_ARC_RERR;
    }else{
        //check if r is big enough
        double di=sx-tcgarc.x;
        double dk=sz-tcgarc.z;
        S32 dis=sqrt(pow(di,2)+pow(dk,2));
        if(dis>2*tcgarc.r) //less then 1u
            return GERR_ARC_RERR;
    }
    tcgarc.sendCount=STDsendcount++;
    *((PTCGarc)&TCGbuf[TCGwptr])=tcgarc;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GARC(tcgarc.gnum, tcgarc.x,tcgarc.z,tcgarc.i,tcgarc.k,tcgarc.r,tcgarc.sendCount);
    g73CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g73PAUSE
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g04 in g73
****************************************************************************
*/

U8 g73Pause(void)
{
    PcompiledFST fstptr;
    TTCGfst tcg04;
    tcg04.gnum=GCODE_04;
    fstptr=(PcompiledFST)execGptr;
    if(fstptr->paramType&GXU_IS_VALUE)
    {
        tcg04.value=fstptr->value;
    }else if(fstptr->paramType&GXU_IS_PARAM){
        //it is a param
        if(fstptr->paramType&GZW_IS_PARAM)
        {
            tcg04.value=getVarValuePQ(fstptr->value);
        }else{
            S32 decimal;
            switch(sysUnit)
            {
                case(0): //input is meter 3 tail digit
                    decimal=1000;
                    break;
                case(1): //input is meter 4 tail digit
                    decimal=10000;
                    break;
                default:
                    decimal=1000;
                    break;
            }
            tcg04.value=getVarValue(fstptr->value/1000)*1000/decimal;
        }
    }else{
        tcg04.value=1; //just 1 ms stop if no x or p
    }

    //tcg04.sendCount=fstptr->srcline;
    tcg04.sendCount=STDsendcount++;
    tcg04.srcLine=fstptr->srcline;
    tcg04.srcCode=grunPtr;

    //(U32 )execGptr=(U32)execGptr+sizeof(TcompiledFST);
    *((PTCGfst)&TCGbuf[TCGwptr])=tcg04;
    DBMSG_GCODE("GCP G04: val %ld, sendcount %ld\n",tcg04.value,tcg04.sendCount);
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    g73CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g73M
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec m code in g73
****************************************************************************
*/
U8 g73M(void)
{
    PcompiledM   mptr;
    TTCGmcode  tcgm;
    mptr=(PcompiledM)cpdGptr;
    tcgm.gnum=mptr->gtype;
    if(tcgm.gnum==GCODE_M03)
    {
       gC2TCState.sdir=3;
    }else if(tcgm.gnum==GCODE_M04)
    {
       gC2TCState.sdir=4;
    }else if(tcgm.gnum==GCODE_M05)
    {
        gC2TCState.sdir=5;
    }
    //tcgm.gnum=(tcgm.gnum<<8)|0x65;
    tcgm.sendCount=STDsendcount++;
    tcgm.srcLine=mptr->srcline;
    tcgm.srcCode=cpdPtr;
    *((PTCGmcode)&TCGbuf[TCGwptr])=tcgm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    g73CheckEnd();
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g73CheckEnd
*PARAMETER :void
*RETURN : void
*DESCRIPTION: check if a g73 isend, set corr
****************************************************************************
*/
void g73CheckEnd(void)
{
    PcompiledG23 gptr;
    TTCGline tcgline;
    gptr=execGptr;

    if(grunPtr==cpdEnd)
    {
        if(d==0) //end of compound gcode
        {
            compoundGcode=0;
            grunPtr++;
            execGptr++;
            tcgline.x=g7xorgx;
            tcgline.z=g7xorgz;
        }else{
            d=d-1;
            grunPtr=cpdStart;
            execGptr=&compiledGbuf[grunPtr];
            tcgline.x=g7xorgx+du+stepx*d;
            tcgline.z=g7xorgz+dw+stepz*d;
        }
        //add a g0 to go to loop start point
        tcgline.gnum=GCODE_00;
        tcgline.sendCount=STDsendcount++;
        tcgline.srcLine=gptr->srcline;
        tcgline.srcCode=grunPtr;

        gC2TCState.x=g7xorgx;
        gC2TCState.z=g7xorgz;
        tcgline.x=unit2Meter4Digit(tcgline.x);
        if(dimMode)
            tcgline.x/=2;
        tcgline.z=unit2Meter4Digit(tcgline.z);
        tcgline.y=gC2TCState.y;
        tcgline.y=unit2Meter4Digit(tcgline.y);
        *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
        CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
        DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
        DEBUGMSG(1,"G73 %d cycle\n",d);
        //here we add a g46 to recover if we are in g41 g42 mode,
        g7xAddCodeG4546(GCODE_46);
    }else{
        grunPtr++;
        execGptr++;
    }
}

/***************************************************************************
*FUNCTION: g742TCG
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec g74 to send code to tcgbuffer
****************************************************************************
*/
U8 g74752TCG(void)
{
    U8 err;
    PcompiledG7x g7475=(PcompiledG7x)execGptr;
    if(compoundGcode==0)
    {
        if(((g7475->gtype==GCODE_74)&&(g7475->paramType&GZW_IS_SETED))
            ||((g7475->gtype==GCODE_75)&&(g7475->paramType&GXU_IS_SETED)))
        {
            err=g7475GetVar();
        }else{
            err=g7475SetVar();
        }
    }else{ //we are reentering
        err=g7475cycle();

    }
    return err;
}
/***************************************************************************
*FUNCTION: g74SetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g74 vars to sys param
****************************************************************************
*/
U8 g7475SetVar(void)
{
    PcompiledG7x g74=(PcompiledG7x)execGptr;
    //set params  of g74
    S32 r;
    if(g74->paramType&GR_IS_SETED)
    {
        if(g74->paramType&GR_IS_VALUE)
        {
            r=g74->r;//paramSetVal(196, g74->r);
        }else if(g74->paramType&GR_IS_PARAM)
        {
            r=getVarValue(g74->r);//paramSetVal(196, globalVar[g74->r]);
        }
        //conver to meter unit
        r=unit2um(r); //to um
        if((r<0)||(r>99999))//check r limit
            r=0;
        if(r!=SYSparam[196].val)
            paramAutoSetVal(196, r);
    }
    execGptr++;
    grunPtr++;
    DBMSG_GCODE("GCP g74 set vars\n");

    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g74GetVar
*PARAMETER :void
*RETURN : void
*DESCRIPTION: set g74 vars to sys param
****************************************************************************
*/
U8 g7475GetVar(void)
{
    U16 i;
    PcompiledG7x g7475=(PcompiledG7x)execGptr;
    //a real g74, init all vars and start loop
    if(gC2TCState.f==0)
        return GERR_NOFEED_G1;
    g7xorgx = gC2TCState.x;
    g7xorgz = gC2TCState.z;

    if(g7475->paramType&GXU_IS_VALUE)
    {
        if(g7475->paramType&GXU_IS_INC)
            g7xendx=g7475->u+gC2TCState.x;
        else
            g7xendx=g7475->u;
    }else if(g7475->paramType&GXU_IS_PARAM)
    {
        if(g7475->paramType&GXU_IS_INC)
            g7xendx=getVarValue(g7475->u)+gC2TCState.x;
        else
            g7xendx=getVarValue(g7475->u);
    }else{
        g7xendx=gC2TCState.x;
    }

    if(g7475->paramType&GZW_IS_VALUE)
    {
        if(g7475->paramType&GZW_IS_INC)
            g7xendz=g7475->w+gC2TCState.z;
        else
            g7xendz=g7475->w;
    }else if(g7475->paramType&GZW_IS_PARAM)
    {
        if(g7475->paramType&GZW_IS_INC)
            g7xendz=getVarValue(g7475->w)+gC2TCState.z;
        else
            g7xendz=getVarValue(g7475->w);
    }else{
        g7xendz=gC2TCState.z;
    }
    di=0;
    dk=0;
    d=0;
    if(g7475->paramType&GI_IS_VALUE)
    {
        di=g7475->p;
    }else if (g7475->paramType&GI_IS_PARAM)
    {
        di=getVarValue(g7475->p);
    }
    if(g7475->paramType&GK_IS_VALUE)
    {
        dk=g7475->q;
    }else if (g7475->paramType&GK_IS_PARAM)
    {
        dk=getVarValue(g7475->q);
    }
    if(g7475->paramType&GR_IS_VALUE)
    {
        d=g7475->r;
    }else if (g7475->paramType&GR_IS_PARAM)
    {
        d=getVarValue(g7475->r);
    }
    //d =g7475->r; //asum coord is from small to big
    enagle =anti_unit2um(DSPparam.sysdword[76]);
    if ((enagle<0)||(enagle>999990))//check r limit
        enagle=0;
    //e=meter4Digit2Unit(e*10);
    if (g7475->gtype==GCODE_74)
    {
        if(g7xorgx>=g7xendx)
        {  //this two value is set as the feed direction value
        	di = -di;
        	d = -d;
        }
        if(g7xorgz>g7xendz)
        {
        	dk = -dk;
        	enagle=-enagle;
        }
    }else{
        if(g7xorgx>g7xendx)
        {
        	di = -di;
        	enagle=-enagle;
        }
        if(g7xorgz>=g7xendz)
        {   //this two value is set as the feed direction value
        	dk = -dk;
        	d = -d;
        }
    }

    g7475step=0;
    g7xendx1=g7xorgx;
    g7xendz1=g7xorgz;
    g7xsrcLine=g7475->srcline;
    compoundGcode=GCODE_74;
    DBMSG_GCODE("GCP real g7475 started\n");
    //here we add a g45 stop radium compensation if needed
    g7xAddCodeG4546(GCODE_45);
    return GERR_OK;
}

U8 g7475cycle(void)
{
    U32 i;
    TTCGline tcgline;
    for(i=0;i<2;i++)
    {
        switch(g7475step)
        {
            case(0):  //step in
            case(1):  //step in
                if(execGptr->gtype==GCODE_74)
                {
                    if(g7xendz!=g7xendz1)
                    {
                        if(abs(g7xendz-g7xendz1)>(abs(dk)+abs(g7475step*e)))
                        {
                            g7xendz1=g7xendz1+dk+g7475step*e;
                        }else{
                            g7xendz1=g7xendz;
                        }
                        if(g7xendz1==g7xendz)
                        {
                            if(g7xendx1==g7xendx)
                                g7475step=4;
                            else
                                g7475step=3;
                        }else
                            g7475step=2;
                    }else{
                        g7475step=3;
                        continue;
                    }
                }else{  //75
                    if(g7xendx!=g7xendx1)
                    {
                        if(abs(g7xendx-g7xendx1)>(abs(di)+abs(g7475step*e)))
                        {
                            g7xendx1=g7xendx1+di+g7475step*e;
                        }else{
                            g7xendx1=g7xendx;
                        }
                        if(g7xendx1==g7xendx)
                        {
                            if(g7xendz1==g7xendz)
                                g7475step=4;
                            else
                                g7475step=3;
                        }else
                            g7475step=2;
                    }else{
                        g7475step=3;
                        continue;
                    }
                }
                //out go a g1
                tcgline.gnum=1;
                tcgline.sendCount=STDsendcount++;
                tcgline.srcCode=grunPtr;
                tcgline.srcLine=g7xsrcLine;
                tcgline.x=g7xendx1;
                tcgline.z=g7xendz1;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                tcgline.y=gC2TCState.y;
                tcgline.y=unit2Meter4Digit(tcgline.y);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                break;
            case(2):  //step out delta e
                //out go a g0
                if(execGptr->gtype==GCODE_74)
                {
                    g7xendz1=g7xendz1-e;
                }else{ //75
                    g7xendx1=g7xendx1-e;
                }
                g7475step=1;
                tcgline.gnum=0;
                tcgline.sendCount=STDsendcount++;
                tcgline.srcCode=grunPtr;
                tcgline.srcLine=g7xsrcLine;
                tcgline.x=g7xendx1;
                tcgline.z=g7xendz1;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                tcgline.y=gC2TCState.y;
                tcgline.y=unit2Meter4Digit(tcgline.y);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                break;
            case(3):  //step back,and foreword
                //out go 3 g0
                if(execGptr->gtype==GCODE_74)
                {
                    g7xendx1=g7xendx1-d;
                }else{ //75
                    g7xendz1=g7xendz1-d;
                }
                tcgline.gnum=0;
                tcgline.sendCount=STDsendcount++;
                tcgline.srcCode=grunPtr;
                tcgline.srcLine=g7xsrcLine;
                tcgline.x=g7xendx1;
                tcgline.z=g7xendz1;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                tcgline.y=gC2TCState.y;
                tcgline.y=unit2Meter4Digit(tcgline.y);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                //2
                if(execGptr->gtype==GCODE_74)
                {
                    g7xendz1=g7xorgz;
                }else{ //75
                    g7xendx1=g7xorgx;
                }
                tcgline.sendCount=STDsendcount++;
                tcgline.x=g7xendx1;
                tcgline.z=g7xendz1;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                // 3
                if(execGptr->gtype==GCODE_74)
                {
                    if(abs(g7xendx1-g7xendx)>=abs(di+d))
                        g7xendx1=g7xendx1+di+d;
                    else
                        g7xendx1=g7xendx;
                }else{ //75
                    if(abs(g7xendz1-g7xendz)>=abs(dk+d))
                        g7xendz1=g7xendz1+dk+d;
                    else
                        g7xendz1=g7xendz;
                }
                tcgline.sendCount=STDsendcount++;
                tcgline.x=g7xendx1;
                tcgline.z=g7xendz1;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                g7475step=0;
                break;
            case(4):  //step end
                if(execGptr->gtype==GCODE_74)
                {
                    g7xendx1=g7xendx1-d;
                }else{ //75
                    g7xendz1=g7xendz1-d;
                }
                tcgline.gnum=0;
                tcgline.sendCount=STDsendcount++;
                tcgline.srcCode=grunPtr;
                tcgline.srcLine=g7xsrcLine;
                tcgline.x=g7xendx1;
                tcgline.z=g7xendz1;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                tcgline.y=gC2TCState.y;
                tcgline.y=unit2Meter4Digit(tcgline.y);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                //out go 2 g0
                tcgline.gnum=0;
                tcgline.sendCount=STDsendcount++;
                tcgline.srcCode=grunPtr;
                tcgline.srcLine=g7xsrcLine;
                if(execGptr->gtype==GCODE_74)
                {
                    tcgline.x=g7xendx1;
                    tcgline.z=g7xorgz;
                }else{
                    tcgline.x=g7xorgx;
                    tcgline.z=g7xendz1;
                }
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);

                tcgline.gnum=0;
                tcgline.sendCount=STDsendcount++;
                //tcgline.srcCode=grunPtr;
                //tcgline.srcLine=0;
                tcgline.x=g7xorgx;
                tcgline.z=g7xorgz;
                gC2TCState.x = tcgline.x;
                gC2TCState.z = tcgline.z;
                tcgline.x=unit2Meter4Digit(tcgline.x);
                if(dimMode)
                    tcgline.x=tcgline.x/2;
                tcgline.z=unit2Meter4Digit(tcgline.z);
                *((PTCGline)&TCGbuf[TCGwptr])=tcgline;
                CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
                DBMSG_GLINE(tcgline.gnum,tcgline.x,tcgline.z,tcgline.sendCount);
                compoundGcode=0;
                //here we add a g46 to recover if we are in g41 g42 mode,
                g7xAddCodeG4546(GCODE_46);
                grunPtr++;
                execGptr++;
                return GERR_OK; //stop loop and go out
                break;
            default:
                //err
                break;
        }
    }
    return GERR_OK;
}




U8 g762TCG(void)
{
    U8 err;
    PcompiledG7x g76=(PcompiledG7x)execGptr;
    if(compoundGcode==0)
    {
        if(!(g76->paramType&GZW_IS_SETED)) //real g76 must has z
        {
            err=g76SetVar();
        }else{
            err=g76GetVar();
        }
    }else{ //we are reentering
        err=g76Cycle();
    }
    return err;
}
/***************************************************************************
*FUNCTION: g76SetVar
*PARAMETER :
*RETURN : err code
*DESCRIPTION: store g76 relate var to 197m 198r 199a  200q 201 d
****************************************************************************
*/
U8 g76SetVar(void)
{
    PcompiledG7x g76=(PcompiledG7x)execGptr;
    //set params  of g74
    U32 p,q,d,m,r,a;
    if(g76->paramType&GI_IS_VALUE)
    {
        p=g76->p;//paramSetVal(196, g76->r);
    }else if(g76->paramType&GI_IS_PARAM)
    {
       p=getVarValuePQ(g76->p);//paramSetVal(196, globalVar[g76->r]);
    }else{
        p=0;
    }
    if(p!=0)
    {
        if(p>=1000000)
            return GERR_PARAM_VALERR;
        a=p%100;
        r=(p%10000-a)/100;
        m=(p-r*100-a)/10000;
        if(a!=SYSparam[199].val)
            paramAutoSetVal(199, a);
        if(r!=SYSparam[198].val)
        {
            paramAutoSetVal(198, r);
        }
        if((m!=0)&&(m!=SYSparam[197].val))
        {
            paramAutoSetVal(197, m);
        }
    }
    //set delta dmin
    if(g76->paramType&GK_IS_SETED)
    {
        if(g76->paramType&GK_IS_VALUE)
        {
            q=g76->q;//paramSetVal(196, g76->r);
        }else if(g76->paramType&GK_IS_PARAM)
        {
            q=getVarValue(g76->q);//paramSetVal(196, globalVar[g76->r]);
        }
        q=unit2um(q);
        if((q<0)||(q>=99999))
            return GERR_PARAM_VALERR;
        if(q!=SYSparam[200].val)
            paramAutoSetVal(200, q);
    }
    if(g76->paramType&GR_IS_SETED)
    {
        if(g76->paramType&GR_IS_VALUE)
        {
            r=g76->r;//paramSetVal(196, g76->r);
        }else if(g76->paramType&GR_IS_PARAM)
        {
            r=getVarValue(g76->r);//paramSetVal(196, globalVar[g76->r]);
        }
        r=unit2um(r);
        if((r<0)||(r>=99999))
            return GERR_PARAM_VALERR;
        if(r!=SYSparam[201].val)
            paramAutoSetVal(201, r);
    }

    execGptr++;
    grunPtr++;
    DBMSG_GCODE("GCP g76 set vars\n");

    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g76GetVar
*PARAMETER :
*RETURN : err code
*DESCRIPTION: get var from param
****************************************************************************
*/
U8 g76GetVar(void)
{
//U8 g76m,g76r,g76a;
//S32 g76dmin,g76d,g76k,g76dd;
    S32 u,dz;
    S32 f;
    PcompiledG7x g76=(PcompiledG7x)execGptr;
    g7xorgx = gC2TCState.x;
    g7xorgz = gC2TCState.z;
    g76a=SYSparam[199].val;
    //get tg(a/2)
    g76a=PI*(g76a/2)/180;
    g76a=tan(g76a);

    g76r=SYSparam[198].val;  //for param 退尾
    g76m=SYSparam[197].val;
    g76dmin=unit2Meter4Digit(anti_unit2um(SYSparam[200].val)); //um to meter4 digit
    g76d=unit2Meter4Digit(anti_unit2um(SYSparam[201].val));    //um to meter4 digit

    if(g76->paramType&GXU_IS_VALUE)
    {
        if(g76->paramType&GXU_IS_INC)
        {
            g7xendx1=g76->u+gC2TCState.x;
        }else{
            g7xendx1=g76->u;
        }
    }else if(g76->paramType&GXU_IS_PARAM)
    {
        if(g76->paramType&GXU_IS_INC)
        {
            g7xendx1=getVarValue(g76->u)+gC2TCState.x;
        }else{
            g7xendx1=getVarValue(g76->u);
            }
    }
    u=g7xendx1-gC2TCState.x;
    if(dimMode)
    {
        u=u/2;
    }
    if(g76->paramType&GZW_IS_VALUE)
    {
        if(g76->paramType&GZW_IS_INC)
        {
            g7xendz=g76->w+gC2TCState.z;
        }else{
            g7xendz=g76->w;
        }
    }else if(g76->paramType&GZW_IS_PARAM)
    {
        if(g76->paramType&GZW_IS_INC)
        {
            g7xendz=getVarValue(g76->w)+gC2TCState.z;
        }else{
            g7xendz=getVarValue(g76->w);
        }
    }
    dz=abs(g7xendz-gC2TCState.z);
    //------------------------------
    g76i=0;
    if(g76->paramType&GR_IS_VALUE)
    {
        g76i=g76->r;
    }else if(g76->paramType&GR_IS_PARAM)
    {
        g76i=getVarValue(g76->r);
    }
    if(g76->paramType&GI_IS_VALUE)
    {
        g76k=g76->p;
    }else if(g76->paramType&GI_IS_PARAM)
    {
        g76k=getVarValue(g76->p);
    }
	g76ra =1.0L*abs(g76i)/dz;
    if(g76i!=0)//detemide where r should be add
    {
        if(((u>0)&(g76i<0))||((u<0)&&(g76i>0)))
        {
             if(((abs(u)-g76k)<abs(g76i)))
             {
                 //g76i=0-u;
                 return GERR_PARAM_VALERR;
             }
        }
        g7xendx=g7xendx1;
        g7xendx1=g7xendx1+g76i;
        if(dimMode)
            g7xendx1=g7xendx1+g76i; //may be bugs
    }else{
        g7xendx=g7xendx1;
    }

    if(g76->paramType&GK_IS_VALUE)
    {
        g76dd=g76->q;
    }else if(g76->paramType&GK_IS_PARAM)
    {
        g76dd=getVarValue(g76->q);
    }
    if(g7xendx>gC2TCState.x)
    {
        g76kdir=0-g76k;
    }else
        g76kdir=g76k;
    g76dz=(g76k-g76d)*g76a;
    if(g76->paramType&GF_IS_VALUE)
    {
        gC2TCState.screwf=g76->f;
    }else if(g76->paramType&GF_IS_PARAM)
    {
        gC2TCState.screwf=getVarValue(g76->f);
    }
    //get screw f
    if(g76->paramType&GF_IS_SETED)
    {
        if(g76->paramType&GF_IS_VALUE)
            f=g76->f;
        else
            f=getVarValue(g76->f);
        if(g76->paramType&GF_IS_INC)
        {
            if(f==0)
                return GERR_PARAM_VALERR;
            if(sysUnit==0)
            {  //IS ENLARGE 1000
                f=25400000.0/f;
            }else{
                //given as # or i in inch, IS ENLARGE 10000
                f=100000000.0/f;
            }
        }
        gC2TCState.screwf=f;
    }else{
        if(gC2TCState.screwf>0)
            f=gC2TCState.screwf;
        else
            return GERR_G32_MISS_FI;
    }
    g76f=f;
    g76f=unit2Meter4DigitFloat(g76f);
    g76f=g76f/10000.0;// the f in g76 is u ,conver form u to mm
    g76r=g76f*g76r*10000/10;  //for param 退尾
    //g76rx=g76r;
    g76rz=g76r;

    g76rxd=1.0L*g76r*abs(g76i)/abs(dz); //计算 退尾前 x坐标与 设定终点的差
    if(g7xendz>gC2TCState.z)
        g76rz=0-g76r;//dao jiao sign
    if(g7xendx<g7xendx1)
    {
        g76rxd=g76rxd;
        g76ra=0-g76ra;
    }else{
        g76rxd=0-g76rxd;
        g76ra=g76ra;
    }
    if(gC2TCState.x<g7xendx)
    { //- -->+
        g76rx=0-g76r;
    }else if(gC2TCState.x>g7xendx)
    {// + --> -
        g76rx=g76r;
    }else{
        return GERR_PARAM_VALERR;
    }
    //----------------------------
    {
        //S32 dr=0;
        double dr=0;
        dr=sqrt(1.0l*g76i*g76i+1.0l*dz*dz);

        if(dz>=g76i)
        {
           g76f=dr/abs(dz)*g76f*gC2TCState.s;
        }else
        {   //here abs(dr) is dx ,may be a bug
            g76f=dr/g76i*g76f*gC2TCState.s;
        }
        g76f=g76f*1000.0; //form mm to um now
        if(((U32)g76f)==0)
            return GERR_NOFEED_G1;
    }
    //conver all other vars to meter4 unit
    //S32 g76dmin,g76d,g76i,g76k,g76dd, g76kdir;
    //S32 g76rx,g76rz;
    g7xorgx=unit2Meter4Digit(g7xorgx);
    g7xorgz=unit2Meter4Digit(g7xorgz);
    g7xendx1=unit2Meter4Digit(g7xendx1);
    g7xendx=unit2Meter4Digit(g7xendx);
    g7xendz=unit2Meter4Digit(g7xendz);
    //g76dmin=unit2Meter4Digit(g76dmin);
    //g76d=unit2Meter4Digit(g76d);
    g76dd=unit2Meter4Digit(g76dd);
    g76deep=0;//g76dd; //record the cut deep
    g76k=unit2Meter4Digit(g76k);
    g76kdir=unit2Meter4Digit(g76kdir);
    g76i=unit2Meter4Digit(g76i);
    if((g76k<g76dd)||(g76k>abs(g7xendx-g7xstartx)))
    {
        return GERR_PARAM_VALERR;
        //gexecState=GEXEC_EXERR;
        //return GERR_UNKNOWN;
    }
    //ready to run
    g76n=1;
    g7475step=0;
    compoundGcode=GCODE_76;
    DBMSG_GCODE("GCP start g76\n");
    //here we add a g45 stop radium compensation if needed
    g7xAddCodeG4546(GCODE_45);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: g76Cycle
*PARAMETER :
*RETURN : err code
*DESCRIPTION: run the g76 screw cycle once
****************************************************************************
*/
U8 g76Cycle(void)
{
    TTCGarc codebuf;
    TTCGline codeline;
    PTCGmcode pm=(PTCGmcode)&codebuf;
    PTCGfst   pfst=(PTCGfst)&codebuf;
    PTCGline  pline=&codeline;
    PcompiledG7x g76=(PcompiledG7x)execGptr;
    double dx,dxx,dz;  //dxx 计算由于z向偏移而导致起始x变浅的量
    S32 y=gC2TCState.y;
    y=unit2Meter4Digit(y);
    if(g7475step==0)
    {   //normal cut
        dx=g76dd*sqrt(g76n);
        //dz=g76dd*sqrt(g76n-1)+g76dmin;
        g76n++;
        if((dx-g76deep)<g76dmin)
        {
            dx=g76deep+g76dmin;
        }
        g76deep=dx;
        if(dx>=(g76k-g76d))
        {    dx=g76k-g76d;
            g7475step=1; //use g7475step to start fine cut
        }
    }else{
        if(g76m==0)
            g76m=1;
        g76m--;
        dx=g76k;
    }
    dz=g76a*dx;
    dxx=g76ra*dz;
    if(g7xendx1<g7xorgx)
    {
        dx=0-dx;
    }
    if(g7xendz<g7xorgz)
        dz=0-dz;
    if(abs(g7xorgz-g7xendz)<abs(dz)) //it  dz is too long
    {
        return GERR_PARAM_VALERR;
    }
    //we must fill the TCG buffer with 7 gcode ,make sure it have space
    //if(CYCLE_BUF_DEEP(TCGwptr, TCGrptr, TCG_BUF_MAX)>(TCG_BUF_MAX-12))
    //    return;
    //add the step 1 g0
    //get the x and z value
       //step 2.1 add a prev f resum code here
    if(gC2TCState.f==0) //give a special f
    {
         if(gC2TCState.GG03==GCODE_99)
         {
            gC2TCState.f=20;
         }else{
            gC2TCState.f=30000;
         }
         memset(pfst,0,sizeof(TTCGarc));
         pfst->gnum=GCODE_F;
         pfst->sendCount=STDsendcount;
         pfst->srcLine=g76->srcline;
         pfst->srcCode=grunPtr;
         pfst->value=gC2TCState.f;
         DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
          *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
         CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    }
    //step 1
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_00;
    pline->sendCount=STDsendcount;
    pline->srcLine=g76->srcline;
    pline->srcCode=grunPtr;
    pline->x=g7xorgx;
    pline->z=g7xorgz+dz;
    pline->y=y;
    if(dimMode)
        pline->x/=2;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 1.5
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_00;
    pline->sendCount=STDsendcount;
    pline->srcLine=g76->srcline;
    pline->srcCode=grunPtr;
    pline->x=g7xendx1;
    if(dimMode)
        pline->x/=2;
    pline->x+=g76kdir+dx+dxx;
    pline->z=g7xorgz+dz;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //as lly need ,we put all asssic code after 1 g01
    //line real screw, step 2
    /*
    pline->gnum=GCODE_01;
    pline->sendCount=STDsendcount;
    pline->srcLine=g76->srcline;
    pline->srcCode=grunPtr;

    pline->x=g7xendx;
    if(dimMode)
        pline->x/=2;
    pline->x+=g76kdir+dx;
    pline->z=g7xendz+g76rz;

    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    */
    //m3
    memset(pm,0,sizeof(TTCGarc));
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        return GERR_SCREW_NOS;
        //gexecState=GEXEC_EXERR;
        //showHint(OPERR_SSTOP_SCREW,SHOW_TIME_FEVER);
    }
    pm->sendCount=STDsendcount;
    pm->srcLine=g76->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //M253
    memset(pm,0,sizeof(TTCGarc));
    pfst->gnum=GCODE_M253;
    pfst->value=0;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g76->srcline;
    pfst->srcCode=grunPtr;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //S
    pfst->gnum=GCODE_S;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g76->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.s; //s must be
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
    *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //g01 since f need x, z ,we cal g1 first, save it later


    //F
    pfst->gnum=GCODE_SCREW;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g76->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=g76f/gC2TCState.s;//g76->k*gC2TCState.s;
    /*
    if(gC2TCState.GG03==GCODE_99)
    {
        //pfst->value=g76f/60.0;
        pfst->value=g76f/gC2TCState.s;
    }
    */
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //m255
    memset(pm,0,sizeof(TTCGarc));
    pm->gnum=GCODE_M255;
    pm->sendCount=STDsendcount;
    pm->srcLine=g76->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //m3
    if(gC2TCState.sdir==3)
        pm->gnum=GCODE_M03;
    else if(gC2TCState.sdir==4)
        pm->gnum=GCODE_M04;
    else{
        return GERR_SCREW_NOS;
        //gexecState=GEXEC_EXERR;
        //showHint(OPERR_SSTOP_SCREW,SHOW_TIME_FEVER);
    }
    pm->sendCount=STDsendcount;
    pm->srcLine=g76->srcline;
    pm->srcCode=grunPtr;
    DBMSG_M(pm->gnum,pm->sendCount);
    *((PTCGmcode)&TCGbuf[TCGwptr])=*pm;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    //line real screw, step 2
    memset(pline,0,sizeof(TTCGline));
    pline->gnum=GCODE_01;
    pline->sendCount=STDsendcount;
    pline->srcLine=g76->srcline;
    pline->srcCode=grunPtr;

    pline->x=g7xendx;
    if(dimMode)
        pline->x/=2;
    pline->x+=g76kdir+g76rxd+dx;
    pline->z=g7xendz+g76rz;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 2.1 add a prev f resum code here
    //
    //step 2.1 add a prev f resum code here

    pfst->gnum=GCODE_F;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g76->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=gC2TCState.f;

    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

    memset(pline,0,sizeof(TTCGline));
    //step2.5
    pline->gnum=GCODE_01;
    pline->sendCount=STDsendcount;
    pline->srcLine=g76->srcline;
    pline->srcCode=grunPtr;

    pline->x=g7xendx;
    if(dimMode)
        pline->x/=2;
    pline->x+=g76kdir+dx+g76rx;
    pline->z=g7xendz;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);

        //add the g04 to sign the screw phase is over
    pfst->gnum=GCODE_04;
    pfst->sendCount=STDsendcount;
    pfst->srcLine=g76->srcline;
    pfst->srcCode=grunPtr;
    pfst->value=0;
    DBMSG_FST(pfst->gnum,pfst->value,pfst->sendCount);
     *((PTCGfst)&TCGbuf[TCGwptr])=*pfst;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 3
    pline->gnum=GCODE_00;
    pline->x=g7xorgx;
    if(dimMode)
        pline->x/=2;
    pline->z=g7xendz;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    //step 4
    pline->gnum=GCODE_00;
    pline->x=g7xorgx;
    if(dimMode)
        pline->x/=2;
    pline->z=g7xorgz;
    pline->y=y;
    DBMSG_GLINE(pline->gnum,pline->x,pline->z,pline->sendCount);
    *((PTCGline)&TCGbuf[TCGwptr])=*pline;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    DBMSG_GCODE("GCP 76 once : X %d,Z %d\n",g76->u,g76->w);
    STDsendcount++;
    if((g7475step==1)&&(g76m==0))
    {
        execGptr++;
        grunPtr++;
        compoundGcode=0;
        DBMSG_GCODE("GCP 76 done\n");
        //here we add a g46 to recover if we are in g41 g42 mode,
        g7xAddCodeG4546(GCODE_46);
    }
    return GERR_OK;
}

/***************************************************************************
*FUNCTION: converAddr
*PARAMETER :index of the global var
*RETURN : value of the var
*DESCRIPTION: handle the unit change in global vars
****************************************************************************
*/

S32 converAddr(S32 val)
{
    S32 result;
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            result=val/1000;
            break;
        case(1): //input is meter 4 tail digit
            result=val/10000;
            break;
        default:
            break;
     }
     return result;
}
/***************************************************************************
*FUNCTION: getVarValue
*PARAMETER :index of the global var
*RETURN : value of the var
*DESCRIPTION: get the global var value from the given index
****************************************************************************
*/
double getVarValueF(S32 index)
{
    double result;
    U8 sign=1;
    if(index<0)
    {
        sign=-1;
        index=abs(index);
    }
    if((index>=MACRO_VAR_START)&&(index<MACRO_VAR_END))
    {
        if(sign==1)
            result= macro_val[index-MACRO_VAR_START];
        else
            result=0-macro_val[index-MACRO_VAR_START];
        return result;
    }
    if((index>=MACRO_VAR_START+9000)&&(index<MACRO_VAR_END+9000))
    {
        index=macro_val[index-9000-MACRO_VAR_START];
        //index=index/1000;
        //index=converAddr(index);
    }
    if(index>9000)
    {
        index=globalVar[index-9000-1];
        //index=index/1000;
        //index=converAddr(index);
    }
    //recheck index here
    if(SYSparam[69].val!=0)
    {
        if(index==401)
        {
            return (F64)coordMACH.x/10000;
        }else if(index==402){
            return (F64)coordMACH.y/10000;
        }else if(index==403){
            return (F64)coordMACH.z/10000;
        }
    }
    if((index<1)||(index>GLOBAL_VAR_MAX))
    {
        //case alarm
        ALARM_GRP1|=ALM_GRP1_MACRO_RUNERR;
        return 0; //return a use less value
    }
    if(sign==1)
        result= globalVar[index-1];
    else
        result=0-globalVar[index-1];
    return result;

}
S32 getVarValue(S32 index)
{
    S32 decimal;
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            decimal=1000;
            break;
        case(1): //input is meter 4 tail digit
            decimal=10000;
            break;
        default:
            decimal=1000;
            break;
    }
    return round(getVarValueF(index)*decimal);
}
S32 getVarValuePQ(S32 index)
{
    return round(getVarValueF(index));
}
/***************************************************************************
*FUNCTION: hcodeExec
*PARAMETER :adj address to get returned adj of exec process
*RETURN : err code
*DESCRIPTION: execute the hcode macros in gcode
****************************************************************************
*/
U8  hcodeExec(U16 gnum,S16* adj)
{
    U8 err=GERR_OK;
    PcompiledG23 phcode=execGptr;

    Errsrc = execGptr->srcline;
    switch(gnum)
    {
        case(GCODE_H01):
            err=hcodeSingleOPCal();
            *adj=-1;
            break;
        case(GCODE_H02):
        case(GCODE_H03):
        case(GCODE_H04):
        case(GCODE_H05):
            err=hcodeNormalCal();
            *adj=-1;
            break;
        case(GCODE_H11):
        case(GCODE_H12):
        case(GCODE_H13):
            hcodeLogicCal();
            *adj=-1;
            break;
        case(GCODE_H21):
        case(GCODE_H22):
            err=hcodeSingleOPCal();
            *adj=-1;
            break;
        case(GCODE_H23):
        case(GCODE_H24):
        case(GCODE_H25):
        case(GCODE_H26):
        case(GCODE_H27):
            err=hcodeMathCal();
            *adj=-1;
            break;
        case(GCODE_H31):
        case(GCODE_H32):
        case(GCODE_H33):
        case(GCODE_H34):
            err=hcodeTriangleCal();
            break;
        case(GCODE_H80):
        case(GCODE_H81):
        case(GCODE_H82):
        case(GCODE_H83):
        case(GCODE_H84):
        case(GCODE_H85):
        case(GCODE_H86):
            err=hcodeJump();
            *adj=-1;
            break;
        case(GCODE_H99):
            err=hcodeAlarm();
            *adj=-1;
            break;
        default:
            err=GERR_G_UNKOWN;
            break;
    }
    return err;
}
/**************************************************************************
*FUNCTION: hcodeCheckOP1
*PARAMETER :void
*RETURN : OP1 type 1 io in ,2 io out 3 param 26-99 4 param 100-127; others 0
*DESCRIPTION: check what type of param the op1 is
***************************************************************************
*/
U8 hcodeCheckOP1(S32* val)
{
    U8 result;
    if((*val>=MACRO_VAR_START)&&(*val<MACRO_VAR_END))
    {
        return 3;
    }
    if((*val>=(MACRO_VAR_START+9000))&&(*val<(MACRO_VAR_END+9000)))
    {
        *val=macro_val[*val-9000-MACRO_VAR_START];
        //*val=converAddr(*val);
    }else if(*val>9000)
    {
        *val=globalVar[*val-9000-1];
        //*val=converAddr(*val);//*val/1000;
    }
    if(*val<=200)
        result=1;
    else if(*val<=GLOBAL_VAR_MAX)  //is  record vars
        result=2;
    else
    {
        result=0;
        ALARM_GRP1|=ALM_GRP1_MACRO_RUNERR;
    }
    *val=*val-1;  //real index of var is -1
    return result;
}
/***************************************************************************
*FUNCTION: hcodeWriteOP1
*PARAMETER :void
*RETURN : void
*DESCRIPTION: wirte the opp
****************************************************************************
*/
U8 hcodeWriteOP1(U16 index,U8 opptype)
{
    if((index<200)||(index>GLOBAL_VAR_MAX))
        return GERR_OK;
    if(opptype==2)
    {
        //IIC_Write8(IICADDR_GVARS+(index-200)*8, globalVar[index]);
        IIC_Write(IICADDR_GVARS+(index-200)*8, &globalVar[index],8);
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcodeGetOP23Value
*PARAMETER :void
*RETURN : void
*DESCRIPTION: get the value of hcode op 2 and 3 to given address
****************************************************************************
*/
void hcodeGetOP23Value(PcompiledG23 phcode,F64* opq,F64* opr)
{
    S32 qindex,rindex,index,decimal;
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            decimal=1000;
            break;
        case(1): //input is meter 4 tail digit
            decimal=10000;
            break;
        default:
            decimal=1000;
            break;
    }
    qindex=phcode->zw;
    if(phcode->paramType&Q_IS_VALUE)
    {
        *opq=qindex/decimal;
    }else if(phcode->paramType&Q_IS_PARAM)
    {
        *opq=getVarValueF(phcode->zw);

    }else
        *opq=0;  //if no q, set to zero

    rindex=phcode->r;
    if(phcode->paramType&R_IS_VALUE)
    {
        *opr=rindex/decimal;
    }else if(phcode->paramType&R_IS_PARAM)
    {
        *opr=getVarValueF(phcode->r);
    }else
        *opr=0; // if no r ,set to zero
}
/***************************************************************************
*FUNCTION: hcode01
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal hcode 01
****************************************************************************
* /
void hcode01()
{
    PcompiledG23 phcode=execGptr;
    if(hcode.paramType&GQ_IS_VALUE)
    {
        globalVar[hcode.xu]=hcode.zw;
    }else{ //Q IS A PARAM
        globalVar[hcode.xu]=globalVar[hcode.zw];
    }
}
/***************************************************************************
*FUNCTION: hcodeNormalCal
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation + - * / of h code
****************************************************************************
*/

U8 hcodeNormalCal(void)
{
    S32 opp;
    F64 opq,opr;
    U8 opptype;
    PcompiledG23 phcode=execGptr;
    opp=phcode->xu;
    opptype=hcodeCheckOP1(&opp);
    if(opptype==0)
    {
        return GERR_VALUE_INVALID;
    }
    hcodeGetOP23Value(phcode, &opq, &opr);
    switch(phcode->gtype)
    {
        case(GCODE_H02):
            globalVar[opp]=opq+opr;
            break;
        case(GCODE_H03):
            globalVar[opp]=opq-opr;
            break;
        case(GCODE_H04):
            globalVar[opp]=opq*opr;
            break;
        case(GCODE_H05):
            if(opr!=0) //div can't be zero
            {
                globalVar[opp]=opq/opr;
            }else
            {
                return GERR_VALUE_INVALID;
            }
            break;
        default:
            break;
    }
    hcodeWriteOP1(opp,opptype);
    execGptr++;
    grunPtr++;
    DEBUGMSG(1,"GCP H 0x%x,p %d,q%d,r%d\n",phcode->gtype,globalVar[phcode->xu],opq,opr);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcodeNormalCal
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation and or nor  of h code
****************************************************************************
*/
U8 hcodeLogicCal(void)
{
    S32 opp,opq,opr;
    F64 dq,dr;
    U8 opptype;
    PcompiledG23 phcode=execGptr;
    opp=phcode->xu;
    opptype=hcodeCheckOP1(&opp);
    if(opptype==0)
    {
        return GERR_VALUE_INVALID;
    }
    hcodeGetOP23Value(phcode, &dq, &dr);
    opq=dq;
    opr=dr;
    switch(phcode->gtype)
    {
        case(GCODE_H11):
            globalVar[opp]=opq&opr;
            break;
        case(GCODE_H12):
            globalVar[opp]=opq|opr;
            break;
        case(GCODE_H13):
            globalVar[opp]=opq^opr;
            break;
    }
    hcodeWriteOP1(opp,opptype);
    execGptr++;
    grunPtr++;
    DEBUGMSG(1,"GCP H 0x%x,p %d,q%d,r%d\n",phcode->gtype,globalVar[phcode->xu],opq,opr);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcode24BCD2BIN
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation and or nor  of h code
****************************************************************************
*/
U8 hcode24BCD2BIN(U32 src,U32 *result)
{
    U8 i,j;
    U32 temp=0;
    for(i=0;i<8;i++)
    {
        j=((src&0xf0000000)>>28);
        if(j>9)
            return GERR_VALUE_INVALID;
        temp=temp*10+j;
        src=src<<4;
    }
    *result=temp;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcode24BIN2BCD
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation and or nor  of h code
****************************************************************************
*/
U8 hcode25BIN2BCD(U32 src,U32 *result)
{
    U8 i,j;
    U32 temp=0;
    for(i=0;i<8;i++)
    {
        j=src%10;
        src=(src-j)/10;
        temp=temp|(j<<(i*4));
    }
    if(src!=0)
        return GERR_VALUE_INVALID;
    *result=temp;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcodeNormalCal
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation and or nor  of h code
****************************************************************************
*/
U8 hcodeMathCal(void)
{
    S32 opp,opq,opr;
    double dopq,dopr;
    U8 opptype;
    U8 err;
    PcompiledG23 phcode=execGptr;
    opp=phcode->xu;
    opptype=hcodeCheckOP1(&opp);
    if(opptype==0)
    {
        return GERR_VALUE_INVALID;
    }
    hcodeGetOP23Value(phcode, &dopq, &dopr);
    opq=dopq;
    opr=dopr;
    switch(phcode->gtype)
    {
        case(GCODE_H23):
            if(opr==0)
                return GERR_VALUE_INVALID;
            globalVar[opp]=opq%opr;
            break;
        case(GCODE_H24):
//            err=hcode24BCD2BIN(opq,&globalVar[opp]);
            if(err!=GERR_OK)
                return err;
            break;
        case(GCODE_H25):
//            err=hcode25BIN2BCD(opq,&globalVar[opp]);
            if(err!=GERR_OK)
                return err;
            break;
        case(GCODE_H26):
            if(opr==0)
                return GERR_VALUE_INVALID;
            globalVar[opp]=globalVar[opp]*dopq/dopr;
            break;
        case(GCODE_H27):
            globalVar[opp]=sqrt(dopq*dopq+dopr*dopr);
            break;
        default:
            break;
    }
    hcodeWriteOP1(opp,opptype);
    execGptr++;
    grunPtr++;
    DEBUGMSG(1,"GCP H 0x%x,p %d,q%d,r%d\n",phcode->gtype,globalVar[phcode->xu],opq,opr);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcode2127
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation and or nor  of h code
****************************************************************************
*/
U8 hcodeSingleOPCal()
{
    S32 opp,opq,opr;
    double dopq,dopr;
    U8 opptype;
    PcompiledG23 phcode=execGptr;
    opp=phcode->xu;
    opptype=hcodeCheckOP1(&opp);
    if(opptype==0)
    {
        return GERR_VALUE_INVALID;
    }
    hcodeGetOP23Value(phcode, &dopq, &dopr);
    /*
    if(phcode->paramType&Q_IS_VALUE)
    {
        opq=phcode->zw;
    }else{ //Q IS A PARAM
        opq=globalVar[phcode->zw];
    }*/
    opq=dopq;
    opr=dopr;
    switch(phcode->gtype)
    {
        case(GCODE_H01):
            globalVar[opp]=dopq;
            break;
        case(GCODE_H21):
            globalVar[opp]=sqrt(abs(dopq));
            break;
        case(GCODE_H22):
            globalVar[opp]=fabs(dopq);
            break;
        default:
            return 1;
            break;
    }
    hcodeWriteOP1(opp,opptype);
    execGptr++;
    grunPtr++;
    DEBUGMSG(1,"GCP H 0x%x, p %d,q%d\n",phcode->gtype,globalVar[phcode->xu],opq);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcodeNormalCal
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the trigonometric function of h code
****************************************************************************
*/
U8 hcodeTriangleCal(void)
{
    S32 opp,opq,opr;
    double dopq,dopr;
    U8 opptype;
    PcompiledG23 phcode=execGptr;
    opp=phcode->xu;
    opptype=hcodeCheckOP1(&opp);
    if(opptype==0)
    {
        return GERR_PARAM_VALERR;
    }
    hcodeGetOP23Value(phcode, &dopq, &dopr);
    switch(phcode->gtype)
    {
        case(GCODE_H31):
            dopr=PI*dopr/180;
            globalVar[opp]=dopq*sin(dopr);
            break;
        case(GCODE_H32):
            dopr=PI*dopr/180;
            globalVar[opp]=dopq*cos(dopr);
            break;
        case(GCODE_H33):
            dopr=PI*dopr/180;
            globalVar[opp]=dopq*tan(dopr);
            break;
        case(GCODE_H34):
            globalVar[opp]=atan(dopq/dopr)*180/PI;
            break;
        default:
            break;
    }
    hcodeWriteOP1(opp,opptype);
    execGptr++;
    grunPtr++;
    DEBUGMSG(1,"GCP H 0x%x, p %d,q%d\n",phcode->gtype,globalVar[phcode->xu],opq);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcodeNormalCal
*PARAMETER :void
*RETURN : void
*DESCRIPTION: cal the normal calculation and or nor  of h code
****************************************************************************
*/
U8 hcodeJump(void)
{
    U8 condiction=0;
    S32 opp,opq,opr;
    double dopq,dopr;
    U8 err;
    PcompiledG23 phcode=execGptr;
    if(phcode->gtype!=GCODE_H80)
    {
       hcodeGetOP23Value(phcode, &dopq, &dopr);
    }
    switch(phcode->gtype)
    {
        case(GCODE_H80):
            condiction=1;
            break;
        case(GCODE_H81):
            if(dopq==dopr)
                condiction=1;
            break;
        case(GCODE_H82):
            if(dopq!=dopr)
               condiction=1;
            break;
        case(GCODE_H83):
            if(dopq>dopr)
               condiction=1;
            break;
        case(GCODE_H84):
            if(dopq<dopr)
               condiction=1;
            break;
        case(GCODE_H85):
            if(dopq>=dopr)
               condiction=1;
            break;
        case(GCODE_H86):
            if(dopq<=dopr)
               condiction=1;
            break;
        default:
            break;
    }
    //find the  pointer should jump to
    if(condiction==1)
    {
        if(phcode->paramType&P_IS_VALUE)
        {
            //opp=converAddr(phcode->xu);
        }else{
            opp=phcode->xu;
            if(opp>9000)
            {
                opp=globalVar[opp-9000-1];
                //opp=converAddr(opp);
            }
            if((opp<1)||(opp>GLOBAL_VAR_MAX))
            {
                ALARM_GRP1|=ALM_GRP1_MACRO_RUNERR;
            }
            opp=globalVar[opp-1];
            //opp=converAddr(opp);
        }
        err=hcodeJumpTo(opp);
        if(err!=GERR_OK)
            return err;
        DEBUGMSG(1,"hcode 0x%x,jump to %d\n",phcode->gtype, phcode->xu);
    }else{  //if not jumping to others ,just go next
        execGptr++;
        grunPtr++;
       DEBUGMSG(1,"hcode 0x%x, not jump\n",phcode->gtype);
       //return GERR_H_UNKNOWN;
    }
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: hcodeAlarm
*PARAMETER :void
*RETURN : void
*DESCRIPTION: generate user definede alarm
****************************************************************************
*/
U8 hcodeAlarm(void)
{
    S32 opp;
    PcompiledG23 phcode=execGptr;
    if(phcode->paramType&P_IS_VALUE)
    {
        opp=phcode->xu;
    }else
    {
        opp=getVarValueF(phcode->xu);
    }
    DEBUGMSG(1,"hcode 99 generate alarm %d\n",opp);
    return GERR_OK;
}

/***************************************************************************
*FUNCTION: hcodeJumpTo
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec the h code jump function
****************************************************************************
*/
U8 hcodeJumpTo(U16 jumpPointTag)
{
    U32 curProg=gC2TCState.currentProg;  //o number of current Prog
    U16 i;
    for(i=0;i<jumpPointCount;i++) //find out whre to jump
    {
        if((jumpPointList[i].tag==jumpPointTag)&&(jumpPointList[i].prog==curProg))
        {
            grunPtr=jumpPointList[i].address;
            execGptr=&compiledGbuf[grunPtr];
            return GERR_OK;
        }
    }
    return GERR_NO_TAG;
    DEBUGMSG(1,"error,H can't find where to jump of hcode %d\n",jumpPointTag);
}
/***************************************************************************
*FUNCTION: Macro_Exec
*PARAMETER :adj address to get returned adj of exec process
*RETURN : err code
*DESCRIPTION: execute the hcode macros in gcode
****************************************************************************
*/
U8  Macro_Exec(U16 gnum,S16* adj)
{
    U8 err=GERR_OK;
    PcompiledG23 phcode=execGptr;
    S32 opp,opq,opr,decimal;
    double dp,dq,dr,result;
    U8 opptype;
    opp=phcode->xu;
    opptype=hcodeCheckOP1(&opp);
    if(opptype==0)
    {
        return GERR_VALUE_INVALID;
    }
    if(phcode->paramType&Q_IS_VALUE)
    {
        dq=phcode->zw;
    }else if(phcode->paramType&Q_IS_PARAM)
    {
        dq=getVarValueF(phcode->zw);
    }else
    {
        dq=0;  //if no q, set to zero
    }
    if(phcode->paramType&R_IS_VALUE)
    {
        dr=phcode->r;
    }else if(phcode->paramType&R_IS_PARAM)
    {
        dr=getVarValueF(phcode->r);
    }else{
        dr=0; // if no r ,set to zero
    }
    switch(sysUnit)
    {
        case(0): //input is meter 3 tail digit
            decimal=1000;
            break;
        case(1): //input is meter 4 tail digit
            decimal=10000;
            break;
        default:
            decimal=1000;
            break;
    }
    switch(gnum>>8)
    {
        case(MACRO_ASSIGN):
            if(phcode->paramType&Q_IS_VALUE)
            {
                result=dq/decimal;
            }else{
                result=dq;
            }
            break;
        case(MACRO_PLUS):
            result=dq+dr;
            break;
        case(MACRO_MINUS):
            result=dq-dr;
            break;
        case(MACRO_MULTIPLY):
            result=dq*dr;
            break;
        case(MACRO_DIVIDE):
            if(fabs(dr)<0.00001)
            {
                err=GERR_VALUE_INVALID;
            }else{
                result=dq/dr;
            }
            break;
        case(MACRO_POW):
            opr=dr;
            result=pow(dq,opr);
            break;
        case(MACRO_BIT_AND):
            opq=dq;
            opr=dr;
            result=opq&opr;
            break;
        case(MACRO_BIT_OR):
            opq=dq;
            opr=dr;
            result=opq|opr;
            break;
        case(MACRO_BIT_XOR):
            opq=dq;
            opr=dr;
            result=opq^opr;
            break;
        case(MACRO_SQRT):
            if(dq<0)
            {
                err=GERR_VALUE_INVALID;
            }else{
                result=sqrt(dq);
            }
            break;
        case(MACRO_ABS):
            result=fabs(dq);
            break;
        case(MACRO_ROUND):
            result=round(dq);
            break;
        case(MACRO_CEIL):
            result=ceil(dq);
            break;
        case(MACRO_FLOOR):
            result=floor(dq);
            break;
        case(MACRO_FIX):
            opq=dq;
            result=opq;
            break;
        case(MACRO_FUP):
            opq=dq;
            if(opq<0)
            {
                opr=-1;
            }else{
                opr=1;
            }
            result=ceil(fabs(dq))*opr;
            break;
        case(MACRO_LN):
            if(dq<0)
            {
                err=GERR_VALUE_INVALID;
            }else{
                result=log(dq);
            }
            break;
        case(MACRO_EXP):
            result=exp(dq);
            break;
        case(MACRO_SIGN):
            if(fabs(dq)<0.00001)
            {
                result=0;
            }else if(dq>0){
                result=1;
            }else if(dq<0){
                result=-1;
            }else{
                result=0;
            }
            break;
        case(MACRO_MOD):
            opq=dq;
            opr=dr;
            if(opr==0)
            {
                err=GERR_VALUE_INVALID;
            }else{
                result=opq%opr;
            }
            break;
        case(MACRO_BIT_NOT):
            opq=dq;
            result=~opq;
            break;
        case(MACRO_SIN):
            dq=PI*dq/180;
            result=sin(dq);
            break;
        case(MACRO_COS):
            dq=PI*dq/180;
            result=cos(dq);
            break;
        case(MACRO_TAN):
            opq=dq;
            if((opq+90)%(180)==0)
            {
                err=GERR_VALUE_INVALID;
            }else{
                dq=PI*dq/180;
                result=tan(dq);
            }
            break;
        case(MACRO_ASIN):
            if((dq>1)||(dq<-1))
            {
                err=GERR_VALUE_INVALID;
            }else{
                result=asin(dq)*180/PI;
            }
            break;
        case(MACRO_ACOS):
            if((dq>1)||(dq<-1))
            {
                err=GERR_VALUE_INVALID;
            }else{
                result=acos(dq)*180/PI;
            }
            break;
        case(MACRO_ATAN):
            result=atan(dq)*180/PI;
            break;
        case(MACRO_LESSTHAN):
            if(dq<dr)
            {
                result=1;
            }else{
                result=0;
            }
            break;
        case(MACRO_LESSOREQUAL):
            if((dq<=dr)||(fabs(dq-dr)<0.00001))
            {
                result=1;
            }else{
                result=0;
            }
            break;
        case(MACRO_GREATERTHAN):
            if(dq>dr)
            {
                result=1;
            }else{
                result=0;
            }
            break;
        case(MACRO_GREATEROREQUAL):
            if((dq>=dr)||(fabs(dq-dr)<0.00001))
            {
                result=1;
            }else{
                result=0;
            }
            break;
        case(MACRO_EQUAL):
            if((dq==dr)||(fabs(dq-dr)<0.00001))
            {
                result=1;
            }else{
                result=0;
            }
            break;
        case(MACRO_NOTEQUAL):
            if((dq==dr)||(fabs(dq-dr)<0.00001))
            {
                result=0;
            }else{
                result=1;
            }
            break;
        case(MACRO_GOTO):
            opq=dq;
            //opq=converAddr(opq);
            err=hcodeJumpTo(opq);
            if(err==GERR_OK)
            {
                return 1;
            }
            break;
        case(MACRO_IF_GOTO):
            opq=dq;
            if(opq|=0)
            {
                opr=dr;
                //opr=converAddr(opr);
                err=hcodeJumpTo(opr);
                if(err==GERR_OK)
                {
                    return 1;
                }
            }
            break;
        case(MACRO_ALARM):
            opq=dq;
            //opq=converAddr(opq);
            if(opq<32)
            {
                ALARM_GRP3|=(1<<(opq-1));
                return GERR_OK;
            }else{
                err=GERR_VALUE_INVALID;
            }
            break;
        case(MACRO_WAIT):
            if(waitBufClear()!=GERR_OK)
                return GERR_OK;//由于没有execGptr++;grunPtr++;adj=-1;G代码编译会不断进入此处直至前面G代码完成
            break;
        case(MACRO_JUDGE_JUMP):
            opq=dq;
            if(opq==0)
            {
                opr=dr;
                grunPtr=opr;
                execGptr=&compiledGbuf[grunPtr];
                return err;
            }
            break;
        case(MACRO_JUMP):
            opr=dr;
            grunPtr=opr;
            execGptr=&compiledGbuf[grunPtr];
            return err;
        case(MACRO_NOP):
            break;
        case(MACRO_AND):
            opq=dq;
            opr=dr;
            result=opq&&opr;
            break;
        case(MACRO_OR):
            opq=dq;
            opr=dr;
            result=opq||opr;
            break;
        case(MACRO_NOT):
            opq=dq;
            result=!opq;
            break;
        case(MACRO_MAX):
            result=dq>dr?dq:dr;
            break;
        case(MACRO_MIN):
            result=dq<dr?dq:dr;
            break;
        default:
            err=GERR_G_UNKOWN;
            break;
    }
    if(err!=GERR_OK)
    {
        Errsrc = execGptr->srcline;
        return err;
    }
    if(opptype==3)
    {
        macro_val[opp-MACRO_VAR_START]=result;
    }else{
        globalVar[opp]=result;
        hcodeWriteOP1(opp,opptype);
    }
    execGptr++;
    grunPtr++;
    *adj=-1;
    return err;
}
/***************************************************************************
*FUNCTION: gMcode20WorkCT()
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec the M20 code ,cal the workpiece and the time;
****************************************************************************
*/
U8 Mcode20WorkCT()
{
    PcompiledM m20=(PcompiledM)execGptr;
    /*
    if(!((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER)
    &&(STDruncount>=(STDsendcount-1))
    &&(CYCLE_BUF_EMPTY(TCGwptr, TCGrptr))
    &&(CYCLE_BUF_EMPTY(DGwptr, DGrptr))))
    {
        if(pushTCGcounter<1)
        {
            pushTCGbyFaitG01();
            pushTCGcounter++;
        }
        return GERR_OK;
    }
    pushTCGcounter=0;
    */
    if(waitBufClear()!=GERR_OK)
        return GERR_OK;

    {
    U32 timeUsed=OSGetTimeTick();
    cutTimePiece=(timeUsed-cutTimeReg)/100;
    workPieceCT++;
    IIC_Write4(IICADDR_WORKPIECE, workPieceCT);
    cutTimeCT+=cutTimePiece;
    cutTimePieceRecord=cutTimePiece;
    cutTimeReg=OSGetTimeTick();
    IIC_Write4(IICADDR_CUT_TIME, cutTimeCT);
    m20flag=1; //mark this flag, so that we wont't cal again in m30
    //record file operation count
    if(machLockFlag==0)
    {
        fileOPrecord[fileOPptr].count++;
        IIC_Write4(IICADDR_FILEOP_CT+fileOPptr*4, fileOPrecord[fileOPptr].count);
    }
    }
    execGptr++;
    grunPtr++;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: M91RETURN
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec the m91 JUMP CODE, it base the auto/half auto input
****************************************************************************
*/

U8 M91return(void)
{
    PcompiledM pm91=(PcompiledM)execGptr;
    U32 callParam=pm91->value;
    U32 i;
    /*
    if(!((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER)
    &&(STDruncount>=(STDsendcount-1))
    &&(CYCLE_BUF_EMPTY(TCGwptr, TCGrptr))
    &&(CYCLE_BUF_EMPTY(DGwptr, DGrptr))))
    {
        if(pushTCGcounter<1)
        {
            pushTCGbyFaitG01();
            pushTCGcounter++;
        }
        return GERR_OK;
    }
    pushTCGcounter=0;
    */
    if(waitBufClear()!=GERR_OK)
        return GERR_OK;

//    if(PLC_SIG_HALFAUTO_BT) //jump to giver n tag
    if(0)
    {
        for(i=0;i<jumpPointCount;i++)
        {
            if((gcallStack[callDeep].callerProg==jumpPointList[i].prog)
            &&(callParam==jumpPointList[i].tag))
            {
                gC2TCState.currentProg=gcallStack[callDeep].callerProg;
                grunPtr=jumpPointList[i].address;
                execGptr=&compiledGbuf[grunPtr];
                DEBUGMSG(1,"M91 returning to %d \n",gcallStack[callDeep].beCallProg);
                return GERR_OK;
            }
        }
        return GERR_NO_TAG;
    }else {
        execGptr++;
        grunPtr++;
        return GERR_OK;
    }
}
/***************************************************************************
*FUNCTION: M98Call
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec the m98 sub program call gcode
****************************************************************************
*/
U8 M98Call(void)
{
    PcompiledM pm98=(PcompiledM)execGptr;
    U32 callParam=pm98->value;
    U32 callTime=1;
    U32 callProg=0;
    U32 caller;
    U32 i;
    if(waitBufClear()!=GERR_OK)
        return GERR_OK;
    if(callDeep!=0)
    {
        caller=gcallStack[callDeep-1].beCallProg;
    }else{
        /*
        if(programCount<=2) //only the sub program is named
        {
            caller=programList[0].index;
        }else{
            caller=0;   //main loop
        }*/
        caller=programList[0].index;
    }
    if(callParam>10000) // just call one time
    {  //THERE should not be 10000
        callProg=callParam%10000;
        callTime=(callParam-callProg)/10000;
    }else{
        callProg=callParam;
    }
    if(callDeep==CALL_DEEP_MAX)
    {
        DEBUGMSG(1,"Over max sub porgram call Deep\n");
        return GERR_STACK_OVF;
    }
    gcallStack[callDeep].callerProg=caller;
    gcallStack[callDeep].beCallProg=callProg;
    gC2TCState.currentProg=callProg;
    gcallStack[callDeep].callTimes=callTime-1; //we had call once here
    //gcallStack[callDeep].jumpPointIndex=i;
    //Find start address in sub program list
    for(i=0;i<programCount;i++)
    {
        if(callProg==programList[i].index)
        {
            gcallStack[callDeep].startAddress=programList[i].address;
            break;
        }
    }
    if(i==programCount)
    {
        DEBUGMSG(1,"M98 calling not exict program %d\n",callProg);
        return GERR_NO_TAG;
    }
    if((callProg>PREDEF_PROG_START)
    &&(callProg<(PREDEF_PROG_START+PREDEF_PROG_MAX)))
    {
        O9XXXsrc=pm98->srcline;
        O9XXXrunptr=grunPtr;
        O9XXXruning=1;
    }
    //gcallStack[callDeep].startAddress=m98Request[i].address;
    gcallStack[callDeep].returnPtr=grunPtr+1;
    grunPtr=gcallStack[callDeep].startAddress;
    execGptr=&compiledGbuf[grunPtr];
    callDeep++;
    DEBUGMSG(1,"M98:prog %d call %d, %d cycles,deep %d\n",
        caller,callProg,callTime,callDeep);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: M99return
*PARAMETER :void
*RETURN : void
*DESCRIPTION: exec the m99 sub program return gcode
****************************************************************************
*/
U8 M99return(void)
{
    PcompiledM pm99=(PcompiledM)execGptr;
    U32 i;
    U32 callParam=pm99->value;
    if(waitBufClear()!=GERR_OK)
        return GERR_OK;
    if(callDeep!=0)
    {
        if(gcallStack[callDeep-1].callTimes>0)
        {  //still loop in sub program
            grunPtr=gcallStack[callDeep-1].startAddress;
            execGptr=&compiledGbuf[grunPtr];
            gcallStack[callDeep-1].callTimes--;
            DEBUGMSG(1,"M99 cycle %d\n",gcallStack[callDeep-1].callTimes);
            return GERR_OK;
        }
        O9XXXruning=0;
        if(callDeep==macro_calldeep_record[macro_calldeep_record_index-1])
        {
            memcpy(globalVar,(macro_local_val[macro_calldeep_record_index-1]),MACRO_LOCAL_VAR_MAX*8);
            macro_calldeep_record_index--;
        }
    }
    if(callParam==0) //default return
    {
        if(callDeep==0)
        {
            // IF IO_AUTO is 0 restart the program; else sent a m30
//            if(!PLC_SIG_HALFAUTO_BT)
            if(1)
            {
                if(m15end==0)
                {
                    if(trace_virtual_run==1)
                    {//虚拟运行遇到G99循环就退出
                        M302TCG();
                        return GERR_OK;
                    }
                    grunPtr=0;
                    execGptr=&compiledGbuf[0];
                    return GERR_OK;
                }else{
                    M302TCG();
                    return GERR_OK;
                }
            }else{
                //=m30
                M302TCG();
                return GERR_OK;
            }
        }
        callDeep--;
        gC2TCState.currentProg=gcallStack[callDeep].callerProg;
        grunPtr=gcallStack[callDeep].returnPtr;
        execGptr=&compiledGbuf[grunPtr];
        DEBUGMSG(1,"M99 returning from %d to %d \n",
            gcallStack[callDeep].beCallProg,gcallStack[callDeep].callerProg);
        return GERR_OK;
    }else{ //find where to go
        if(callDeep!=0)
            callDeep--;
        else  //clear the be call program
            gcallStack[callDeep].beCallProg=0;
        for(i=0;i<jumpPointCount;i++)
        {
            if((gcallStack[callDeep].callerProg==jumpPointList[i].prog)
            &&(callParam==jumpPointList[i].tag))
            {
                gC2TCState.currentProg=gcallStack[callDeep].callerProg;
                grunPtr=jumpPointList[i].address;
                execGptr=&compiledGbuf[grunPtr];
                DEBUGMSG(1,"M99 returning from %d to %d tag %d\n",
                    gcallStack[callDeep].beCallProg,gcallStack[callDeep].callerProg,callParam);
                return GERR_OK;
            }
        }
        return GERR_NO_TAG;
        DEBUGMSG(1,"M99 specified address can't be found %d \n",callParam);
    }
}
/***************************************************************************
*FUNCTION: M15cycle
*PARAMETER :void
*RETURN : void
*DESCRIPTION: handle m15 code ,if p and not set yet ,set it;if setted ,cal the times
****************************************************************************
*/
U8 M15cycle()
{
    PcompiledM pm15=(PcompiledM)execGptr;
    if(waitBufClear()!=GERR_OK)
    return GERR_OK;
    if(m15init)
    {
        m15init=0;
        m15end=0;
        m15cycleTime=pm15->value;
    }
    if(m15cycleTime>0)
        m15cycleTime--;
    if(m15cycleTime==0)
        m15end=1;

    execGptr++;
    grunPtr++;
    return GERR_OK;
}
U8 g65Call()
{
    PcompiledG23 hmacro=(PcompiledG23)execGptr;
    U32 callParam;
    U32 callTime=1;
    U32 callProg=0;
    U32 caller;
    U32 i;
    if(waitBufClear()!=GERR_OK)
        return GERR_OK;
    if(hmacro->r==1)
    {
        if(macro_calldeep_record_index>=MACRO_IF_LAYER_MAX)
        {
            return GERR_STACK_OVF;
        }
        macro_calldeep_record[macro_calldeep_record_index]=callDeep+1;
        memcpy((macro_local_val[macro_calldeep_record_index]),globalVar,MACRO_LOCAL_VAR_MAX*8);
        memset(globalVar,0,MACRO_LOCAL_VAR_MAX*8);
        macro_calldeep_record_index++;
        execGptr++;
        grunPtr++;
        return GERR_OK;
    }
    if(hmacro->r!=2)
    {
        return 10;
    }
    callParam=hmacro->xu;
    callTime=hmacro->zw;
    if(callDeep!=0)
    {
        caller=gcallStack[callDeep-1].beCallProg;
    }else{
        caller=programList[0].index;
    }
    if(callParam>10000) // just call one time
    {  //THERE should not be 10000
        callProg=callParam%10000;
        callTime=(callParam-callProg)/10000;
    }else{
        callProg=callParam;
    }
    if(callDeep==CALL_DEEP_MAX)
    {
        DEBUGMSG(1,"Over max sub porgram call Deep\n");
        return GERR_STACK_OVF;
    }
    gcallStack[callDeep].callerProg=caller;
    gcallStack[callDeep].beCallProg=callProg;
    gC2TCState.currentProg=callProg;
    gcallStack[callDeep].callTimes=callTime-1; //we had call once here
    //gcallStack[callDeep].jumpPointIndex=i;
    //Find start address in sub program list
    for(i=0;i<programCount;i++)
    {
        if(callProg==programList[i].index)
        {
            gcallStack[callDeep].startAddress=programList[i].address;
            break;
        }
    }
    if(i==programCount)
    {
        DEBUGMSG(1,"M98 calling not exict program %d\n",callProg);
        return GERR_NO_TAG;
    }
    //gcallStack[callDeep].startAddress=m98Request[i].address;
    gcallStack[callDeep].returnPtr=grunPtr+1;
    grunPtr=gcallStack[callDeep].startAddress;
    execGptr=&compiledGbuf[grunPtr];
    callDeep++;
    DEBUGMSG(1,"G65:prog %d call %d, %d cycles,deep %d\n",
        caller,callProg,callTime,callDeep);
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: pushTCGbyFaitG01
*PARAMETER :void
*RETURN : void
*DESCRIPTION: make a fait g01 code with zero move to pust prev codes
* out of TCP buffer
****************************************************************************
*/
void pushTCGbyFaitG01(void)
{
    //make a fait line code to push code out in TCP buffer
    PcompiledM pg23=(PcompiledM)execGptr;
    TTCGmcode m31;
    m31.gnum=GCODE_M31;
    m31.sendCount=STDsendcount;
    m31.srcLine=pg23->srcline;
    m31.srcCode=grunPtr;
    *((PTCGmcode)&TCGbuf[TCGwptr])=m31;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    return;
}
/***************************************************************************
*FUNCTION: pushTCGbyFait_MDI
*PARAMETER :void
*RETURN : void
*DESCRIPTION:  MDI end
****************************************************************************
*/
void pushTCGbyFait_MDI(void)
{
    //make a fait line code to push code out in TCP buffer
    PcompiledM pg23=(PcompiledM)execGptr;
    TTCGmcode m30;
    m30.gnum=GCODE_M30;
    m30.sendCount=STDsendcount;
    m30.srcLine=pg23->srcline;
    m30.srcCode=grunPtr;
    *((PTCGmcode)&TCGbuf[TCGwptr])=m30;
    CYCLE_BUF_WINC(TCGwptr, TCG_BUF_MAX);
    return;
}
/***************************************************************************
*FUNCTION: waitBufClear
*PARAMETER :void
*RETURN : void
*DESCRIPTION: wait prev generated code to be done
****************************************************************************
*/
U8 waitBufClear(void)
{
    if(trace_virtual_run)
    {//虚拟运行不发送代码，所以不能等待
        return GERR_OK;
    }
    if(!((DSPState&BIT_CODE_OVER)&&(DSPState&BIT_LOCA_OVER)
    &&(STDruncount>=(STDsendcount-1))
    &&(CYCLE_BUF_EMPTY(TCGwptr, TCGrptr))
    &&(CYCLE_BUF_EMPTY(DGwptr, DGrptr))))
    {
        if(pushTCGcounter<1)
        {
            pushTCGbyFaitG01();
            pushTCGcounter++;
        }
        return 1;
    }
    pushTCGcounter=0;
    return GERR_OK;
}
/***************************************************************************
*FUNCTION: toolCompent
*PARAMETER :void
*RETURN : void
*DESCRIPTION: for now ,this function simulate the tool compent process
****************************************************************************
*/
void toolCompent(void )
{
    static U32 realRunCT=0;
    PTCGarc tcgptr; //pointer to the TCGbuf
    //PDGarc  dgptr;
    PTCGline glineptr;
    PTCGarc garcptr;
    PTCGfst fstptr;
    PTCGmcode mptr;

    U8 onegcode;
    U8 ct;
    if(CYCLE_BUF_EMPTY(TCGwptr, TCGrptr))
    {
        if(gexecState==GEXEC_READE)
        {
            gexecState=GEXEC_DONE;
        }
        return;
    }
    //DBMSG_GCODE("fait tool compent start\n");
    for(ct=0;ct<TCG_BUF_MAX;ct++)
    {
        if(CYCLE_BUF_EMPTY(TCGwptr, TCGrptr))
        {
            break;
        }
        //it must at lease have 5 buf space to store one g and it's mfst
        tcgptr=(PTCGarc)&(TCGbuf[TCGrptr]);
        switch((tcgptr->gnum))
        {
           case (GCODE_M03):
           case (GCODE_M04):
           case (GCODE_M05):
           case (GCODE_M06):
           case (GCODE_M07):
           case (GCODE_M08):
           case (GCODE_M19):
           case (GCODE_M32):
           case (GCODE_M33):
           case (GCODE_M30):
           case (GCODE_M41):
           case (GCODE_M42):
           case (GCODE_M43):
           case (GCODE_M44):
           case (GCODE_M254):
           case (GCODE_M255):
               mptr=(PTCGmcode)tcgptr;
               //DEBUGMSG(1,"FTCP M 0x%04x, sendcount %ld, rct %ld\n",mptr->gnum,mptr->sendCount,realRunCT++);
               break;
           case (GCODE_F):
           case (GCODE_S):
           case (GCODE_T):
           case (GCODE_LOCATE):
           case (GCODE_04):
           case (GCODE_M50):
           case (GCODE_54):
           case (GCODE_96):
           case (GCODE_97):
           case (GCODE_98):
           case (GCODE_99):
           case (GCODE_M253):
               fstptr=(PTCGfst)tcgptr;
               //DEBUGMSG(1,"FTCP FST 0x%04x: val %ld, sendcount %ld, rct %ld\n",
               // fstptr->gnum,fstptr->value,fstptr->sendCount,realRunCT++);
               break;
           case (GCODE_00):
           case (GCODE_01):
           case (GCODE_50):
               onegcode=TRUE;
               glineptr=(PTCGline)tcgptr;
               //DEBUGMSG(1,"FTCP LINE :%d X %d,Z %d,sendcount %ld, rct %ld\n",
               // glineptr->gnum,glineptr->x,glineptr->z,glineptr->sendCount,realRunCT++);
               break;
           case (GCODE_02):
           case (GCODE_03):
               tcgptr=(PTCGarc)tcgptr;
              /* DEBUGMSG(1,"FTCP ARC %d: X %d,Z %d, I %d,K %d, R %d, send count %ld, rct %ld\n",
                    tcgptr->gnum, tcgptr->x,tcgptr->z,
                    tcgptr->i,tcgptr->k,tcgptr->r,tcgptr->sendCount,realRunCT++);
               */
               break;
           default:
               DBMSG_GCODE("FTCP unkonw gcode\n",tcgptr->gnum);

        }
        CYCLE_BUF_RINC(TCGrptr, TCG_BUF_MAX );
   }
   //DBMSG_GCODE("fait tool compent end\n");
}
/*
*------------------------------------------------------------------------------
* function: AutoRunStart
* parameter: void
* return   : void
* description : handle the run key press,start auto run
*------------------------------------------------------------------------------
*/
void autoRunStart(void)
{
        gexecState=GEXEC_CMPLE;
        execGptr=compiledGbuf;
        //guiUpdateReq=TRUE;
        grunPtr=0; //setto exec pointer to begin
        if((SYSparam[96].val==0)&&(autoBreakPoint.flag!=0))
        {
            grunPtr=autoBreakPoint.codeIndex;
            execGptr=&compiledGbuf[grunPtr];
            autoBreakPoint.flag=0;
            autoBreakPoint.codeIndex=0;
        }
        callDeep=0;
        //re init auto mode
        STDruncount=0;
        STDrealsendcount=0;
        STDsendcount=0;
        prevSrcLine=0;
        pushTCGcounter=0;
        compoundGcode=0;
        coordCurGend=coordWorkBack;
        coordSentedGend=coordWorkBack;
        coordGend[STDsendcount]=coordWorkBack;
        STDsendcount++;
        CYCLE_BUF_INIT(TCGwptr,TCGrptr); //empty all buffer
        CYCLE_BUF_INIT(DGwptr,DGrptr);
        CYCLE_BUF_INIT(SENDEDwptr,SENDEDrptr);
        //conver to program unit
        gC2TCState.x=meter4Digit2Unit(coordWorkBack.x);
        gC2TCState.z=meter4Digit2Unit(coordWorkBack.z);
        gC2TCState.y=meter4Digit2Unit(coordWorkBack.y);
        coordOrginWork.x=coordOrginWorkG5x[0].x+coordOrginWorkG5x[gWorkState.GG05].x;
        coordOrginWork.z=coordOrginWorkG5x[0].z+coordOrginWorkG5x[gWorkState.GG05].z;
        coordOrginWork.y=coordOrginWorkG5x[0].y+coordOrginWorkG5x[gWorkState.GG05].y;
        gC2TCState.orgx=meter4Digit2Unit(coordOrginWork.x);
        gC2TCState.orgz=meter4Digit2Unit(coordOrginWork.z);
        gC2TCState.orgy=meter4Digit2Unit(coordOrginWork.y);
        gC2TCState.t=gWorkState.t;
        {
        U8 index;
        index=gC2TCState.t%100;
        //gC2TCState.shiftx=meter4Digit2Unit(toolCompensation[index].x);
        gC2TCState.shiftx=meter4Digit2Unit(coordShiftWork.x);
        if(dimMode)
        {
            gC2TCState.x=gC2TCState.x*2;
            gC2TCState.orgx=gC2TCState.orgx*2;
            gC2TCState.shiftx*=2;
        }
        //gC2TCState.shiftz=meter4Digit2Unit(toolCompensation[index].z);
        gC2TCState.shiftz=meter4Digit2Unit(coordShiftWork.z);
        gC2TCState.shifty=meter4Digit2Unit(coordShiftWork.y);
        }
        gC2TCState.GG01=0;
        gC2TCState.GG02=gWorkState.GG02;
        gC2TCState.GG03=gWorkState.GG03; //default g code of group 3
        gC2TCState.GG04=gWorkState.GG04;
        gC2TCState.GG05=gWorkState.GG05;
        gC2TCState.GG06=gWorkState.GG06;
        gC2TCState.sdir=gWorkState.sdir; //clock sign;
        gC2TCState.f=0;//gWorkState.f;
        gC2TCState.s=gWorkState.s;
        if(gC2TCState.G96SpinspeedLimit==0)
            gC2TCState.G96SpinspeedLimit=SYSparam[168].val;
        gC2TCState.screwf=0;
        gC2TCState.screwHead=1;
        if(gC2TCState.f==0)
            gC2TCState.fseted=0;
        else
            gC2TCState.fseted=1;
        gC2TCState.chuck=gWorkState.chuck;
        gC2TCState.tail=gWorkState.tail;
        gC2TCState.m4x=gWorkState.m4x;
        m15init=1;
        m15end=0;

        if(coolSign==0)
            autoBreakPoint.m89=GCODE_M09;
        else
            autoBreakPoint.m89=GCODE_M08;
        autoBreakPoint.m1213=GCODE_M12;
        if(gC2TCState.sdir==3)
            autoBreakPoint.m345=GCODE_M03;
        else if(gC2TCState.sdir==4)
            autoBreakPoint.m345=GCODE_M04;
        else
            autoBreakPoint.m345=GCODE_M05;
        autoBreakPoint.fvalue=gWorkState.f;
        autoBreakPoint.t=gWorkState.t;
        autoBreakPoint.m4x=gWorkState.m4x;
        //autoBreakPoint.coord.x=gC2TCState.x;
        //autoBreakPoint.coord.z=gC2TCState.z;
        autoBreakPoint.coord= coordWorkBack;
        autoBreakPoint.sendCount=0;
        if(programCount!=0)
            gC2TCState.currentProg=programList[0].index;
        gWorkState=gC2TCState;
        spindleAutoStateChanged=FALSE;
        chuckAutoStateChanged=FALSE;
        tailAutoStateChanged=FALSE;
        SENDEDrptr=0;
        SENDEDwptr=0;
        sendedPtr=0;
        assistenFlag=0;
        assistStart=0;
        autoAssistenPlcRequest=0;
        addLineMode=0;
        macro_calldeep_record_index=0;
        memset(macro_calldeep_record,0,MACRO_IF_LAYER_MAX);
        memset(macro_local_val,0,MACRO_IF_LAYER_MAX*MACRO_LOCAL_VAR_MAX*8);
        Init_Toolcompen();
        //now turn to auto mode and run the code

        taskEventBuf[taskEventCount]=TEVENT_MOD_AUTO;//TEVENT_COORDORGSET;
        taskEventCount++;
        //record the start time
        cutTimeReg=OSGetTimeTick();
        //cutTimeReg=0;
        m20flag=0;
        gexecErrInsend=FALSE;
        //PLC_NCCMD_CHUCK_TIRE;
        //now turn to auto mode and run the code
        taskEventBuf[taskEventCount]=TEVENT_MOD_AUTO;//TEVENT_COORDORGSET;
        taskEventCount++;
        if(mdimode.inmdi==0&&trace_virtual_run==0)
        {//MDI或虚拟运行不需记录运行文件信息
            //record the start time
            cutTimeReg=OSGetTimeTick();
            //record file operation  time
//            fileOPrecord[fileOPptr].datetime=Get_Time32BIT();
            IIC_Write4(IICADDR_FILEOP_TIME+fileOPptr*4, fileOPrecord[fileOPptr].datetime);
            DEBUGMSG(1,"Auto run start\n");
        }
        if(((currentGUI>GUINUM_COORDS)&&(currentGUI!=GUINUM_SIMTRACE))
        ||(currentGUI==GUINUM_MAIN))
            if(mdimode.runO9XXX==0)
                currentGUI=GUINUM_COORDS;
		if((mdimode.inmdi)&&(mdimode.runO9XXX==0))
        {
            currentGUI=GUINUM_MDI;
        }
}



//////////////////////////////////////////////
//平面几何计算通用函数
/* 两点之间的距离，线段的长度 */
/*
int myround(double   indata,int   precision,double   outdata)
{
    if   (   indata> 0.00   )
        *outdata=(int)((indata*precision*10)+0.5)/100.00;
    else
        *outdata=(int)((indata*precision*10)-0.5)/100.00;
    return   0;
} */
int myround(double indata)
{
    if(indata>0)
        return (int)(indata+0.5);
    else
        return (int)(indata-0.5);
}
/*  把任意输入角度整形成+ - 180
*/
double angleRound(double angle)
{
    if(fabs(angle)>360.0L)
    {
        int i=angle;
        double tail=angle-i;
        i=i%360;
        angle=i+tail;
    }
    if(angle>180)
        angle=angle-360;
    else if(angle<-180)
        angle=360.0L+angle;
    return angle;
}
double DistanceOfPoints(Point A, Point B)
{
	return (double)sqrt((A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y));
}
/* 点到直线的距离 */
double DistanceOfPointToLine(Point P, Line l)
{
	double m = (double)sqrt(l.A * l.A + l.B * l.B);	// 分母
	double n = l.A * P.x + l.B * P.y + l.C;	// 分子
	if (n < 0)
		n = 0 - n;
	return n / m;
}
/* 向量的模，即向量的长度 */
double VectorLength(Vector v)
{
	return (double)sqrt(v.x * v.x + v.y * v.y);
}
/*
 * 由两个点构造一个向量
 */
Vector VectorConstruct(Point A, Point B)
{
	Vector v;
	v.x = B.x - A.x;
	v.y = B.y - A.y;
	return v;
}
/* 点是否在线段上: 距离判断 */
int PointIsOnSegment(Point P, Point A, Point B)
{
	double d1 = DistanceOfPoints(P, A);
	double d2 = DistanceOfPoints(P, B);
	double d3 = DistanceOfPoints(A, B);

	if ((d1 + d2 - d3)<0.1)
		return 1;
	else
		return 0;
}
/*知道直线上一点的一轴坐标值，求点另一轴坐标值*/
double PointOfLine(Line l, double xy, int isx)
{
    double result;
    if(isx==1)
    {
        /*if(l.B==0)
        {  //y为任意值
           return 0;
        }*/
        result=(0-l.C-l.A*xy)/l.B;
    }else{
        result=(0-l.C-l.B*xy)/l.A;
    }
    return result;
}
/*知道直线上一点的一轴坐标，求另外一轴坐标
*这里len是点3到点2的距离
* 如果没有这个点，返回flag=0 有为1
* flag 作为参数还负责传入是否 要跟chamferLenReg比较
* 1比较，0不比较。
*/
Point Point3(Point p1,Point p2, double len,U8* flag)
{
    Point p3;
    double segLen;
    segLen=DistanceOfPoints(p1,p2);
    if((len-segLen)>0.1)//浮点类型会有尾数误差，
    {
        *flag=GERR_CHAMFER_TOOBIG;
        return p3;
    }
    if(*flag==1) //首直线可能有倒角，要与chamferLenReg验算
    {
        if((len+chamferLenReg)>(segLen+1)) //浮点数的关系，允许1um误差
        {

            *flag=GERR_CHAMFER_TOOBIG;
            return p3;
        }
    }
    *flag=GERR_OK;
    if(len==segLen)
       return p1;
    if(len==0)
        return p2;
    //
    p3.x=(p1.x-p2.x)*len/segLen+p2.x;
    p3.y=(p1.y-p2.y)*len/segLen+p2.y;
    return p3;
}
/*两点构造直线*/
Line LineMake(Point A, Point B)
{
	Line l;
	l.A = B.y - A.y;
	l.B = A.x - B.x;
	l.C = B.x * A.y - A.x * B.y;
	return l;
}
/*点和斜率构造直线，为适应G代码输入，用的角度输入*/
Line LineMakeAngle(Point A, double angle)
{
    Line l;
    //需保证angel 在+-180内
    //化成+-90度
    /*
    if(angle<-90)
    {
        angle=angle+180;
    }else if(angle>90){
        angle=angle-180;
    }*/
    if(angle==0) //ZX坐标系 ，与xy的相反
    {
       l.A=1;
       l.B=0;
       l.C=0-A.x;
    }else if((angle==90)||(angle==-90))
    {
        l.A=0;
        l.B=1;
        l.C=0-A.y;
    }else{
	    l.A=1;//-tan(angle/180*PI);//xz的关系，
    	//l.A = B.y - A.y;
    	l.B = -tan(angle/180*PI);
    	l.C= 0-l.B*A.y-l.A*A.x;
    	//l.C = B.x * A.y - A.x * B.y;
	}
	return l;
}

/*求直线交点*/
Point LinesIntersection(Line m, Line n, U8 *flag)
{
	Point i;
	double d = n.A * m.B - m.A * n.B;
	if (d == 0)
	{
		*flag = 0;
		return i;
	}

	i.x = (n.B * m.C - m.B * n.C) / d;
	i.y = (m.A * n.C - n.A * m.C) / d;
	*flag = 1;
	return i;
}
/* 两直线的夹角，返回弧度值 */
double IncludedAngle(Line m, Line n)
{
    double result,t;
	double v = m.A * n.A + m.B * n.B;
	if (v == 0)	// 两直线垂直
		return PI/2;

	// 如果v=0, 则t为无穷大（输出则为inf. =infinity）
	// atan仍有返回值，为90度，并没有出错。
	t = (m.A*n.B-n.A*m.B) / v;
	if (t < 0)
	{
	    t = 0 - t;
	}
	result=atan(t);
	return result;
	//return atan(t) * 180 / PI;
}
//计算直线交点到垂足的距离
double crossLen(double r,Point p1,Point p2,Point p3)
{
    double len;
    double angle;
    Line l1,l2;
    l1=LineMake(p1,p2);
    l2=LineMake(p2,p3);
    angle=IncludedAngle(l1, l2);
    //所得为锐夹角，要判断是否是钝角
    //通过边长关系判断
    //a^2+b^2=c^2 90度，大于为锐角，小于为钝角
    {
    double sa,sb,sc; //边长平方
    sa=pow((p2.x-p1.x),2)+pow((p2.y-p1.y),2);
    sb=pow((p3.x-p2.x),2)+pow((p3.y-p2.y),2);
    sc=pow((p3.x-p1.x),2)+pow((p3.y-p1.y),2);
    if(sc>(sa+sb))
    {
       angle=PI-angle;  //钝角
    }
    }
    angle=angle/2;
    len=r/tan(angle);
    //printf("%f,%f\n",angle,tan(angle));
    return len;
}

//计算垂足位置
Point len2point(double len, Line l,Point p1,Point p2)
{
    Point result;
    double angle ;
    if(l.B==0)
        angle=PI/2;
    else if(l.A==0)
        angle=0;
    else
        angle=atan(l.A/l.B);

    result.x=len*cos(angle);
    result.y=len*sin(angle);
    //printf("  angle=%f,x=%f,y=%f\n",angle, result.x, result.y);
    if(p2.x>p1.x)
        result.x=p1.x+fabs(result.x);
    else
        result.x=p1.x-fabs(result.x);
    if(p2.y>p1.y)
        result.y=p1.y+fabs(result.y);
    else
        result.y=p1.y-fabs(result.y);

    return result ;
}
//新的方法通过直线拐向判别弧向

U8 arcDir(Point p1,Point p2,Point p3)
{
    U8 dir=judgeMoveSide(p1, p2, p3, 1);
    if(dir==0)  //(逆时针)摆角大于180度
        return 2; //逆弧
    else
        return 3; //顺弧
}
/*
//判断圆弧的顺逆方向:参数为起点，终点，圆心
U8 arcDirOld(Point s,Point e,Point c)
{
    U8 result;
    double x1,y1,x2,y2;
    U8 pos1,pos2; //两个向量的象限
    x1=s.x-c.x;
    y1=s.y-c.y;
    x2=e.x-c.x;
    y2=e.y-c.y;
    //列出所有可能组合
    if(x1>=0)
    {
        if(y1>=0)
            pos1=1;
        else
            pos1=4;
    }else{
        if(y1>=0)
            pos1=2;
        else
            pos1=3;
    }
    if(x2>=0)
    {
        if(y2>=0)
            pos2=1;
        else
            pos2=4;
    }else{
        if(y2>=0)
            pos2=2;
        else
            pos2=3;
    }
    if(pos1==1)
    {
        if(pos2==1)
        { //同象限 1
          if(x1>x2)
              result=3; //逆弧
          else
              result=2;
        }else if(pos2==2)
        {
            result=3;
        }else if(pos2==3)
        {
            if((0-x1)>x2)
                result=3;
            else
                result=2;
        }else if(pos2==4)
        {
            result=2;
        }
    }else if(pos1==2)
    {
        if(pos2==1)
        {
            result=2;
        }else if(pos2==2)
        {
            //同象限 1
            if(x1>x2)
                result=2;
            else
                result=3;
        }else if(pos2==3)
        {
            result=3;

        }else if(pos2==4)
        {
            if((0-x1)>x2)
                result=3;
            else
                result=2;
        }
    }else if(pos1==3)
    {
        if(pos2==1)
        { //同象限 1
          if((0-x1)>x2)
              result=3;
          else
              result=2;
        }else if(pos2==2)
        {
            result=2;
        }else if(pos2==3)
        {
            if(x1>x2)
                result=3;
            else
                result=2;
        }else if(pos2==4)
        {
            result=3;
        }
    }else if(pos1==4)
    {
        if(pos2==1)
        {
            result=3;
        }else if(pos2==2)
        {
            //同象限 1
            if((0-x1)>x2)
                result=3; //逆弧
            else
                result=2;
        }else if(pos2==3)
        {
            result=2;
        }else if(pos2==4)
        {
            if(x1>x2)
                result=2;
            else
                result=3;
        }
    }
    if(result==2) //与正常xy坐标刚好相反了
        result=3;
    else
        result=2;
    return result;
}
*/

//准备加入圆弧倒角
/* 计算点到直线的垂点 */
Point VerticalPoint(Point p, Line l)
{
	Point v;
	double tmp = l.A * l.A + l.B * l.B;
	v.x = (l.B * l.B * p.x - l.A * l.B * p.y - l.A * l.C) / tmp;
	v.y = (l.A * l.A * p.y - l.A * l.B * p.x - l.B * l.C) / tmp;

	return v;
}
//计算直线的矢量角度，即以终点减起点的角度,角度范围[0，360)
//入口:起点坐标结构体，终点坐标结构体
//出口:该条代码的起始矢量角度
double calLineAngle(Point Start_Point,Point End_Point)
{
	 double angle;
	 double delt_x;
	 double delt_z;
	 double delt;

	 delt_x=End_Point.x-Start_Point.x;
	 delt_z=End_Point.y-Start_Point.y;

     if((delt_x==0)&&(delt_z==0))
 	   angle=0;
	 if(delt_x==0)
	 	{
	 	 if(delt_z>0)
	 	   angle=0;
		 else
		   angle=180;
	 	}
	 if(delt_z==0)
	 	{
	 	 if(delt_x>0)
	 	    angle=90;
		 else
		 	angle=270;    //
	 	}
	 if(delt_z<0)   //第2、3象限
	 	{
	 	 angle=atan(delt_x/delt_z);  //弧度
	 	 angle=angle*180/PI;               //角度
		 angle+=180;                       //转到实际象限去
	 	}
	 if((delt_z>0)&&(delt_x>0))   //第1象限
	 	{
	 	 angle=atan(delt_x/delt_z);     //弧度
	 	 angle=angle*180/PI;
	 	}
	 if((delt_z>0)&&(delt_x<0))   //第4现象
	 	{
	 	 angle=atan(delt_x/delt_z);     //弧度
	 	 angle=angle*180/PI;
		 angle+=360;
	 	}
	 return angle;
}

//计算直线和圆弧相接时的走向，此算法从原刀补中移植
//原理为，直线斜率和圆弧起始角(起点到圆心的直线角)夹角，
//配合顺逆弧，可知交点切向方向。由于是对应刀补缩短型，可判断取那个直线。
//参数为直线起点，终点，圆心，弧向(2,3顺逆)
//返回 0，左 1 右//
U8 judgeMoveSide(Point p1,Point p2,Point p3,int dir)
{
    FLOAT64 del_angle;
    FLOAT64 Angle1,Angle2;
    U8    tool_compen_type;    //刀补类型 0 缩短 1伸长 2 插入型
    U8 Connection_type;
    Angle1=calLineAngle(p1, p2);

    Angle2=calLineAngle(p2, p3);
    switch(dir)
    {
        case 1: //直线
            //不变
            break;
        case 2:
        	Angle2=Angle2-90;
            if(Angle2<0)
            	Angle2+=360;
            break;
        case 3:
        	Angle2=Angle2+90;
            if(Angle2>=360)
            	Angle2-=360;
            	break;
        default:
            return 2; //出错或是顺切圆，都返回2 不能继续计算
            break;
    }

    del_angle=180+Angle1-Angle2;
    if(del_angle<0)
        del_angle+=360;
    if(del_angle>=360)
        del_angle-=360;                //求得工件实体转角
    if(del_angle==0)
        return 2;//这个情况不能做倒角

    if(del_angle<=180)
    {
        if((del_angle==180)&&(dir==2))  //
            return 0;
        return 1; //左偏移，相当g41
    }else
    {
        return 0; //41
    }
    return 2;
}

//----对圆弧做标准变换，因为圆弧的G代码是给两种类型，需要统一-------
//---------入口:Cal_code单元，圆弧半径值,圆弧转向------------
//---------出口:圆心坐标值---------------------------
Point calArcCenter(Point StartPoint,Point EndPoint, double radius,int dir)
{
    double R1,R2,Real_r;
    double Angle;
    double Middle_x,Middle_z;
    Point Middle,CenterPoint;
    Real_r=radius;
    Middle.x=(StartPoint.x+EndPoint.x)/2;
    Middle.y=(StartPoint.y+EndPoint.y)/2;
    R1=sqrt(pow((EndPoint.x-Middle.x),2)+pow((EndPoint.y-Middle.y),2));
    R2=sqrt(Real_r*Real_r-R1*R1);
    if(dir==2)
        Angle=calLineAngle(StartPoint,EndPoint);  //顺圆弧
    else
        Angle=calLineAngle(EndPoint,StartPoint);  //逆弧要反向
    CenterPoint.y=round(Middle.y+R2*sin(Angle*PI/180));
    CenterPoint.x=round(Middle.x-R2*cos(Angle*PI/180));
    return CenterPoint;
}


//计算接圆中心
//参数为直线起点，终点，圆心，弧半径，切圆半径，弧向(2,3顺逆)
Point calCenterPoint(Point p1,Point p2,Point p3,
    double radius,double radius2,int arcDir,int cutDir)
{
    Point Vector;
    double delt_angle;
    double Angle_aom;
    double angleA,angleB,SinAngleA,CosAngleA;
    double OE,OC;
    double O1O2,O1C,O2C;
    U8 Connection_type;
    angleA=calLineAngle(p1,p2);
    angleB=calLineAngle(p3,p2);
    SinAngleA=sin(angleA*PI/180);
    CosAngleA=cos(angleA*PI/180);
    Angle_aom=angleB-(angleA+90);     //即角度AOM,直线1逆转90度可以与另一根线重合
    switch(arcDir)
    {
    case 2:         //G01--G02
        if(cutDir==0)
    	{
			//Angle_aom=Next.StartAngle-(Current.StartAngle+90);     //即角度AOM,直线1逆转90度可以与另一根线重合
			//OE=Next.Radius*cos(Angle_aom*PI/180);
    		OE=radius*cos(Angle_aom*PI/180);
    		OC=radius+radius2;
    		OE=OE+radius2;
    		Vector.y=-OE*SinAngleA-sqrt(OC*OC-OE*OE)*CosAngleA;
    		Vector.x=+OE*CosAngleA-sqrt(OC*OC-OE*OE)*SinAngleA;	//ch lly
    	}
        else if(cutDir==1)
    	{
    		OE=radius*cos(Angle_aom*PI/180);
    		OC=radius-radius2;
    		OE=OE-radius2;
    		Vector.y=-OE*SinAngleA+sqrt(OC*OC-OE*OE)*CosAngleA;   //ch lly
    		Vector.x=+OE*CosAngleA+sqrt(OC*OC-OE*OE)*SinAngleA;
    	}


    	// 2
        break;
    case 3:   //G01--G03
        if(cutDir==0)
    	{
    		OE=radius*cos(Angle_aom*PI/180);
    		OC=radius-radius2;
    		OE=OE+radius2;
    		Vector.y=-OE*SinAngleA+sqrt(OC*OC-OE*OE)*CosAngleA;
    		Vector.x=+OE*CosAngleA+sqrt(OC*OC-OE*OE)*SinAngleA;	//ch lly
    	}
        else if(cutDir==1)
    	{
    		OE=radius*cos(Angle_aom*PI/180);
    		OC=radius+radius2;
    		OE=OE-radius2;
    		Vector.y=-OE*SinAngleA-sqrt(OC*OC-OE*OE)*CosAngleA;   //ch lly
    		Vector.x=+OE*CosAngleA-sqrt(OC*OC-OE*OE)*SinAngleA;
    	}
        break;
    }
    Vector.x+=p3.x;
    Vector.y+=p3.y;
    return Vector;
}

//通过两圆圆心构造直线，求切点
Point calArcIntersectionPoint(Point center1,Point center2,double radius)
{
    double angle;
    Point Vector;
    angle=calLineAngle(center1,center2);
    Vector.x=center1.x+radius*sin(angle*PI/180);
    Vector.y=center1.y+radius*cos(angle*PI/180);
    return Vector;
}

//判断圆上一点是否在某段弧上
//参数为圆弧起点，终点，圆心，和要判别的点
//方法是看mp的角度是否在起始和终止角之间
//否返回0,是返回1
S32 pointInArc(Point sp,Point ep,Point cp, Point mp,U8 arcdir)
{

    double angleS,angleE,angleM;
    angleS=calLineAngle(cp,sp);
    angleE=calLineAngle(cp,ep);
    angleM=calLineAngle(cp,mp);
    if(arcdir==2) //顺弧 //as>ae;
    {
        if(angleS<angleE) //过0度
        {
            if(((angleM>=0)&&(angleM<angleS)) //0- s
                ||((angleM>angleE)&&(angleM<360)))
                return 1;
        }else if((angleM>angleE)&&(angleM<angleS))
            return 1;
    }else if(arcdir==3) //逆弧 as<ae
    {
        if(angleE<angleS)
        {
            if(((angleM>=0)&&(angleM<angleE)) //0- E
                ||((angleM>angleS)&&(angleM<360)))
                return 1;
        }else if((angleM>angleS)&&(angleM<angleE))
            return 1;
    }
    return 0;
}
